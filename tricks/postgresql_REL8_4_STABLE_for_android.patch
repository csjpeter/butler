diff --git a/Android.mk b/Android.mk
new file mode 100644
index 0000000..28775a1
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,8 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+subdirs := $(addprefix $(LOCAL_PATH)/,$(addsuffix /Android.mk, \
+                src \
+        ))
+
+include $(subdirs)
diff --git a/README.android b/README.android
new file mode 100644
index 0000000..9949bdb
--- /dev/null
+++ b/README.android
@@ -0,0 +1,45 @@
+
+This solutions is based on psqldroid patches downloaded from
+http://code.google.com/p/psqldroid/downloads/list
+
+The original instructions were:
+
+	download & configure the Android source tree
+	download postgresql-8.4.1
+	download the psqldroid patch
+	extract the postgres archive and move the directory to external/postgresql
+		under your Android source tree
+	change into the external/postgresql directory
+	apply the psqldroid patch
+	run 'sh create-symbolic-links.sh'
+	change to the root of the android source tree
+	make psql 
+
+	Notes:
+		This is known to work with the Android Donut release, but probably others as well
+		Once the compilation completes, you will find binaries under target/out/... 
+
+What I did:
+
+	unpacked the downloaded psqldroid-20100106.patch.gz and renamed the created
+			directoy postgresql to postgresql-droid
+	I checked out postgresql git repository
+			git clone git://git.postgresql.org/git/postgresql.git
+	stepped in and created a branch named psqldroid_8.4
+			git checkout -t -b psqldroid_8.4_2 origin/REL8_4_STABLE
+	applied the patch by
+		for f in $(find ../postgresql-droid/ | grep "\.diff$"); do patch -p1 < $f; done
+	run create-symbolic-links.sh and then removed it
+		bash create-symbolic-links.sh && rm create-symbolic-links.sh
+	and added new files created so far
+			git add -f .
+			(some were ignored by gitignores I guess because those
+			were to be generated in some way)
+	made a git commit, so the rest can be tracked in git log
+
+For compiling you will need android SDK, NDK.
+Set your ANDROID_HOME to your android sdk path.
+Also you will need openssl-android. You should put its git repo next to your postgresql directory.
+	git clone https://github.com/scottt/openssl-android.git
+	It had last commit id 98ea02b773a647e2fd935bee50fdaa310b7f447d when I was checking it out.
+Now you can try to compile by using 'ndk-build' script from you android NDK directory.
diff --git a/jni b/jni
new file mode 120000
index 0000000..6a04314
--- /dev/null
+++ b/jni
@@ -0,0 +1 @@
+./
\ No newline at end of file
diff --git a/src/Android.mk b/src/Android.mk
new file mode 100644
index 0000000..32c4236
--- /dev/null
+++ b/src/Android.mk
@@ -0,0 +1,11 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+subdirs := $(addprefix $(LOCAL_PATH)/,$(addsuffix /Android.mk, \
+	port \
+	interfaces/libpq \
+	))
+
+#	bin/psql
+
+include $(subdirs)
diff --git a/src/backend/utils/Android.mk b/src/backend/utils/Android.mk
new file mode 100644
index 0000000..28775a1
--- /dev/null
+++ b/src/backend/utils/Android.mk
@@ -0,0 +1,8 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+subdirs := $(addprefix $(LOCAL_PATH)/,$(addsuffix /Android.mk, \
+                src \
+        ))
+
+include $(subdirs)
diff --git a/src/backend/utils/fmgroids.h b/src/backend/utils/fmgroids.h
new file mode 100644
index 0000000..8e1bd0b
--- /dev/null
+++ b/src/backend/utils/fmgroids.h
@@ -0,0 +1,1881 @@
+/*-------------------------------------------------------------------------
+ *
+ * fmgroids.h
+ *    Macros that define the OIDs of built-in functions.
+ *
+ * These macros can be used to avoid a catalog lookup when a specific
+ * fmgr-callable function needs to be referenced.
+ *
+ * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * NOTES
+ *	******************************
+ *	*** DO NOT EDIT THIS FILE! ***
+ *	******************************
+ *
+ *	It has been GENERATED by Gen_fmgrtab.sh
+ *	from ../../../src/include/catalog/pg_proc.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef FMGROIDS_H
+#define FMGROIDS_H
+
+/*
+ *	Constant macros for the OIDs of entries in pg_proc.
+ *
+ *	NOTE: macros are named after the prosrc value, ie the actual C name
+ *	of the implementing function, not the proname which may be overloaded.
+ *	For example, we want to be able to assign different macro names to both
+ *	char_text() and name_text() even though these both appear with proname
+ *	'text'.  If the same C function appears in more than one pg_proc entry,
+ *	its equivalent macro will be defined with the lowest OID among those
+ *	entries.
+ */
+#define F_BYTEAOUT 31
+#define F_CHAROUT 33
+#define F_NAMEIN 34
+#define F_NAMEOUT 35
+#define F_INT2IN 38
+#define F_INT2OUT 39
+#define F_INT2VECTORIN 40
+#define F_INT2VECTOROUT 41
+#define F_INT4IN 42
+#define F_INT4OUT 43
+#define F_REGPROCIN 44
+#define F_REGPROCOUT 45
+#define F_TEXTIN 46
+#define F_TEXTOUT 47
+#define F_TIDIN 48
+#define F_TIDOUT 49
+#define F_XIDIN 50
+#define F_XIDOUT 51
+#define F_CIDIN 52
+#define F_CIDOUT 53
+#define F_OIDVECTORIN 54
+#define F_OIDVECTOROUT 55
+#define F_BOOLLT 56
+#define F_BOOLGT 57
+#define F_BOOLEQ 60
+#define F_CHAREQ 61
+#define F_NAMEEQ 62
+#define F_INT2EQ 63
+#define F_INT2LT 64
+#define F_INT4EQ 65
+#define F_INT4LT 66
+#define F_TEXTEQ 67
+#define F_XIDEQ 68
+#define F_CIDEQ 69
+#define F_CHARNE 70
+#define F_CHARLE 72
+#define F_CHARGT 73
+#define F_CHARGE 74
+#define F_CHARTOI4 77
+#define F_I4TOCHAR 78
+#define F_NAMEREGEXEQ 79
+#define F_BOOLNE 84
+#define F_PGSQL_VERSION 89
+#define F_EQSEL 101
+#define F_NEQSEL 102
+#define F_SCALARLTSEL 103
+#define F_SCALARGTSEL 104
+#define F_EQJOINSEL 105
+#define F_NEQJOINSEL 106
+#define F_SCALARLTJOINSEL 107
+#define F_SCALARGTJOINSEL 108
+#define F_UNKNOWNIN 109
+#define F_UNKNOWNOUT 110
+#define F_NUMERIC_FAC 111
+#define F_BOX_ABOVE_EQ 115
+#define F_BOX_BELOW_EQ 116
+#define F_POINT_IN 117
+#define F_POINT_OUT 118
+#define F_LSEG_IN 119
+#define F_LSEG_OUT 120
+#define F_PATH_IN 121
+#define F_PATH_OUT 122
+#define F_BOX_IN 123
+#define F_BOX_OUT 124
+#define F_BOX_OVERLAP 125
+#define F_BOX_GE 126
+#define F_BOX_GT 127
+#define F_BOX_EQ 128
+#define F_BOX_LT 129
+#define F_BOX_LE 130
+#define F_POINT_ABOVE 131
+#define F_POINT_LEFT 132
+#define F_POINT_RIGHT 133
+#define F_POINT_BELOW 134
+#define F_POINT_EQ 135
+#define F_ON_PB 136
+#define F_ON_PPATH 137
+#define F_BOX_CENTER 138
+#define F_AREASEL 139
+#define F_AREAJOINSEL 140
+#define F_INT4MUL 141
+#define F_INT4NE 144
+#define F_INT2NE 145
+#define F_INT2GT 146
+#define F_INT4GT 147
+#define F_INT2LE 148
+#define F_INT4LE 149
+#define F_INT4GE 150
+#define F_INT2GE 151
+#define F_INT2MUL 152
+#define F_INT2DIV 153
+#define F_INT4DIV 154
+#define F_INT2MOD 155
+#define F_INT4MOD 156
+#define F_TEXTNE 157
+#define F_INT24EQ 158
+#define F_INT42EQ 159
+#define F_INT24LT 160
+#define F_INT42LT 161
+#define F_INT24GT 162
+#define F_INT42GT 163
+#define F_INT24NE 164
+#define F_INT42NE 165
+#define F_INT24LE 166
+#define F_INT42LE 167
+#define F_INT24GE 168
+#define F_INT42GE 169
+#define F_INT24MUL 170
+#define F_INT42MUL 171
+#define F_INT24DIV 172
+#define F_INT42DIV 173
+#define F_INT2PL 176
+#define F_INT4PL 177
+#define F_INT24PL 178
+#define F_INT42PL 179
+#define F_INT2MI 180
+#define F_INT4MI 181
+#define F_INT24MI 182
+#define F_INT42MI 183
+#define F_OIDEQ 184
+#define F_OIDNE 185
+#define F_BOX_SAME 186
+#define F_BOX_CONTAIN 187
+#define F_BOX_LEFT 188
+#define F_BOX_OVERLEFT 189
+#define F_BOX_OVERRIGHT 190
+#define F_BOX_RIGHT 191
+#define F_BOX_CONTAINED 192
+#define F_FLOAT4IN 200
+#define F_FLOAT4OUT 201
+#define F_FLOAT4MUL 202
+#define F_FLOAT4DIV 203
+#define F_FLOAT4PL 204
+#define F_FLOAT4MI 205
+#define F_FLOAT4UM 206
+#define F_FLOAT4ABS 207
+#define F_FLOAT4_ACCUM 208
+#define F_FLOAT4LARGER 209
+#define F_FLOAT4SMALLER 211
+#define F_INT4UM 212
+#define F_INT2UM 213
+#define F_FLOAT8IN 214
+#define F_FLOAT8OUT 215
+#define F_FLOAT8MUL 216
+#define F_FLOAT8DIV 217
+#define F_FLOAT8PL 218
+#define F_FLOAT8MI 219
+#define F_FLOAT8UM 220
+#define F_FLOAT8ABS 221
+#define F_FLOAT8_ACCUM 222
+#define F_FLOAT8LARGER 223
+#define F_FLOAT8SMALLER 224
+#define F_LSEG_CENTER 225
+#define F_PATH_CENTER 226
+#define F_POLY_CENTER 227
+#define F_DROUND 228
+#define F_DTRUNC 229
+#define F_DSQRT 230
+#define F_DCBRT 231
+#define F_DPOW 232
+#define F_DEXP 233
+#define F_DLOG1 234
+#define F_I2TOD 235
+#define F_I2TOF 236
+#define F_DTOI2 237
+#define F_FTOI2 238
+#define F_LINE_DISTANCE 239
+#define F_ABSTIMEIN 240
+#define F_ABSTIMEOUT 241
+#define F_RELTIMEIN 242
+#define F_RELTIMEOUT 243
+#define F_TIMEPL 244
+#define F_TIMEMI 245
+#define F_TINTERVALIN 246
+#define F_TINTERVALOUT 247
+#define F_INTINTERVAL 248
+#define F_TINTERVALREL 249
+#define F_TIMENOW 250
+#define F_ABSTIMEEQ 251
+#define F_ABSTIMENE 252
+#define F_ABSTIMELT 253
+#define F_ABSTIMEGT 254
+#define F_ABSTIMELE 255
+#define F_ABSTIMEGE 256
+#define F_RELTIMEEQ 257
+#define F_RELTIMENE 258
+#define F_RELTIMELT 259
+#define F_RELTIMEGT 260
+#define F_RELTIMELE 261
+#define F_RELTIMEGE 262
+#define F_TINTERVALSAME 263
+#define F_TINTERVALCT 264
+#define F_TINTERVALOV 265
+#define F_TINTERVALLENEQ 266
+#define F_TINTERVALLENNE 267
+#define F_TINTERVALLENLT 268
+#define F_TINTERVALLENGT 269
+#define F_TINTERVALLENLE 270
+#define F_TINTERVALLENGE 271
+#define F_TINTERVALSTART 272
+#define F_TINTERVALEND 273
+#define F_TIMEOFDAY 274
+#define F_ABSTIME_FINITE 275
+#define F_INTER_SL 277
+#define F_INTER_LB 278
+#define F_FLOAT48MUL 279
+#define F_FLOAT48DIV 280
+#define F_FLOAT48PL 281
+#define F_FLOAT48MI 282
+#define F_FLOAT84MUL 283
+#define F_FLOAT84DIV 284
+#define F_FLOAT84PL 285
+#define F_FLOAT84MI 286
+#define F_FLOAT4EQ 287
+#define F_FLOAT4NE 288
+#define F_FLOAT4LT 289
+#define F_FLOAT4LE 290
+#define F_FLOAT4GT 291
+#define F_FLOAT4GE 292
+#define F_FLOAT8EQ 293
+#define F_FLOAT8NE 294
+#define F_FLOAT8LT 295
+#define F_FLOAT8LE 296
+#define F_FLOAT8GT 297
+#define F_FLOAT8GE 298
+#define F_FLOAT48EQ 299
+#define F_FLOAT48NE 300
+#define F_FLOAT48LT 301
+#define F_FLOAT48LE 302
+#define F_FLOAT48GT 303
+#define F_FLOAT48GE 304
+#define F_FLOAT84EQ 305
+#define F_FLOAT84NE 306
+#define F_FLOAT84LT 307
+#define F_FLOAT84LE 308
+#define F_FLOAT84GT 309
+#define F_FLOAT84GE 310
+#define F_FTOD 311
+#define F_DTOF 312
+#define F_I2TOI4 313
+#define F_I4TOI2 314
+#define F_INT2VECTOREQ 315
+#define F_I4TOD 316
+#define F_DTOI4 317
+#define F_I4TOF 318
+#define F_FTOI4 319
+#define F_WIDTH_BUCKET_FLOAT8 320
+#define F_HASH_ACLITEM 329
+#define F_BTGETTUPLE 330
+#define F_BTINSERT 331
+#define F_BTBULKDELETE 332
+#define F_BTBEGINSCAN 333
+#define F_BTRESCAN 334
+#define F_BTENDSCAN 335
+#define F_BTMARKPOS 336
+#define F_BTRESTRPOS 337
+#define F_BTBUILD 338
+#define F_POLY_SAME 339
+#define F_POLY_CONTAIN 340
+#define F_POLY_LEFT 341
+#define F_POLY_OVERLEFT 342
+#define F_POLY_OVERRIGHT 343
+#define F_POLY_RIGHT 344
+#define F_POLY_CONTAINED 345
+#define F_POLY_OVERLAP 346
+#define F_POLY_IN 347
+#define F_POLY_OUT 348
+#define F_BTINT2CMP 350
+#define F_BTINT4CMP 351
+#define F_BTFLOAT4CMP 354
+#define F_BTFLOAT8CMP 355
+#define F_BTOIDCMP 356
+#define F_BTABSTIMECMP 357
+#define F_BTCHARCMP 358
+#define F_BTNAMECMP 359
+#define F_BTTEXTCMP 360
+#define F_LSEG_DISTANCE 361
+#define F_LSEG_INTERPT 362
+#define F_DIST_PS 363
+#define F_DIST_PB 364
+#define F_DIST_SB 365
+#define F_CLOSE_PS 366
+#define F_CLOSE_PB 367
+#define F_CLOSE_SB 368
+#define F_ON_PS 369
+#define F_PATH_DISTANCE 370
+#define F_DIST_PPATH 371
+#define F_ON_SB 372
+#define F_INTER_SB 373
+#define F_CASH_CMP 377
+#define F_ARRAY_PUSH 378
+#define F_BTRELTIMECMP 380
+#define F_BTTINTERVALCMP 381
+#define F_BTARRAYCMP 382
+#define F_ARRAY_CAT 383
+#define F_ARRAY_NE 390
+#define F_ARRAY_LT 391
+#define F_ARRAY_GT 392
+#define F_ARRAY_LE 393
+#define F_TEXT_TO_ARRAY 394
+#define F_ARRAY_TO_TEXT 395
+#define F_ARRAY_GE 396
+#define F_HASHINT2VECTOR 398
+#define F_HASHMACADDR 399
+#define F_HASHTEXT 400
+#define F_RTRIM1 401
+#define F_BTOIDVECTORCMP 404
+#define F_NAME_TEXT 406
+#define F_TEXT_NAME 407
+#define F_NAME_BPCHAR 408
+#define F_BPCHAR_NAME 409
+#define F_HASHINET 422
+#define F_HASHVACUUMCLEANUP 425
+#define F_HASH_NUMERIC 432
+#define F_MACADDR_IN 436
+#define F_MACADDR_OUT 437
+#define F_HASHCOSTESTIMATE 438
+#define F_HASHGETTUPLE 440
+#define F_HASHINSERT 441
+#define F_HASHBULKDELETE 442
+#define F_HASHBEGINSCAN 443
+#define F_HASHRESCAN 444
+#define F_HASHENDSCAN 445
+#define F_HASHMARKPOS 446
+#define F_HASHRESTRPOS 447
+#define F_HASHBUILD 448
+#define F_HASHINT2 449
+#define F_HASHINT4 450
+#define F_HASHFLOAT4 451
+#define F_HASHFLOAT8 452
+#define F_HASHOID 453
+#define F_HASHCHAR 454
+#define F_HASHNAME 455
+#define F_HASHVARLENA 456
+#define F_HASHOIDVECTOR 457
+#define F_TEXT_LARGER 458
+#define F_TEXT_SMALLER 459
+#define F_INT8IN 460
+#define F_INT8OUT 461
+#define F_INT8UM 462
+#define F_INT8PL 463
+#define F_INT8MI 464
+#define F_INT8MUL 465
+#define F_INT8DIV 466
+#define F_INT8EQ 467
+#define F_INT8NE 468
+#define F_INT8LT 469
+#define F_INT8GT 470
+#define F_INT8LE 471
+#define F_INT8GE 472
+#define F_INT84EQ 474
+#define F_INT84NE 475
+#define F_INT84LT 476
+#define F_INT84GT 477
+#define F_INT84LE 478
+#define F_INT84GE 479
+#define F_INT84 480
+#define F_INT48 481
+#define F_I8TOD 482
+#define F_DTOI8 483
+#define F_ARRAY_LARGER 515
+#define F_ARRAY_SMALLER 516
+#define F_INET_ABBREV 598
+#define F_CIDR_ABBREV 599
+#define F_INET_SET_MASKLEN 605
+#define F_OIDVECTORNE 619
+#define F_CIDR_SET_MASKLEN 635
+#define F_BTGETBITMAP 636
+#define F_HASHGETBITMAP 637
+#define F_GISTGETBITMAP 638
+#define F_I8TOF 652
+#define F_FTOI8 653
+#define F_NAMELT 655
+#define F_NAMELE 656
+#define F_NAMEGT 657
+#define F_NAMEGE 658
+#define F_NAMENE 659
+#define F_BPCHAR 668
+#define F_VARCHAR 669
+#define F_MKTINTERVAL 676
+#define F_OIDVECTORLT 677
+#define F_OIDVECTORLE 678
+#define F_OIDVECTOREQ 679
+#define F_OIDVECTORGE 680
+#define F_OIDVECTORGT 681
+#define F_NETWORK_NETWORK 683
+#define F_NETWORK_NETMASK 696
+#define F_NETWORK_MASKLEN 697
+#define F_NETWORK_BROADCAST 698
+#define F_NETWORK_HOST 699
+#define F_CURRENT_USER 710
+#define F_NETWORK_FAMILY 711
+#define F_INT82 714
+#define F_LO_CREATE 715
+#define F_OIDLT 716
+#define F_OIDLE 717
+#define F_BYTEAOCTETLEN 720
+#define F_BYTEAGETBYTE 721
+#define F_BYTEASETBYTE 722
+#define F_BYTEAGETBIT 723
+#define F_BYTEASETBIT 724
+#define F_DIST_PL 725
+#define F_DIST_LB 726
+#define F_DIST_SL 727
+#define F_DIST_CPOLY 728
+#define F_POLY_DISTANCE 729
+#define F_NETWORK_SHOW 730
+#define F_TEXT_LT 740
+#define F_TEXT_LE 741
+#define F_TEXT_GT 742
+#define F_TEXT_GE 743
+#define F_ARRAY_EQ 744
+#define F_SESSION_USER 746
+#define F_ARRAY_DIMS 747
+#define F_ARRAY_NDIMS 748
+#define F_ARRAY_IN 750
+#define F_ARRAY_OUT 751
+#define F_MACADDR_TRUNC 753
+#define F_INT28 754
+#define F_SMGRIN 760
+#define F_SMGROUT 761
+#define F_SMGREQ 762
+#define F_SMGRNE 763
+#define F_LO_IMPORT 764
+#define F_LO_EXPORT 765
+#define F_INT4INC 766
+#define F_LO_IMPORT_WITH_OID 767
+#define F_INT4LARGER 768
+#define F_INT4SMALLER 769
+#define F_INT2LARGER 770
+#define F_INT2SMALLER 771
+#define F_GISTCOSTESTIMATE 772
+#define F_GISTGETTUPLE 774
+#define F_GISTINSERT 775
+#define F_GISTBULKDELETE 776
+#define F_GISTBEGINSCAN 777
+#define F_GISTRESCAN 778
+#define F_GISTENDSCAN 779
+#define F_GISTMARKPOS 780
+#define F_GISTRESTRPOS 781
+#define F_GISTBUILD 782
+#define F_TINTERVALEQ 784
+#define F_TINTERVALNE 785
+#define F_TINTERVALLT 786
+#define F_TINTERVALGT 787
+#define F_TINTERVALLE 788
+#define F_TINTERVALGE 789
+#define F_PG_CLIENT_ENCODING 810
+#define F_CURRENT_QUERY 817
+#define F_MACADDR_EQ 830
+#define F_MACADDR_LT 831
+#define F_MACADDR_LE 832
+#define F_MACADDR_GT 833
+#define F_MACADDR_GE 834
+#define F_MACADDR_NE 835
+#define F_MACADDR_CMP 836
+#define F_INT82PL 837
+#define F_INT82MI 838
+#define F_INT82MUL 839
+#define F_INT82DIV 840
+#define F_INT28PL 841
+#define F_BTINT8CMP 842
+#define F_CASH_MUL_FLT4 846
+#define F_CASH_DIV_FLT4 847
+#define F_FLT4_MUL_CASH 848
+#define F_TEXTPOS 849
+#define F_TEXTLIKE 850
+#define F_TEXTNLIKE 851
+#define F_INT48EQ 852
+#define F_INT48NE 853
+#define F_INT48LT 854
+#define F_INT48GT 855
+#define F_INT48LE 856
+#define F_INT48GE 857
+#define F_NAMELIKE 858
+#define F_NAMENLIKE 859
+#define F_CHAR_BPCHAR 860
+#define F_CURRENT_DATABASE 861
+#define F_INT4_MUL_CASH 862
+#define F_INT2_MUL_CASH 863
+#define F_CASH_MUL_INT4 864
+#define F_CASH_DIV_INT4 865
+#define F_CASH_MUL_INT2 866
+#define F_CASH_DIV_INT2 867
+#define F_LOWER 870
+#define F_UPPER 871
+#define F_INITCAP 872
+#define F_LPAD 873
+#define F_RPAD 874
+#define F_LTRIM 875
+#define F_RTRIM 876
+#define F_TEXT_SUBSTR 877
+#define F_TRANSLATE 878
+#define F_LTRIM1 881
+#define F_TEXT_SUBSTR_NO_LEN 883
+#define F_BTRIM 884
+#define F_BTRIM1 885
+#define F_CASH_IN 886
+#define F_CASH_OUT 887
+#define F_CASH_EQ 888
+#define F_CASH_NE 889
+#define F_CASH_LT 890
+#define F_CASH_LE 891
+#define F_CASH_GT 892
+#define F_CASH_GE 893
+#define F_CASH_PL 894
+#define F_CASH_MI 895
+#define F_CASH_MUL_FLT8 896
+#define F_CASH_DIV_FLT8 897
+#define F_CASHLARGER 898
+#define F_CASHSMALLER 899
+#define F_INET_IN 910
+#define F_INET_OUT 911
+#define F_FLT8_MUL_CASH 919
+#define F_NETWORK_EQ 920
+#define F_NETWORK_LT 921
+#define F_NETWORK_LE 922
+#define F_NETWORK_GT 923
+#define F_NETWORK_GE 924
+#define F_NETWORK_NE 925
+#define F_NETWORK_CMP 926
+#define F_NETWORK_SUB 927
+#define F_NETWORK_SUBEQ 928
+#define F_NETWORK_SUP 929
+#define F_NETWORK_SUPEQ 930
+#define F_CASH_WORDS 935
+#define F_GENERATE_SERIES_TIMESTAMP 938
+#define F_GENERATE_SERIES_TIMESTAMPTZ 939
+#define F_INT28MI 942
+#define F_INT28MUL 943
+#define F_TEXT_CHAR 944
+#define F_INT8MOD 945
+#define F_CHAR_TEXT 946
+#define F_INT28DIV 948
+#define F_HASHINT8 949
+#define F_LO_OPEN 952
+#define F_LO_CLOSE 953
+#define F_LOREAD 954
+#define F_LOWRITE 955
+#define F_LO_LSEEK 956
+#define F_LO_CREAT 957
+#define F_LO_TELL 958
+#define F_ON_PL 959
+#define F_ON_SL 960
+#define F_CLOSE_PL 961
+#define F_CLOSE_SL 962
+#define F_CLOSE_LB 963
+#define F_LO_UNLINK 964
+#define F_BTVACUUMCLEANUP 972
+#define F_PATH_INTER 973
+#define F_BOX_AREA 975
+#define F_BOX_WIDTH 976
+#define F_BOX_HEIGHT 977
+#define F_BOX_DISTANCE 978
+#define F_PATH_AREA 979
+#define F_BOX_INTERSECT 980
+#define F_BOX_DIAGONAL 981
+#define F_PATH_N_LT 982
+#define F_PATH_N_GT 983
+#define F_PATH_N_EQ 984
+#define F_PATH_N_LE 985
+#define F_PATH_N_GE 986
+#define F_PATH_LENGTH 987
+#define F_POINT_NE 988
+#define F_POINT_VERT 989
+#define F_POINT_HORIZ 990
+#define F_POINT_DISTANCE 991
+#define F_POINT_SLOPE 992
+#define F_LSEG_CONSTRUCT 993
+#define F_LSEG_INTERSECT 994
+#define F_LSEG_PARALLEL 995
+#define F_LSEG_PERP 996
+#define F_LSEG_VERTICAL 997
+#define F_LSEG_HORIZONTAL 998
+#define F_LSEG_EQ 999
+#define F_LO_TRUNCATE 1004
+#define F_TIMESTAMPTZ_IZONE 1026
+#define F_ACLITEMIN 1031
+#define F_ACLITEMOUT 1032
+#define F_ACLINSERT 1035
+#define F_ACLREMOVE 1036
+#define F_ACLCONTAINS 1037
+#define F_GETDATABASEENCODING 1039
+#define F_BPCHARIN 1044
+#define F_BPCHAROUT 1045
+#define F_VARCHARIN 1046
+#define F_VARCHAROUT 1047
+#define F_BPCHAREQ 1048
+#define F_BPCHARLT 1049
+#define F_BPCHARLE 1050
+#define F_BPCHARGT 1051
+#define F_BPCHARGE 1052
+#define F_BPCHARNE 1053
+#define F_ACLITEM_EQ 1062
+#define F_BPCHAR_LARGER 1063
+#define F_BPCHAR_SMALLER 1064
+#define F_PG_PREPARED_XACT 1065
+#define F_GENERATE_SERIES_STEP_INT4 1066
+#define F_GENERATE_SERIES_INT4 1067
+#define F_GENERATE_SERIES_STEP_INT8 1068
+#define F_GENERATE_SERIES_INT8 1069
+#define F_BPCHARCMP 1078
+#define F_TEXT_REGCLASS 1079
+#define F_HASHBPCHAR 1080
+#define F_FORMAT_TYPE 1081
+#define F_DATE_IN 1084
+#define F_DATE_OUT 1085
+#define F_DATE_EQ 1086
+#define F_DATE_LT 1087
+#define F_DATE_LE 1088
+#define F_DATE_GT 1089
+#define F_DATE_GE 1090
+#define F_DATE_NE 1091
+#define F_DATE_CMP 1092
+#define F_TIME_LT 1102
+#define F_TIME_LE 1103
+#define F_TIME_GT 1104
+#define F_TIME_GE 1105
+#define F_TIME_NE 1106
+#define F_TIME_CMP 1107
+#define F_DATE_LARGER 1138
+#define F_DATE_SMALLER 1139
+#define F_DATE_MI 1140
+#define F_DATE_PLI 1141
+#define F_DATE_MII 1142
+#define F_TIME_IN 1143
+#define F_TIME_OUT 1144
+#define F_TIME_EQ 1145
+#define F_CIRCLE_ADD_PT 1146
+#define F_CIRCLE_SUB_PT 1147
+#define F_CIRCLE_MUL_PT 1148
+#define F_CIRCLE_DIV_PT 1149
+#define F_TIMESTAMPTZ_IN 1150
+#define F_TIMESTAMPTZ_OUT 1151
+#define F_TIMESTAMP_EQ 1152
+#define F_TIMESTAMP_NE 1153
+#define F_TIMESTAMP_LT 1154
+#define F_TIMESTAMP_LE 1155
+#define F_TIMESTAMP_GE 1156
+#define F_TIMESTAMP_GT 1157
+#define F_TIMESTAMPTZ_ZONE 1159
+#define F_INTERVAL_IN 1160
+#define F_INTERVAL_OUT 1161
+#define F_INTERVAL_EQ 1162
+#define F_INTERVAL_NE 1163
+#define F_INTERVAL_LT 1164
+#define F_INTERVAL_LE 1165
+#define F_INTERVAL_GE 1166
+#define F_INTERVAL_GT 1167
+#define F_INTERVAL_UM 1168
+#define F_INTERVAL_PL 1169
+#define F_INTERVAL_MI 1170
+#define F_TIMESTAMPTZ_PART 1171
+#define F_INTERVAL_PART 1172
+#define F_ABSTIME_TIMESTAMPTZ 1173
+#define F_DATE_TIMESTAMPTZ 1174
+#define F_INTERVAL_JUSTIFY_HOURS 1175
+#define F_RELTIME_INTERVAL 1177
+#define F_TIMESTAMPTZ_DATE 1178
+#define F_ABSTIME_DATE 1179
+#define F_TIMESTAMPTZ_ABSTIME 1180
+#define F_XID_AGE 1181
+#define F_TIMESTAMP_MI 1188
+#define F_TIMESTAMPTZ_PL_INTERVAL 1189
+#define F_TIMESTAMPTZ_MI_INTERVAL 1190
+#define F_GENERATE_SUBSCRIPTS 1191
+#define F_GENERATE_SUBSCRIPTS_NODIR 1192
+#define F_ARRAY_FILL 1193
+#define F_INTERVAL_RELTIME 1194
+#define F_TIMESTAMP_SMALLER 1195
+#define F_TIMESTAMP_LARGER 1196
+#define F_INTERVAL_SMALLER 1197
+#define F_INTERVAL_LARGER 1198
+#define F_TIMESTAMPTZ_AGE 1199
+#define F_INTERVAL_SCALE 1200
+#define F_TIMESTAMPTZ_TRUNC 1217
+#define F_INTERVAL_TRUNC 1218
+#define F_INT8INC 1219
+#define F_INT8ABS 1230
+#define F_INT8LARGER 1236
+#define F_INT8SMALLER 1237
+#define F_TEXTICREGEXEQ 1238
+#define F_TEXTICREGEXNE 1239
+#define F_NAMEICREGEXEQ 1240
+#define F_NAMEICREGEXNE 1241
+#define F_BOOLIN 1242
+#define F_BOOLOUT 1243
+#define F_BYTEAIN 1244
+#define F_CHARIN 1245
+#define F_CHARLT 1246
+#define F_INT4ABS 1251
+#define F_NAMEREGEXNE 1252
+#define F_INT2ABS 1253
+#define F_TEXTREGEXEQ 1254
+#define F_TEXTREGEXNE 1256
+#define F_TEXTLEN 1257
+#define F_TEXTCAT 1258
+#define F_PG_CHAR_TO_ENCODING 1264
+#define F_TIDNE 1265
+#define F_CIDR_IN 1267
+#define F_BTCOSTESTIMATE 1268
+#define F_PG_COLUMN_SIZE 1269
+#define F_OVERLAPS_TIMETZ 1271
+#define F_DATETIME_TIMESTAMP 1272
+#define F_TIMETZ_PART 1273
+#define F_INT84PL 1274
+#define F_INT84MI 1275
+#define F_INT84MUL 1276
+#define F_INT84DIV 1277
+#define F_INT48PL 1278
+#define F_INT48MI 1279
+#define F_INT48MUL 1280
+#define F_INT48DIV 1281
+#define F_QUOTE_IDENT 1282
+#define F_QUOTE_LITERAL 1283
+#define F_ARRAY_FILL_WITH_LOWER_BOUNDS 1286
+#define F_I8TOOID 1287
+#define F_OIDTOI8 1288
+#define F_QUOTE_NULLABLE 1289
+#define F_SUPPRESS_REDUNDANT_UPDATES_TRIGGER 1291
+#define F_TIDEQ 1292
+#define F_CURRTID_BYRELOID 1293
+#define F_CURRTID_BYRELNAME 1294
+#define F_INTERVAL_JUSTIFY_DAYS 1295
+#define F_DATETIMETZ_TIMESTAMPTZ 1297
+#define F_NOW 1299
+#define F_POSITIONSEL 1300
+#define F_POSITIONJOINSEL 1301
+#define F_CONTSEL 1302
+#define F_CONTJOINSEL 1303
+#define F_OVERLAPS_TIMESTAMP 1304
+#define F_OVERLAPS_TIME 1308
+#define F_TIMESTAMP_IN 1312
+#define F_TIMESTAMP_OUT 1313
+#define F_TIMESTAMP_CMP 1314
+#define F_INTERVAL_CMP 1315
+#define F_TIMESTAMP_TIME 1316
+#define F_BPCHARLEN 1318
+#define F_INTERVAL_DIV 1326
+#define F_DLOG10 1339
+#define F_OIDVECTORTYPES 1349
+#define F_TIMETZ_IN 1350
+#define F_TIMETZ_OUT 1351
+#define F_TIMETZ_EQ 1352
+#define F_TIMETZ_NE 1353
+#define F_TIMETZ_LT 1354
+#define F_TIMETZ_LE 1355
+#define F_TIMETZ_GE 1356
+#define F_TIMETZ_GT 1357
+#define F_TIMETZ_CMP 1358
+#define F_NETWORK_HOSTMASK 1362
+#define F_MAKEACLITEM 1365
+#define F_TIME_INTERVAL 1370
+#define F_PG_LOCK_STATUS 1371
+#define F_DATE_FINITE 1373
+#define F_TEXTOCTETLEN 1374
+#define F_BPCHAROCTETLEN 1375
+#define F_TIME_LARGER 1377
+#define F_TIME_SMALLER 1378
+#define F_TIMETZ_LARGER 1379
+#define F_TIMETZ_SMALLER 1380
+#define F_TIME_PART 1385
+#define F_PG_GET_CONSTRAINTDEF 1387
+#define F_TIMESTAMPTZ_TIMETZ 1388
+#define F_TIMESTAMP_FINITE 1389
+#define F_INTERVAL_FINITE 1390
+#define F_PG_STAT_GET_BACKEND_START 1391
+#define F_PG_STAT_GET_BACKEND_CLIENT_ADDR 1392
+#define F_PG_STAT_GET_BACKEND_CLIENT_PORT 1393
+#define F_CURRENT_SCHEMA 1402
+#define F_CURRENT_SCHEMAS 1403
+#define F_LINE_PARALLEL 1412
+#define F_LINE_PERP 1413
+#define F_LINE_VERTICAL 1414
+#define F_LINE_HORIZONTAL 1415
+#define F_CIRCLE_CENTER 1416
+#define F_INTERVAL_TIME 1419
+#define F_POINTS_BOX 1421
+#define F_BOX_ADD 1422
+#define F_BOX_SUB 1423
+#define F_BOX_MUL 1424
+#define F_BOX_DIV 1425
+#define F_CIDR_OUT 1427
+#define F_POLY_CONTAIN_PT 1428
+#define F_PT_CONTAINED_POLY 1429
+#define F_PATH_ISCLOSED 1430
+#define F_PATH_ISOPEN 1431
+#define F_PATH_NPOINTS 1432
+#define F_PATH_CLOSE 1433
+#define F_PATH_OPEN 1434
+#define F_PATH_ADD 1435
+#define F_PATH_ADD_PT 1436
+#define F_PATH_SUB_PT 1437
+#define F_PATH_MUL_PT 1438
+#define F_PATH_DIV_PT 1439
+#define F_CONSTRUCT_POINT 1440
+#define F_POINT_ADD 1441
+#define F_POINT_SUB 1442
+#define F_POINT_MUL 1443
+#define F_POINT_DIV 1444
+#define F_POLY_NPOINTS 1445
+#define F_POLY_BOX 1446
+#define F_POLY_PATH 1447
+#define F_BOX_POLY 1448
+#define F_PATH_POLY 1449
+#define F_CIRCLE_IN 1450
+#define F_CIRCLE_OUT 1451
+#define F_CIRCLE_SAME 1452
+#define F_CIRCLE_CONTAIN 1453
+#define F_CIRCLE_LEFT 1454
+#define F_CIRCLE_OVERLEFT 1455
+#define F_CIRCLE_OVERRIGHT 1456
+#define F_CIRCLE_RIGHT 1457
+#define F_CIRCLE_CONTAINED 1458
+#define F_CIRCLE_OVERLAP 1459
+#define F_CIRCLE_BELOW 1460
+#define F_CIRCLE_ABOVE 1461
+#define F_CIRCLE_EQ 1462
+#define F_CIRCLE_NE 1463
+#define F_CIRCLE_LT 1464
+#define F_CIRCLE_GT 1465
+#define F_CIRCLE_LE 1466
+#define F_CIRCLE_GE 1467
+#define F_CIRCLE_AREA 1468
+#define F_CIRCLE_DIAMETER 1469
+#define F_CIRCLE_RADIUS 1470
+#define F_CIRCLE_DISTANCE 1471
+#define F_CR_CIRCLE 1473
+#define F_POLY_CIRCLE 1474
+#define F_CIRCLE_POLY 1475
+#define F_DIST_PC 1476
+#define F_CIRCLE_CONTAIN_PT 1477
+#define F_PT_CONTAINED_CIRCLE 1478
+#define F_BOX_CIRCLE 1479
+#define F_CIRCLE_BOX 1480
+#define F_LSEG_NE 1482
+#define F_LSEG_LT 1483
+#define F_LSEG_LE 1484
+#define F_LSEG_GT 1485
+#define F_LSEG_GE 1486
+#define F_LSEG_LENGTH 1487
+#define F_CLOSE_LS 1488
+#define F_CLOSE_LSEG 1489
+#define F_LINE_IN 1490
+#define F_LINE_OUT 1491
+#define F_LINE_EQ 1492
+#define F_LINE_CONSTRUCT_PP 1493
+#define F_LINE_INTERPT 1494
+#define F_LINE_INTERSECT 1495
+#define F_BIT_IN 1564
+#define F_BIT_OUT 1565
+#define F_PG_GET_RULEDEF 1573
+#define F_NEXTVAL_OID 1574
+#define F_CURRVAL_OID 1575
+#define F_SETVAL_OID 1576
+#define F_VARBIT_IN 1579
+#define F_VARBIT_OUT 1580
+#define F_BITEQ 1581
+#define F_BITNE 1582
+#define F_BITGE 1592
+#define F_BITGT 1593
+#define F_BITLE 1594
+#define F_BITLT 1595
+#define F_BITCMP 1596
+#define F_PG_ENCODING_TO_CHAR 1597
+#define F_DRANDOM 1598
+#define F_SETSEED 1599
+#define F_DASIN 1600
+#define F_DACOS 1601
+#define F_DATAN 1602
+#define F_DATAN2 1603
+#define F_DSIN 1604
+#define F_DCOS 1605
+#define F_DTAN 1606
+#define F_DCOT 1607
+#define F_DEGREES 1608
+#define F_RADIANS 1609
+#define F_DPI 1610
+#define F_INTERVAL_MUL 1618
+#define F_PG_TYPEOF 1619
+#define F_ASCII 1620
+#define F_CHR 1621
+#define F_REPEAT 1622
+#define F_SIMILAR_ESCAPE 1623
+#define F_MUL_D_INTERVAL 1624
+#define F_TEXTICLIKE 1633
+#define F_TEXTICNLIKE 1634
+#define F_NAMEICLIKE 1635
+#define F_NAMEICNLIKE 1636
+#define F_LIKE_ESCAPE 1637
+#define F_OIDGT 1638
+#define F_OIDGE 1639
+#define F_PG_GET_VIEWDEF_NAME 1640
+#define F_PG_GET_VIEWDEF 1641
+#define F_PG_GET_USERBYID 1642
+#define F_PG_GET_INDEXDEF 1643
+#define F_RI_FKEY_CHECK_INS 1644
+#define F_RI_FKEY_CHECK_UPD 1645
+#define F_RI_FKEY_CASCADE_DEL 1646
+#define F_RI_FKEY_CASCADE_UPD 1647
+#define F_RI_FKEY_RESTRICT_DEL 1648
+#define F_RI_FKEY_RESTRICT_UPD 1649
+#define F_RI_FKEY_SETNULL_DEL 1650
+#define F_RI_FKEY_SETNULL_UPD 1651
+#define F_RI_FKEY_SETDEFAULT_DEL 1652
+#define F_RI_FKEY_SETDEFAULT_UPD 1653
+#define F_RI_FKEY_NOACTION_DEL 1654
+#define F_RI_FKEY_NOACTION_UPD 1655
+#define F_PG_GET_TRIGGERDEF 1662
+#define F_PG_GET_SERIAL_SEQUENCE 1665
+#define F_BITAND 1673
+#define F_BITOR 1674
+#define F_BITXOR 1675
+#define F_BITNOT 1676
+#define F_BITSHIFTLEFT 1677
+#define F_BITSHIFTRIGHT 1678
+#define F_BITCAT 1679
+#define F_BITSUBSTR 1680
+#define F_BITLENGTH 1681
+#define F_BITOCTETLENGTH 1682
+#define F_BITFROMINT4 1683
+#define F_BITTOINT4 1684
+#define F_BIT 1685
+#define F_PG_GET_KEYWORDS 1686
+#define F_VARBIT 1687
+#define F_TIME_HASH 1688
+#define F_FLATFILE_UPDATE_TRIGGER 1689
+#define F_TIME_MI_TIME 1690
+#define F_BOOLLE 1691
+#define F_BOOLGE 1692
+#define F_BTBOOLCMP 1693
+#define F_TIMETZ_HASH 1696
+#define F_INTERVAL_HASH 1697
+#define F_BITPOSITION 1698
+#define F_NUMERIC_IN 1701
+#define F_NUMERIC_OUT 1702
+#define F_NUMERIC 1703
+#define F_NUMERIC_ABS 1704
+#define F_NUMERIC_SIGN 1706
+#define F_NUMERIC_ROUND 1707
+#define F_NUMERIC_TRUNC 1709
+#define F_NUMERIC_CEIL 1711
+#define F_NUMERIC_FLOOR 1712
+#define F_LENGTH_IN_ENCODING 1713
+#define F_PG_CONVERT_FROM 1714
+#define F_INET_TO_CIDR 1715
+#define F_PG_GET_EXPR 1716
+#define F_PG_CONVERT_TO 1717
+#define F_NUMERIC_EQ 1718
+#define F_NUMERIC_NE 1719
+#define F_NUMERIC_GT 1720
+#define F_NUMERIC_GE 1721
+#define F_NUMERIC_LT 1722
+#define F_NUMERIC_LE 1723
+#define F_NUMERIC_ADD 1724
+#define F_NUMERIC_SUB 1725
+#define F_NUMERIC_MUL 1726
+#define F_NUMERIC_DIV 1727
+#define F_NUMERIC_MOD 1728
+#define F_NUMERIC_SQRT 1730
+#define F_NUMERIC_EXP 1732
+#define F_NUMERIC_LN 1734
+#define F_NUMERIC_LOG 1736
+#define F_NUMERIC_POWER 1738
+#define F_INT4_NUMERIC 1740
+#define F_FLOAT4_NUMERIC 1742
+#define F_FLOAT8_NUMERIC 1743
+#define F_NUMERIC_INT4 1744
+#define F_NUMERIC_FLOAT4 1745
+#define F_NUMERIC_FLOAT8 1746
+#define F_TIME_PL_INTERVAL 1747
+#define F_TIME_MI_INTERVAL 1748
+#define F_TIMETZ_PL_INTERVAL 1749
+#define F_TIMETZ_MI_INTERVAL 1750
+#define F_NUMERIC_INC 1764
+#define F_SETVAL3_OID 1765
+#define F_NUMERIC_SMALLER 1766
+#define F_NUMERIC_LARGER 1767
+#define F_INTERVAL_TO_CHAR 1768
+#define F_NUMERIC_CMP 1769
+#define F_TIMESTAMPTZ_TO_CHAR 1770
+#define F_NUMERIC_UMINUS 1771
+#define F_NUMERIC_TO_CHAR 1772
+#define F_INT4_TO_CHAR 1773
+#define F_INT8_TO_CHAR 1774
+#define F_FLOAT4_TO_CHAR 1775
+#define F_FLOAT8_TO_CHAR 1776
+#define F_NUMERIC_TO_NUMBER 1777
+#define F_TO_TIMESTAMP 1778
+#define F_NUMERIC_INT8 1779
+#define F_TO_DATE 1780
+#define F_INT8_NUMERIC 1781
+#define F_INT2_NUMERIC 1782
+#define F_NUMERIC_INT2 1783
+#define F_OIDIN 1798
+#define F_OIDOUT 1799
+#define F_PG_CONVERT 1813
+#define F_ICLIKESEL 1814
+#define F_ICNLIKESEL 1815
+#define F_ICLIKEJOINSEL 1816
+#define F_ICNLIKEJOINSEL 1817
+#define F_REGEXEQSEL 1818
+#define F_LIKESEL 1819
+#define F_ICREGEXEQSEL 1820
+#define F_REGEXNESEL 1821
+#define F_NLIKESEL 1822
+#define F_ICREGEXNESEL 1823
+#define F_REGEXEQJOINSEL 1824
+#define F_LIKEJOINSEL 1825
+#define F_ICREGEXEQJOINSEL 1826
+#define F_REGEXNEJOINSEL 1827
+#define F_NLIKEJOINSEL 1828
+#define F_ICREGEXNEJOINSEL 1829
+#define F_FLOAT8_AVG 1830
+#define F_FLOAT8_VAR_SAMP 1831
+#define F_FLOAT8_STDDEV_SAMP 1832
+#define F_NUMERIC_ACCUM 1833
+#define F_INT2_ACCUM 1834
+#define F_INT4_ACCUM 1835
+#define F_INT8_ACCUM 1836
+#define F_NUMERIC_AVG 1837
+#define F_NUMERIC_VAR_SAMP 1838
+#define F_NUMERIC_STDDEV_SAMP 1839
+#define F_INT2_SUM 1840
+#define F_INT4_SUM 1841
+#define F_INT8_SUM 1842
+#define F_INTERVAL_ACCUM 1843
+#define F_INTERVAL_AVG 1844
+#define F_TO_ASCII_DEFAULT 1845
+#define F_TO_ASCII_ENC 1846
+#define F_TO_ASCII_ENCNAME 1847
+#define F_INT28EQ 1850
+#define F_INT28NE 1851
+#define F_INT28LT 1852
+#define F_INT28GT 1853
+#define F_INT28LE 1854
+#define F_INT28GE 1855
+#define F_INT82EQ 1856
+#define F_INT82NE 1857
+#define F_INT82LT 1858
+#define F_INT82GT 1859
+#define F_INT82LE 1860
+#define F_INT82GE 1861
+#define F_INT2AND 1892
+#define F_INT2OR 1893
+#define F_INT2XOR 1894
+#define F_INT2NOT 1895
+#define F_INT2SHL 1896
+#define F_INT2SHR 1897
+#define F_INT4AND 1898
+#define F_INT4OR 1899
+#define F_INT4XOR 1900
+#define F_INT4NOT 1901
+#define F_INT4SHL 1902
+#define F_INT4SHR 1903
+#define F_INT8AND 1904
+#define F_INT8OR 1905
+#define F_INT8XOR 1906
+#define F_INT8NOT 1907
+#define F_INT8SHL 1908
+#define F_INT8SHR 1909
+#define F_INT8UP 1910
+#define F_INT2UP 1911
+#define F_INT4UP 1912
+#define F_FLOAT4UP 1913
+#define F_FLOAT8UP 1914
+#define F_NUMERIC_UPLUS 1915
+#define F_HAS_TABLE_PRIVILEGE_NAME_NAME 1922
+#define F_HAS_TABLE_PRIVILEGE_NAME_ID 1923
+#define F_HAS_TABLE_PRIVILEGE_ID_NAME 1924
+#define F_HAS_TABLE_PRIVILEGE_ID_ID 1925
+#define F_HAS_TABLE_PRIVILEGE_NAME 1926
+#define F_HAS_TABLE_PRIVILEGE_ID 1927
+#define F_PG_STAT_GET_NUMSCANS 1928
+#define F_PG_STAT_GET_TUPLES_RETURNED 1929
+#define F_PG_STAT_GET_TUPLES_FETCHED 1930
+#define F_PG_STAT_GET_TUPLES_INSERTED 1931
+#define F_PG_STAT_GET_TUPLES_UPDATED 1932
+#define F_PG_STAT_GET_TUPLES_DELETED 1933
+#define F_PG_STAT_GET_BLOCKS_FETCHED 1934
+#define F_PG_STAT_GET_BLOCKS_HIT 1935
+#define F_PG_STAT_GET_BACKEND_IDSET 1936
+#define F_PG_STAT_GET_BACKEND_PID 1937
+#define F_PG_STAT_GET_BACKEND_DBID 1938
+#define F_PG_STAT_GET_BACKEND_USERID 1939
+#define F_PG_STAT_GET_BACKEND_ACTIVITY 1940
+#define F_PG_STAT_GET_DB_NUMBACKENDS 1941
+#define F_PG_STAT_GET_DB_XACT_COMMIT 1942
+#define F_PG_STAT_GET_DB_XACT_ROLLBACK 1943
+#define F_PG_STAT_GET_DB_BLOCKS_FETCHED 1944
+#define F_PG_STAT_GET_DB_BLOCKS_HIT 1945
+#define F_BINARY_ENCODE 1946
+#define F_BINARY_DECODE 1947
+#define F_BYTEAEQ 1948
+#define F_BYTEALT 1949
+#define F_BYTEALE 1950
+#define F_BYTEAGT 1951
+#define F_BYTEAGE 1952
+#define F_BYTEANE 1953
+#define F_BYTEACMP 1954
+#define F_TIMESTAMP_SCALE 1961
+#define F_INT2_AVG_ACCUM 1962
+#define F_INT4_AVG_ACCUM 1963
+#define F_INT8_AVG 1964
+#define F_OIDLARGER 1965
+#define F_OIDSMALLER 1966
+#define F_TIMESTAMPTZ_SCALE 1967
+#define F_TIME_SCALE 1968
+#define F_TIMETZ_SCALE 1969
+#define F_PG_STAT_GET_TUPLES_HOT_UPDATED 1972
+#define F_NUMERIC_DIV_TRUNC 1973
+#define F_BYTEALIKE 2005
+#define F_BYTEANLIKE 2006
+#define F_LIKE_ESCAPE_BYTEA 2009
+#define F_BYTEACAT 2011
+#define F_BYTEA_SUBSTR 2012
+#define F_BYTEA_SUBSTR_NO_LEN 2013
+#define F_BYTEAPOS 2014
+#define F_BYTEATRIM 2015
+#define F_TIMESTAMPTZ_TIME 2019
+#define F_TIMESTAMP_TRUNC 2020
+#define F_TIMESTAMP_PART 2021
+#define F_PG_STAT_GET_ACTIVITY 2022
+#define F_ABSTIME_TIMESTAMP 2023
+#define F_DATE_TIMESTAMP 2024
+#define F_PG_BACKEND_PID 2026
+#define F_TIMESTAMPTZ_TIMESTAMP 2027
+#define F_TIMESTAMP_TIMESTAMPTZ 2028
+#define F_TIMESTAMP_DATE 2029
+#define F_TIMESTAMP_ABSTIME 2030
+#define F_TIMESTAMP_PL_INTERVAL 2032
+#define F_TIMESTAMP_MI_INTERVAL 2033
+#define F_PG_CONF_LOAD_TIME 2034
+#define F_TIMETZ_ZONE 2037
+#define F_TIMETZ_IZONE 2038
+#define F_TIMESTAMP_HASH 2039
+#define F_TIMETZ_TIME 2046
+#define F_TIME_TIMETZ 2047
+#define F_TIMESTAMP_TO_CHAR 2049
+#define F_AGGREGATE_DUMMY 2050
+#define F_TIMESTAMP_AGE 2058
+#define F_TIMESTAMP_ZONE 2069
+#define F_TIMESTAMP_IZONE 2070
+#define F_DATE_PL_INTERVAL 2071
+#define F_DATE_MI_INTERVAL 2072
+#define F_TEXTREGEXSUBSTR 2073
+#define F_BITFROMINT8 2075
+#define F_BITTOINT8 2076
+#define F_SHOW_CONFIG_BY_NAME 2077
+#define F_SET_CONFIG_BY_NAME 2078
+#define F_PG_TABLE_IS_VISIBLE 2079
+#define F_PG_TYPE_IS_VISIBLE 2080
+#define F_PG_FUNCTION_IS_VISIBLE 2081
+#define F_PG_OPERATOR_IS_VISIBLE 2082
+#define F_PG_OPCLASS_IS_VISIBLE 2083
+#define F_SHOW_ALL_SETTINGS 2084
+#define F_REPLACE_TEXT 2087
+#define F_SPLIT_TEXT 2088
+#define F_TO_HEX32 2089
+#define F_TO_HEX64 2090
+#define F_ARRAY_LOWER 2091
+#define F_ARRAY_UPPER 2092
+#define F_PG_CONVERSION_IS_VISIBLE 2093
+#define F_PG_STAT_GET_BACKEND_ACTIVITY_START 2094
+#define F_PG_TERMINATE_BACKEND 2096
+#define F_PG_GET_FUNCTIONDEF 2098
+#define F_TEXT_PATTERN_LT 2160
+#define F_TEXT_PATTERN_LE 2161
+#define F_PG_GET_FUNCTION_ARGUMENTS 2162
+#define F_TEXT_PATTERN_GE 2163
+#define F_TEXT_PATTERN_GT 2164
+#define F_PG_GET_FUNCTION_RESULT 2165
+#define F_BTTEXT_PATTERN_CMP 2166
+#define F_PG_DATABASE_SIZE_NAME 2168
+#define F_WIDTH_BUCKET_NUMERIC 2170
+#define F_PG_CANCEL_BACKEND 2171
+#define F_PG_START_BACKUP 2172
+#define F_PG_STOP_BACKUP 2173
+#define F_BPCHAR_PATTERN_LT 2174
+#define F_BPCHAR_PATTERN_LE 2175
+#define F_ARRAY_LENGTH 2176
+#define F_BPCHAR_PATTERN_GE 2177
+#define F_BPCHAR_PATTERN_GT 2178
+#define F_BTBPCHAR_PATTERN_CMP 2180
+#define F_BTINT48CMP 2188
+#define F_BTINT84CMP 2189
+#define F_BTINT24CMP 2190
+#define F_BTINT42CMP 2191
+#define F_BTINT28CMP 2192
+#define F_BTINT82CMP 2193
+#define F_BTFLOAT48CMP 2194
+#define F_BTFLOAT84CMP 2195
+#define F_INET_CLIENT_ADDR 2196
+#define F_INET_CLIENT_PORT 2197
+#define F_INET_SERVER_ADDR 2198
+#define F_INET_SERVER_PORT 2199
+#define F_REGPROCEDUREIN 2212
+#define F_REGPROCEDUREOUT 2213
+#define F_REGOPERIN 2214
+#define F_REGOPEROUT 2215
+#define F_REGOPERATORIN 2216
+#define F_REGOPERATOROUT 2217
+#define F_REGCLASSIN 2218
+#define F_REGCLASSOUT 2219
+#define F_REGTYPEIN 2220
+#define F_REGTYPEOUT 2221
+#define F_PG_STAT_CLEAR_SNAPSHOT 2230
+#define F_PG_GET_FUNCTION_IDENTITY_ARGUMENTS 2232
+#define F_FMGR_INTERNAL_VALIDATOR 2246
+#define F_FMGR_C_VALIDATOR 2247
+#define F_FMGR_SQL_VALIDATOR 2248
+#define F_HAS_DATABASE_PRIVILEGE_NAME_NAME 2250
+#define F_HAS_DATABASE_PRIVILEGE_NAME_ID 2251
+#define F_HAS_DATABASE_PRIVILEGE_ID_NAME 2252
+#define F_HAS_DATABASE_PRIVILEGE_ID_ID 2253
+#define F_HAS_DATABASE_PRIVILEGE_NAME 2254
+#define F_HAS_DATABASE_PRIVILEGE_ID 2255
+#define F_HAS_FUNCTION_PRIVILEGE_NAME_NAME 2256
+#define F_HAS_FUNCTION_PRIVILEGE_NAME_ID 2257
+#define F_HAS_FUNCTION_PRIVILEGE_ID_NAME 2258
+#define F_HAS_FUNCTION_PRIVILEGE_ID_ID 2259
+#define F_HAS_FUNCTION_PRIVILEGE_NAME 2260
+#define F_HAS_FUNCTION_PRIVILEGE_ID 2261
+#define F_HAS_LANGUAGE_PRIVILEGE_NAME_NAME 2262
+#define F_HAS_LANGUAGE_PRIVILEGE_NAME_ID 2263
+#define F_HAS_LANGUAGE_PRIVILEGE_ID_NAME 2264
+#define F_HAS_LANGUAGE_PRIVILEGE_ID_ID 2265
+#define F_HAS_LANGUAGE_PRIVILEGE_NAME 2266
+#define F_HAS_LANGUAGE_PRIVILEGE_ID 2267
+#define F_HAS_SCHEMA_PRIVILEGE_NAME_NAME 2268
+#define F_HAS_SCHEMA_PRIVILEGE_NAME_ID 2269
+#define F_HAS_SCHEMA_PRIVILEGE_ID_NAME 2270
+#define F_HAS_SCHEMA_PRIVILEGE_ID_ID 2271
+#define F_HAS_SCHEMA_PRIVILEGE_NAME 2272
+#define F_HAS_SCHEMA_PRIVILEGE_ID 2273
+#define F_PG_STAT_RESET 2274
+#define F_TEXTREGEXREPLACE_NOOPT 2284
+#define F_TEXTREGEXREPLACE 2285
+#define F_PG_TOTAL_RELATION_SIZE 2286
+#define F_PG_SIZE_PRETTY 2288
+#define F_PG_OPTIONS_TO_TABLE 2289
+#define F_RECORD_IN 2290
+#define F_RECORD_OUT 2291
+#define F_CSTRING_IN 2292
+#define F_CSTRING_OUT 2293
+#define F_ANY_IN 2294
+#define F_ANY_OUT 2295
+#define F_ANYARRAY_IN 2296
+#define F_ANYARRAY_OUT 2297
+#define F_VOID_IN 2298
+#define F_VOID_OUT 2299
+#define F_TRIGGER_IN 2300
+#define F_TRIGGER_OUT 2301
+#define F_LANGUAGE_HANDLER_IN 2302
+#define F_LANGUAGE_HANDLER_OUT 2303
+#define F_INTERNAL_IN 2304
+#define F_INTERNAL_OUT 2305
+#define F_OPAQUE_IN 2306
+#define F_OPAQUE_OUT 2307
+#define F_DCEIL 2308
+#define F_DFLOOR 2309
+#define F_DSIGN 2310
+#define F_MD5_TEXT 2311
+#define F_ANYELEMENT_IN 2312
+#define F_ANYELEMENT_OUT 2313
+#define F_POSTGRESQL_FDW_VALIDATOR 2316
+#define F_MD5_BYTEA 2321
+#define F_PG_TABLESPACE_SIZE_OID 2322
+#define F_PG_TABLESPACE_SIZE_NAME 2323
+#define F_PG_DATABASE_SIZE_OID 2324
+#define F_ARRAY_UNNEST 2331
+#define F_PG_RELATION_SIZE 2332
+#define F_ARRAY_AGG_TRANSFN 2333
+#define F_ARRAY_AGG_FINALFN 2334
+#define F_DATE_LT_TIMESTAMP 2338
+#define F_DATE_LE_TIMESTAMP 2339
+#define F_DATE_EQ_TIMESTAMP 2340
+#define F_DATE_GT_TIMESTAMP 2341
+#define F_DATE_GE_TIMESTAMP 2342
+#define F_DATE_NE_TIMESTAMP 2343
+#define F_DATE_CMP_TIMESTAMP 2344
+#define F_DATE_LT_TIMESTAMPTZ 2351
+#define F_DATE_LE_TIMESTAMPTZ 2352
+#define F_DATE_EQ_TIMESTAMPTZ 2353
+#define F_DATE_GT_TIMESTAMPTZ 2354
+#define F_DATE_GE_TIMESTAMPTZ 2355
+#define F_DATE_NE_TIMESTAMPTZ 2356
+#define F_DATE_CMP_TIMESTAMPTZ 2357
+#define F_TIMESTAMP_LT_DATE 2364
+#define F_TIMESTAMP_LE_DATE 2365
+#define F_TIMESTAMP_EQ_DATE 2366
+#define F_TIMESTAMP_GT_DATE 2367
+#define F_TIMESTAMP_GE_DATE 2368
+#define F_TIMESTAMP_NE_DATE 2369
+#define F_TIMESTAMP_CMP_DATE 2370
+#define F_TIMESTAMPTZ_LT_DATE 2377
+#define F_TIMESTAMPTZ_LE_DATE 2378
+#define F_TIMESTAMPTZ_EQ_DATE 2379
+#define F_TIMESTAMPTZ_GT_DATE 2380
+#define F_TIMESTAMPTZ_GE_DATE 2381
+#define F_TIMESTAMPTZ_NE_DATE 2382
+#define F_TIMESTAMPTZ_CMP_DATE 2383
+#define F_HAS_TABLESPACE_PRIVILEGE_NAME_NAME 2390
+#define F_HAS_TABLESPACE_PRIVILEGE_NAME_ID 2391
+#define F_HAS_TABLESPACE_PRIVILEGE_ID_NAME 2392
+#define F_HAS_TABLESPACE_PRIVILEGE_ID_ID 2393
+#define F_HAS_TABLESPACE_PRIVILEGE_NAME 2394
+#define F_HAS_TABLESPACE_PRIVILEGE_ID 2395
+#define F_SHELL_IN 2398
+#define F_SHELL_OUT 2399
+#define F_ARRAY_RECV 2400
+#define F_ARRAY_SEND 2401
+#define F_RECORD_RECV 2402
+#define F_RECORD_SEND 2403
+#define F_INT2RECV 2404
+#define F_INT2SEND 2405
+#define F_INT4RECV 2406
+#define F_INT4SEND 2407
+#define F_INT8RECV 2408
+#define F_INT8SEND 2409
+#define F_INT2VECTORRECV 2410
+#define F_INT2VECTORSEND 2411
+#define F_BYTEARECV 2412
+#define F_BYTEASEND 2413
+#define F_TEXTRECV 2414
+#define F_TEXTSEND 2415
+#define F_UNKNOWNRECV 2416
+#define F_UNKNOWNSEND 2417
+#define F_OIDRECV 2418
+#define F_OIDSEND 2419
+#define F_OIDVECTORRECV 2420
+#define F_OIDVECTORSEND 2421
+#define F_NAMERECV 2422
+#define F_NAMESEND 2423
+#define F_FLOAT4RECV 2424
+#define F_FLOAT4SEND 2425
+#define F_FLOAT8RECV 2426
+#define F_FLOAT8SEND 2427
+#define F_POINT_RECV 2428
+#define F_POINT_SEND 2429
+#define F_BPCHARRECV 2430
+#define F_BPCHARSEND 2431
+#define F_VARCHARRECV 2432
+#define F_VARCHARSEND 2433
+#define F_CHARRECV 2434
+#define F_CHARSEND 2435
+#define F_BOOLRECV 2436
+#define F_BOOLSEND 2437
+#define F_TIDRECV 2438
+#define F_TIDSEND 2439
+#define F_XIDRECV 2440
+#define F_XIDSEND 2441
+#define F_CIDRECV 2442
+#define F_CIDSEND 2443
+#define F_REGPROCRECV 2444
+#define F_REGPROCSEND 2445
+#define F_REGPROCEDURERECV 2446
+#define F_REGPROCEDURESEND 2447
+#define F_REGOPERRECV 2448
+#define F_REGOPERSEND 2449
+#define F_REGOPERATORRECV 2450
+#define F_REGOPERATORSEND 2451
+#define F_REGCLASSRECV 2452
+#define F_REGCLASSSEND 2453
+#define F_REGTYPERECV 2454
+#define F_REGTYPESEND 2455
+#define F_BIT_RECV 2456
+#define F_BIT_SEND 2457
+#define F_VARBIT_RECV 2458
+#define F_VARBIT_SEND 2459
+#define F_NUMERIC_RECV 2460
+#define F_NUMERIC_SEND 2461
+#define F_ABSTIMERECV 2462
+#define F_ABSTIMESEND 2463
+#define F_RELTIMERECV 2464
+#define F_RELTIMESEND 2465
+#define F_TINTERVALRECV 2466
+#define F_TINTERVALSEND 2467
+#define F_DATE_RECV 2468
+#define F_DATE_SEND 2469
+#define F_TIME_RECV 2470
+#define F_TIME_SEND 2471
+#define F_TIMETZ_RECV 2472
+#define F_TIMETZ_SEND 2473
+#define F_TIMESTAMP_RECV 2474
+#define F_TIMESTAMP_SEND 2475
+#define F_TIMESTAMPTZ_RECV 2476
+#define F_TIMESTAMPTZ_SEND 2477
+#define F_INTERVAL_RECV 2478
+#define F_INTERVAL_SEND 2479
+#define F_LSEG_RECV 2480
+#define F_LSEG_SEND 2481
+#define F_PATH_RECV 2482
+#define F_PATH_SEND 2483
+#define F_BOX_RECV 2484
+#define F_BOX_SEND 2485
+#define F_POLY_RECV 2486
+#define F_POLY_SEND 2487
+#define F_LINE_RECV 2488
+#define F_LINE_SEND 2489
+#define F_CIRCLE_RECV 2490
+#define F_CIRCLE_SEND 2491
+#define F_CASH_RECV 2492
+#define F_CASH_SEND 2493
+#define F_MACADDR_RECV 2494
+#define F_MACADDR_SEND 2495
+#define F_INET_RECV 2496
+#define F_INET_SEND 2497
+#define F_CIDR_RECV 2498
+#define F_CIDR_SEND 2499
+#define F_CSTRING_RECV 2500
+#define F_CSTRING_SEND 2501
+#define F_ANYARRAY_RECV 2502
+#define F_ANYARRAY_SEND 2503
+#define F_PG_GET_RULEDEF_EXT 2504
+#define F_PG_GET_VIEWDEF_NAME_EXT 2505
+#define F_PG_GET_VIEWDEF_EXT 2506
+#define F_PG_GET_INDEXDEF_EXT 2507
+#define F_PG_GET_CONSTRAINTDEF_EXT 2508
+#define F_PG_GET_EXPR_EXT 2509
+#define F_PG_PREPARED_STATEMENT 2510
+#define F_PG_CURSOR 2511
+#define F_FLOAT8_VAR_POP 2512
+#define F_FLOAT8_STDDEV_POP 2513
+#define F_NUMERIC_VAR_POP 2514
+#define F_BOOLAND_STATEFUNC 2515
+#define F_BOOLOR_STATEFUNC 2516
+#define F_TIMESTAMP_LT_TIMESTAMPTZ 2520
+#define F_TIMESTAMP_LE_TIMESTAMPTZ 2521
+#define F_TIMESTAMP_EQ_TIMESTAMPTZ 2522
+#define F_TIMESTAMP_GT_TIMESTAMPTZ 2523
+#define F_TIMESTAMP_GE_TIMESTAMPTZ 2524
+#define F_TIMESTAMP_NE_TIMESTAMPTZ 2525
+#define F_TIMESTAMP_CMP_TIMESTAMPTZ 2526
+#define F_TIMESTAMPTZ_LT_TIMESTAMP 2527
+#define F_TIMESTAMPTZ_LE_TIMESTAMP 2528
+#define F_TIMESTAMPTZ_EQ_TIMESTAMP 2529
+#define F_TIMESTAMPTZ_GT_TIMESTAMP 2530
+#define F_TIMESTAMPTZ_GE_TIMESTAMP 2531
+#define F_TIMESTAMPTZ_NE_TIMESTAMP 2532
+#define F_TIMESTAMPTZ_CMP_TIMESTAMP 2533
+#define F_PG_TABLESPACE_DATABASES 2556
+#define F_INT4_BOOL 2557
+#define F_BOOL_INT4 2558
+#define F_LASTVAL 2559
+#define F_PG_POSTMASTER_START_TIME 2560
+#define F_GISTVACUUMCLEANUP 2561
+#define F_BOX_BELOW 2562
+#define F_BOX_OVERBELOW 2563
+#define F_BOX_OVERABOVE 2564
+#define F_BOX_ABOVE 2565
+#define F_POLY_BELOW 2566
+#define F_POLY_OVERBELOW 2567
+#define F_POLY_OVERABOVE 2568
+#define F_POLY_ABOVE 2569
+#define F_GIST_BOX_CONSISTENT 2578
+#define F_GIST_BOX_COMPRESS 2579
+#define F_GIST_BOX_DECOMPRESS 2580
+#define F_GIST_BOX_PENALTY 2581
+#define F_GIST_BOX_PICKSPLIT 2582
+#define F_GIST_BOX_UNION 2583
+#define F_GIST_BOX_SAME 2584
+#define F_GIST_POLY_CONSISTENT 2585
+#define F_GIST_POLY_COMPRESS 2586
+#define F_CIRCLE_OVERBELOW 2587
+#define F_CIRCLE_OVERABOVE 2588
+#define F_GIST_CIRCLE_CONSISTENT 2591
+#define F_GIST_CIRCLE_COMPRESS 2592
+#define F_NUMERIC_STDDEV_POP 2596
+#define F_DOMAIN_IN 2597
+#define F_DOMAIN_RECV 2598
+#define F_PG_TIMEZONE_ABBREVS 2599
+#define F_PG_RELOAD_CONF 2621
+#define F_PG_ROTATE_LOGFILE 2622
+#define F_PG_STAT_FILE 2623
+#define F_PG_READ_FILE 2624
+#define F_PG_LS_DIR 2625
+#define F_PG_SLEEP 2626
+#define F_INETNOT 2627
+#define F_INETAND 2628
+#define F_INETOR 2629
+#define F_INETPL 2630
+#define F_INETMI_INT8 2632
+#define F_INETMI 2633
+#define F_STATEMENT_TIMESTAMP 2648
+#define F_CLOCK_TIMESTAMP 2649
+#define F_GIN_CMP_PREFIX 2700
+#define F_PG_HAS_ROLE_NAME_NAME 2705
+#define F_PG_HAS_ROLE_NAME_ID 2706
+#define F_PG_HAS_ROLE_ID_NAME 2707
+#define F_PG_HAS_ROLE_ID_ID 2708
+#define F_PG_HAS_ROLE_NAME 2709
+#define F_PG_HAS_ROLE_ID 2710
+#define F_INTERVAL_JUSTIFY_INTERVAL 2711
+#define F_GINGETBITMAP 2731
+#define F_GININSERT 2732
+#define F_GINBEGINSCAN 2733
+#define F_GINRESCAN 2734
+#define F_GINENDSCAN 2735
+#define F_GINMARKPOS 2736
+#define F_GINRESTRPOS 2737
+#define F_GINBUILD 2738
+#define F_GINBULKDELETE 2739
+#define F_GINVACUUMCLEANUP 2740
+#define F_GINCOSTESTIMATE 2741
+#define F_GINARRAYEXTRACT 2743
+#define F_GINARRAYCONSISTENT 2744
+#define F_INT8_AVG_ACCUM 2746
+#define F_ARRAYOVERLAP 2747
+#define F_ARRAYCONTAINS 2748
+#define F_ARRAYCONTAINED 2749
+#define F_PG_STAT_GET_DB_TUPLES_RETURNED 2758
+#define F_PG_STAT_GET_DB_TUPLES_FETCHED 2759
+#define F_PG_STAT_GET_DB_TUPLES_INSERTED 2760
+#define F_PG_STAT_GET_DB_TUPLES_UPDATED 2761
+#define F_PG_STAT_GET_DB_TUPLES_DELETED 2762
+#define F_REGEXP_MATCHES_NO_FLAGS 2763
+#define F_REGEXP_MATCHES 2764
+#define F_REGEXP_SPLIT_TO_TABLE_NO_FLAGS 2765
+#define F_REGEXP_SPLIT_TO_TABLE 2766
+#define F_REGEXP_SPLIT_TO_ARRAY_NO_FLAGS 2767
+#define F_REGEXP_SPLIT_TO_ARRAY 2768
+#define F_PG_STAT_GET_BGWRITER_TIMED_CHECKPOINTS 2769
+#define F_PG_STAT_GET_BGWRITER_REQUESTED_CHECKPOINTS 2770
+#define F_PG_STAT_GET_BGWRITER_BUF_WRITTEN_CHECKPOINTS 2771
+#define F_PG_STAT_GET_BGWRITER_BUF_WRITTEN_CLEAN 2772
+#define F_PG_STAT_GET_BGWRITER_MAXWRITTEN_CLEAN 2773
+#define F_GINQUERYARRAYEXTRACT 2774
+#define F_PG_STAT_GET_BUF_WRITTEN_BACKEND 2775
+#define F_ANYNONARRAY_IN 2777
+#define F_ANYNONARRAY_OUT 2778
+#define F_PG_STAT_GET_LAST_VACUUM_TIME 2781
+#define F_PG_STAT_GET_LAST_AUTOVACUUM_TIME 2782
+#define F_PG_STAT_GET_LAST_ANALYZE_TIME 2783
+#define F_PG_STAT_GET_LAST_AUTOANALYZE_TIME 2784
+#define F_BTOPTIONS 2785
+#define F_HASHOPTIONS 2786
+#define F_GISTOPTIONS 2787
+#define F_GINOPTIONS 2788
+#define F_TIDGT 2790
+#define F_TIDLT 2791
+#define F_TIDGE 2792
+#define F_TIDLE 2793
+#define F_BTTIDCMP 2794
+#define F_TIDLARGER 2795
+#define F_TIDSMALLER 2796
+#define F_INT8INC_ANY 2804
+#define F_INT8INC_FLOAT8_FLOAT8 2805
+#define F_FLOAT8_REGR_ACCUM 2806
+#define F_FLOAT8_REGR_SXX 2807
+#define F_FLOAT8_REGR_SYY 2808
+#define F_FLOAT8_REGR_SXY 2809
+#define F_FLOAT8_REGR_AVGX 2810
+#define F_FLOAT8_REGR_AVGY 2811
+#define F_FLOAT8_REGR_R2 2812
+#define F_FLOAT8_REGR_SLOPE 2813
+#define F_FLOAT8_REGR_INTERCEPT 2814
+#define F_FLOAT8_COVAR_POP 2815
+#define F_FLOAT8_COVAR_SAMP 2816
+#define F_FLOAT8_CORR 2817
+#define F_PG_SWITCH_XLOG 2848
+#define F_PG_CURRENT_XLOG_LOCATION 2849
+#define F_PG_XLOGFILE_NAME_OFFSET 2850
+#define F_PG_XLOGFILE_NAME 2851
+#define F_PG_CURRENT_XLOG_INSERT_LOCATION 2852
+#define F_PG_STAT_GET_BACKEND_WAITING 2853
+#define F_PG_MY_TEMP_SCHEMA 2854
+#define F_PG_IS_OTHER_TEMP_SCHEMA 2855
+#define F_PG_TIMEZONE_NAMES 2856
+#define F_PG_STAT_GET_BACKEND_XACT_START 2857
+#define F_NUMERIC_AVG_ACCUM 2858
+#define F_PG_STAT_GET_BUF_ALLOC 2859
+#define F_PG_STAT_GET_LIVE_TUPLES 2878
+#define F_PG_STAT_GET_DEAD_TUPLES 2879
+#define F_PG_ADVISORY_LOCK_INT8 2880
+#define F_PG_ADVISORY_LOCK_SHARED_INT8 2881
+#define F_PG_TRY_ADVISORY_LOCK_INT8 2882
+#define F_PG_TRY_ADVISORY_LOCK_SHARED_INT8 2883
+#define F_PG_ADVISORY_UNLOCK_INT8 2884
+#define F_PG_ADVISORY_UNLOCK_SHARED_INT8 2885
+#define F_PG_ADVISORY_LOCK_INT4 2886
+#define F_PG_ADVISORY_LOCK_SHARED_INT4 2887
+#define F_PG_TRY_ADVISORY_LOCK_INT4 2888
+#define F_PG_TRY_ADVISORY_LOCK_SHARED_INT4 2889
+#define F_PG_ADVISORY_UNLOCK_INT4 2890
+#define F_PG_ADVISORY_UNLOCK_SHARED_INT4 2891
+#define F_PG_ADVISORY_UNLOCK_ALL 2892
+#define F_XML_IN 2893
+#define F_XML_OUT 2894
+#define F_XMLCOMMENT 2895
+#define F_TEXTTOXML 2896
+#define F_XMLVALIDATE 2897
+#define F_XML_RECV 2898
+#define F_XML_SEND 2899
+#define F_XMLCONCAT2 2900
+#define F_VARBITTYPMODIN 2902
+#define F_INTERVALTYPMODIN 2903
+#define F_INTERVALTYPMODOUT 2904
+#define F_TIMESTAMPTYPMODIN 2905
+#define F_TIMESTAMPTYPMODOUT 2906
+#define F_TIMESTAMPTZTYPMODIN 2907
+#define F_TIMESTAMPTZTYPMODOUT 2908
+#define F_TIMETYPMODIN 2909
+#define F_TIMETYPMODOUT 2910
+#define F_TIMETZTYPMODIN 2911
+#define F_TIMETZTYPMODOUT 2912
+#define F_BPCHARTYPMODIN 2913
+#define F_BPCHARTYPMODOUT 2914
+#define F_VARCHARTYPMODIN 2915
+#define F_VARCHARTYPMODOUT 2916
+#define F_NUMERICTYPMODIN 2917
+#define F_NUMERICTYPMODOUT 2918
+#define F_BITTYPMODIN 2919
+#define F_BITTYPMODOUT 2920
+#define F_VARBITTYPMODOUT 2921
+#define F_XMLTOTEXT 2922
+#define F_TABLE_TO_XML 2923
+#define F_QUERY_TO_XML 2924
+#define F_CURSOR_TO_XML 2925
+#define F_TABLE_TO_XMLSCHEMA 2926
+#define F_QUERY_TO_XMLSCHEMA 2927
+#define F_CURSOR_TO_XMLSCHEMA 2928
+#define F_TABLE_TO_XML_AND_XMLSCHEMA 2929
+#define F_QUERY_TO_XML_AND_XMLSCHEMA 2930
+#define F_XPATH 2931
+#define F_SCHEMA_TO_XML 2933
+#define F_SCHEMA_TO_XMLSCHEMA 2934
+#define F_SCHEMA_TO_XML_AND_XMLSCHEMA 2935
+#define F_DATABASE_TO_XML 2936
+#define F_DATABASE_TO_XMLSCHEMA 2937
+#define F_DATABASE_TO_XML_AND_XMLSCHEMA 2938
+#define F_TXID_SNAPSHOT_IN 2939
+#define F_TXID_SNAPSHOT_OUT 2940
+#define F_TXID_SNAPSHOT_RECV 2941
+#define F_TXID_SNAPSHOT_SEND 2942
+#define F_TXID_CURRENT 2943
+#define F_TXID_CURRENT_SNAPSHOT 2944
+#define F_TXID_SNAPSHOT_XMIN 2945
+#define F_TXID_SNAPSHOT_XMAX 2946
+#define F_TXID_SNAPSHOT_XIP 2947
+#define F_TXID_VISIBLE_IN_SNAPSHOT 2948
+#define F_UUID_IN 2952
+#define F_UUID_OUT 2953
+#define F_UUID_LT 2954
+#define F_UUID_LE 2955
+#define F_UUID_EQ 2956
+#define F_UUID_GE 2957
+#define F_UUID_GT 2958
+#define F_UUID_NE 2959
+#define F_UUID_CMP 2960
+#define F_UUID_RECV 2961
+#define F_UUID_SEND 2962
+#define F_UUID_HASH 2963
+#define F_BOOLTEXT 2971
+#define F_PG_STAT_GET_FUNCTION_CALLS 2978
+#define F_PG_STAT_GET_FUNCTION_TIME 2979
+#define F_PG_STAT_GET_FUNCTION_SELF_TIME 2980
+#define F_RECORD_EQ 2981
+#define F_RECORD_NE 2982
+#define F_RECORD_LT 2983
+#define F_RECORD_GT 2984
+#define F_RECORD_LE 2985
+#define F_RECORD_GE 2986
+#define F_BTRECORDCMP 2987
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_NAME_NAME 3000
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_NAME_ID 3001
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_ID_NAME 3002
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_ID_ID 3003
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_NAME 3004
+#define F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_ID 3005
+#define F_HAS_SERVER_PRIVILEGE_NAME_NAME 3006
+#define F_HAS_SERVER_PRIVILEGE_NAME_ID 3007
+#define F_HAS_SERVER_PRIVILEGE_ID_NAME 3008
+#define F_HAS_SERVER_PRIVILEGE_ID_ID 3009
+#define F_HAS_SERVER_PRIVILEGE_NAME 3010
+#define F_HAS_SERVER_PRIVILEGE_ID 3011
+#define F_HAS_COLUMN_PRIVILEGE_NAME_NAME_NAME 3012
+#define F_HAS_COLUMN_PRIVILEGE_NAME_NAME_ATTNUM 3013
+#define F_HAS_COLUMN_PRIVILEGE_NAME_ID_NAME 3014
+#define F_HAS_COLUMN_PRIVILEGE_NAME_ID_ATTNUM 3015
+#define F_HAS_COLUMN_PRIVILEGE_ID_NAME_NAME 3016
+#define F_HAS_COLUMN_PRIVILEGE_ID_NAME_ATTNUM 3017
+#define F_HAS_COLUMN_PRIVILEGE_ID_ID_NAME 3018
+#define F_HAS_COLUMN_PRIVILEGE_ID_ID_ATTNUM 3019
+#define F_HAS_COLUMN_PRIVILEGE_NAME_NAME 3020
+#define F_HAS_COLUMN_PRIVILEGE_NAME_ATTNUM 3021
+#define F_HAS_COLUMN_PRIVILEGE_ID_NAME 3022
+#define F_HAS_COLUMN_PRIVILEGE_ID_ATTNUM 3023
+#define F_HAS_ANY_COLUMN_PRIVILEGE_NAME_NAME 3024
+#define F_HAS_ANY_COLUMN_PRIVILEGE_NAME_ID 3025
+#define F_HAS_ANY_COLUMN_PRIVILEGE_ID_NAME 3026
+#define F_HAS_ANY_COLUMN_PRIVILEGE_ID_ID 3027
+#define F_HAS_ANY_COLUMN_PRIVILEGE_NAME 3028
+#define F_HAS_ANY_COLUMN_PRIVILEGE_ID 3029
+#define F_WINDOW_ROW_NUMBER 3100
+#define F_WINDOW_RANK 3101
+#define F_WINDOW_DENSE_RANK 3102
+#define F_WINDOW_PERCENT_RANK 3103
+#define F_WINDOW_CUME_DIST 3104
+#define F_WINDOW_NTILE 3105
+#define F_WINDOW_LAG 3106
+#define F_WINDOW_LAG_WITH_OFFSET 3107
+#define F_WINDOW_LAG_WITH_OFFSET_AND_DEFAULT 3108
+#define F_WINDOW_LEAD 3109
+#define F_WINDOW_LEAD_WITH_OFFSET 3110
+#define F_WINDOW_LEAD_WITH_OFFSET_AND_DEFAULT 3111
+#define F_WINDOW_FIRST_VALUE 3112
+#define F_WINDOW_LAST_VALUE 3113
+#define F_WINDOW_NTH_VALUE 3114
+#define F_ANYENUM_IN 3504
+#define F_ANYENUM_OUT 3505
+#define F_ENUM_IN 3506
+#define F_ENUM_OUT 3507
+#define F_ENUM_EQ 3508
+#define F_ENUM_NE 3509
+#define F_ENUM_LT 3510
+#define F_ENUM_GT 3511
+#define F_ENUM_LE 3512
+#define F_ENUM_GE 3513
+#define F_ENUM_CMP 3514
+#define F_HASHENUM 3515
+#define F_ENUM_SMALLER 3524
+#define F_ENUM_LARGER 3525
+#define F_ENUM_FIRST 3528
+#define F_ENUM_LAST 3529
+#define F_ENUM_RANGE_BOUNDS 3530
+#define F_ENUM_RANGE_ALL 3531
+#define F_ENUM_RECV 3532
+#define F_ENUM_SEND 3533
+#define F_TSVECTORIN 3610
+#define F_TSVECTOROUT 3611
+#define F_TSQUERYIN 3612
+#define F_TSQUERYOUT 3613
+#define F_TSVECTOR_LT 3616
+#define F_TSVECTOR_LE 3617
+#define F_TSVECTOR_EQ 3618
+#define F_TSVECTOR_NE 3619
+#define F_TSVECTOR_GE 3620
+#define F_TSVECTOR_GT 3621
+#define F_TSVECTOR_CMP 3622
+#define F_TSVECTOR_STRIP 3623
+#define F_TSVECTOR_SETWEIGHT 3624
+#define F_TSVECTOR_CONCAT 3625
+#define F_TS_MATCH_VQ 3634
+#define F_TS_MATCH_QV 3635
+#define F_TSVECTORSEND 3638
+#define F_TSVECTORRECV 3639
+#define F_TSQUERYSEND 3640
+#define F_TSQUERYRECV 3641
+#define F_GTSVECTORIN 3646
+#define F_GTSVECTOROUT 3647
+#define F_GTSVECTOR_COMPRESS 3648
+#define F_GTSVECTOR_DECOMPRESS 3649
+#define F_GTSVECTOR_PICKSPLIT 3650
+#define F_GTSVECTOR_UNION 3651
+#define F_GTSVECTOR_SAME 3652
+#define F_GTSVECTOR_PENALTY 3653
+#define F_GTSVECTOR_CONSISTENT 3654
+#define F_GIN_EXTRACT_TSVECTOR 3656
+#define F_GIN_EXTRACT_TSQUERY 3657
+#define F_GIN_TSQUERY_CONSISTENT 3658
+#define F_TSQUERY_LT 3662
+#define F_TSQUERY_LE 3663
+#define F_TSQUERY_EQ 3664
+#define F_TSQUERY_NE 3665
+#define F_TSQUERY_GE 3666
+#define F_TSQUERY_GT 3667
+#define F_TSQUERY_CMP 3668
+#define F_TSQUERY_AND 3669
+#define F_TSQUERY_OR 3670
+#define F_TSQUERY_NOT 3671
+#define F_TSQUERY_NUMNODE 3672
+#define F_TSQUERYTREE 3673
+#define F_TSQUERY_REWRITE 3684
+#define F_TSQUERY_REWRITE_QUERY 3685
+#define F_TSMATCHSEL 3686
+#define F_TSMATCHJOINSEL 3687
+#define F_TS_TYPANALYZE 3688
+#define F_TS_STAT1 3689
+#define F_TS_STAT2 3690
+#define F_TSQ_MCONTAINS 3691
+#define F_TSQ_MCONTAINED 3692
+#define F_GTSQUERY_COMPRESS 3695
+#define F_GTSQUERY_DECOMPRESS 3696
+#define F_GTSQUERY_PICKSPLIT 3697
+#define F_GTSQUERY_UNION 3698
+#define F_GTSQUERY_SAME 3699
+#define F_GTSQUERY_PENALTY 3700
+#define F_GTSQUERY_CONSISTENT 3701
+#define F_TS_RANK_WTTF 3703
+#define F_TS_RANK_WTT 3704
+#define F_TS_RANK_TTF 3705
+#define F_TS_RANK_TT 3706
+#define F_TS_RANKCD_WTTF 3707
+#define F_TS_RANKCD_WTT 3708
+#define F_TS_RANKCD_TTF 3709
+#define F_TS_RANKCD_TT 3710
+#define F_TSVECTOR_LENGTH 3711
+#define F_TS_TOKEN_TYPE_BYID 3713
+#define F_TS_TOKEN_TYPE_BYNAME 3714
+#define F_TS_PARSE_BYID 3715
+#define F_TS_PARSE_BYNAME 3716
+#define F_PRSD_START 3717
+#define F_PRSD_NEXTTOKEN 3718
+#define F_PRSD_END 3719
+#define F_PRSD_HEADLINE 3720
+#define F_PRSD_LEXTYPE 3721
+#define F_TS_LEXIZE 3723
+#define F_GIN_CMP_TSLEXEME 3724
+#define F_DSIMPLE_INIT 3725
+#define F_DSIMPLE_LEXIZE 3726
+#define F_DSYNONYM_INIT 3728
+#define F_DSYNONYM_LEXIZE 3729
+#define F_DISPELL_INIT 3731
+#define F_DISPELL_LEXIZE 3732
+#define F_REGCONFIGIN 3736
+#define F_REGCONFIGOUT 3737
+#define F_REGCONFIGRECV 3738
+#define F_REGCONFIGSEND 3739
+#define F_THESAURUS_INIT 3740
+#define F_THESAURUS_LEXIZE 3741
+#define F_TS_HEADLINE_BYID_OPT 3743
+#define F_TS_HEADLINE_BYID 3744
+#define F_TO_TSVECTOR_BYID 3745
+#define F_TO_TSQUERY_BYID 3746
+#define F_PLAINTO_TSQUERY_BYID 3747
+#define F_TO_TSVECTOR 3749
+#define F_TO_TSQUERY 3750
+#define F_PLAINTO_TSQUERY 3751
+#define F_TSVECTOR_UPDATE_TRIGGER_BYID 3752
+#define F_TSVECTOR_UPDATE_TRIGGER_BYCOLUMN 3753
+#define F_TS_HEADLINE_OPT 3754
+#define F_TS_HEADLINE 3755
+#define F_PG_TS_PARSER_IS_VISIBLE 3756
+#define F_PG_TS_DICT_IS_VISIBLE 3757
+#define F_PG_TS_CONFIG_IS_VISIBLE 3758
+#define F_GET_CURRENT_TS_CONFIG 3759
+#define F_TS_MATCH_TT 3760
+#define F_TS_MATCH_TQ 3761
+#define F_PG_TS_TEMPLATE_IS_VISIBLE 3768
+#define F_REGDICTIONARYIN 3771
+#define F_REGDICTIONARYOUT 3772
+#define F_REGDICTIONARYRECV 3773
+#define F_REGDICTIONARYSEND 3774
+
+#endif /* FMGROIDS_H */
diff --git a/src/backend/utils/fmgrtab.c b/src/backend/utils/fmgrtab.c
new file mode 100644
index 0000000..1606b49
--- /dev/null
+++ b/src/backend/utils/fmgrtab.c
@@ -0,0 +1,3944 @@
+/*-------------------------------------------------------------------------
+ *
+ * fmgrtab.c
+ *    The function manager's table of internal functions.
+ *
+ * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * NOTES
+ *
+ *	******************************
+ *	*** DO NOT EDIT THIS FILE! ***
+ *	******************************
+ *
+ *	It has been GENERATED by Gen_fmgrtab.sh
+ *	from ../../../src/include/catalog/pg_proc.h
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+
+#include "utils/fmgrtab.h"
+
+extern Datum byteaout (PG_FUNCTION_ARGS);
+extern Datum charout (PG_FUNCTION_ARGS);
+extern Datum namein (PG_FUNCTION_ARGS);
+extern Datum nameout (PG_FUNCTION_ARGS);
+extern Datum int2in (PG_FUNCTION_ARGS);
+extern Datum int2out (PG_FUNCTION_ARGS);
+extern Datum int2vectorin (PG_FUNCTION_ARGS);
+extern Datum int2vectorout (PG_FUNCTION_ARGS);
+extern Datum int4in (PG_FUNCTION_ARGS);
+extern Datum int4out (PG_FUNCTION_ARGS);
+extern Datum regprocin (PG_FUNCTION_ARGS);
+extern Datum regprocout (PG_FUNCTION_ARGS);
+extern Datum textin (PG_FUNCTION_ARGS);
+extern Datum textout (PG_FUNCTION_ARGS);
+extern Datum tidin (PG_FUNCTION_ARGS);
+extern Datum tidout (PG_FUNCTION_ARGS);
+extern Datum xidin (PG_FUNCTION_ARGS);
+extern Datum xidout (PG_FUNCTION_ARGS);
+extern Datum cidin (PG_FUNCTION_ARGS);
+extern Datum cidout (PG_FUNCTION_ARGS);
+extern Datum oidvectorin (PG_FUNCTION_ARGS);
+extern Datum oidvectorout (PG_FUNCTION_ARGS);
+extern Datum boollt (PG_FUNCTION_ARGS);
+extern Datum boolgt (PG_FUNCTION_ARGS);
+extern Datum booleq (PG_FUNCTION_ARGS);
+extern Datum chareq (PG_FUNCTION_ARGS);
+extern Datum nameeq (PG_FUNCTION_ARGS);
+extern Datum int2eq (PG_FUNCTION_ARGS);
+extern Datum int2lt (PG_FUNCTION_ARGS);
+extern Datum int4eq (PG_FUNCTION_ARGS);
+extern Datum int4lt (PG_FUNCTION_ARGS);
+extern Datum texteq (PG_FUNCTION_ARGS);
+extern Datum xideq (PG_FUNCTION_ARGS);
+extern Datum cideq (PG_FUNCTION_ARGS);
+extern Datum charne (PG_FUNCTION_ARGS);
+extern Datum charle (PG_FUNCTION_ARGS);
+extern Datum chargt (PG_FUNCTION_ARGS);
+extern Datum charge (PG_FUNCTION_ARGS);
+extern Datum chartoi4 (PG_FUNCTION_ARGS);
+extern Datum i4tochar (PG_FUNCTION_ARGS);
+extern Datum nameregexeq (PG_FUNCTION_ARGS);
+extern Datum boolne (PG_FUNCTION_ARGS);
+extern Datum pgsql_version (PG_FUNCTION_ARGS);
+extern Datum eqsel (PG_FUNCTION_ARGS);
+extern Datum neqsel (PG_FUNCTION_ARGS);
+extern Datum scalarltsel (PG_FUNCTION_ARGS);
+extern Datum scalargtsel (PG_FUNCTION_ARGS);
+extern Datum eqjoinsel (PG_FUNCTION_ARGS);
+extern Datum neqjoinsel (PG_FUNCTION_ARGS);
+extern Datum scalarltjoinsel (PG_FUNCTION_ARGS);
+extern Datum scalargtjoinsel (PG_FUNCTION_ARGS);
+extern Datum unknownin (PG_FUNCTION_ARGS);
+extern Datum unknownout (PG_FUNCTION_ARGS);
+extern Datum numeric_fac (PG_FUNCTION_ARGS);
+extern Datum box_above_eq (PG_FUNCTION_ARGS);
+extern Datum box_below_eq (PG_FUNCTION_ARGS);
+extern Datum point_in (PG_FUNCTION_ARGS);
+extern Datum point_out (PG_FUNCTION_ARGS);
+extern Datum lseg_in (PG_FUNCTION_ARGS);
+extern Datum lseg_out (PG_FUNCTION_ARGS);
+extern Datum path_in (PG_FUNCTION_ARGS);
+extern Datum path_out (PG_FUNCTION_ARGS);
+extern Datum box_in (PG_FUNCTION_ARGS);
+extern Datum box_out (PG_FUNCTION_ARGS);
+extern Datum box_overlap (PG_FUNCTION_ARGS);
+extern Datum box_ge (PG_FUNCTION_ARGS);
+extern Datum box_gt (PG_FUNCTION_ARGS);
+extern Datum box_eq (PG_FUNCTION_ARGS);
+extern Datum box_lt (PG_FUNCTION_ARGS);
+extern Datum box_le (PG_FUNCTION_ARGS);
+extern Datum point_above (PG_FUNCTION_ARGS);
+extern Datum point_left (PG_FUNCTION_ARGS);
+extern Datum point_right (PG_FUNCTION_ARGS);
+extern Datum point_below (PG_FUNCTION_ARGS);
+extern Datum point_eq (PG_FUNCTION_ARGS);
+extern Datum on_pb (PG_FUNCTION_ARGS);
+extern Datum on_ppath (PG_FUNCTION_ARGS);
+extern Datum box_center (PG_FUNCTION_ARGS);
+extern Datum areasel (PG_FUNCTION_ARGS);
+extern Datum areajoinsel (PG_FUNCTION_ARGS);
+extern Datum int4mul (PG_FUNCTION_ARGS);
+extern Datum int4ne (PG_FUNCTION_ARGS);
+extern Datum int2ne (PG_FUNCTION_ARGS);
+extern Datum int2gt (PG_FUNCTION_ARGS);
+extern Datum int4gt (PG_FUNCTION_ARGS);
+extern Datum int2le (PG_FUNCTION_ARGS);
+extern Datum int4le (PG_FUNCTION_ARGS);
+extern Datum int4ge (PG_FUNCTION_ARGS);
+extern Datum int2ge (PG_FUNCTION_ARGS);
+extern Datum int2mul (PG_FUNCTION_ARGS);
+extern Datum int2div (PG_FUNCTION_ARGS);
+extern Datum int4div (PG_FUNCTION_ARGS);
+extern Datum int2mod (PG_FUNCTION_ARGS);
+extern Datum int4mod (PG_FUNCTION_ARGS);
+extern Datum textne (PG_FUNCTION_ARGS);
+extern Datum int24eq (PG_FUNCTION_ARGS);
+extern Datum int42eq (PG_FUNCTION_ARGS);
+extern Datum int24lt (PG_FUNCTION_ARGS);
+extern Datum int42lt (PG_FUNCTION_ARGS);
+extern Datum int24gt (PG_FUNCTION_ARGS);
+extern Datum int42gt (PG_FUNCTION_ARGS);
+extern Datum int24ne (PG_FUNCTION_ARGS);
+extern Datum int42ne (PG_FUNCTION_ARGS);
+extern Datum int24le (PG_FUNCTION_ARGS);
+extern Datum int42le (PG_FUNCTION_ARGS);
+extern Datum int24ge (PG_FUNCTION_ARGS);
+extern Datum int42ge (PG_FUNCTION_ARGS);
+extern Datum int24mul (PG_FUNCTION_ARGS);
+extern Datum int42mul (PG_FUNCTION_ARGS);
+extern Datum int24div (PG_FUNCTION_ARGS);
+extern Datum int42div (PG_FUNCTION_ARGS);
+extern Datum int2pl (PG_FUNCTION_ARGS);
+extern Datum int4pl (PG_FUNCTION_ARGS);
+extern Datum int24pl (PG_FUNCTION_ARGS);
+extern Datum int42pl (PG_FUNCTION_ARGS);
+extern Datum int2mi (PG_FUNCTION_ARGS);
+extern Datum int4mi (PG_FUNCTION_ARGS);
+extern Datum int24mi (PG_FUNCTION_ARGS);
+extern Datum int42mi (PG_FUNCTION_ARGS);
+extern Datum oideq (PG_FUNCTION_ARGS);
+extern Datum oidne (PG_FUNCTION_ARGS);
+extern Datum box_same (PG_FUNCTION_ARGS);
+extern Datum box_contain (PG_FUNCTION_ARGS);
+extern Datum box_left (PG_FUNCTION_ARGS);
+extern Datum box_overleft (PG_FUNCTION_ARGS);
+extern Datum box_overright (PG_FUNCTION_ARGS);
+extern Datum box_right (PG_FUNCTION_ARGS);
+extern Datum box_contained (PG_FUNCTION_ARGS);
+extern Datum float4in (PG_FUNCTION_ARGS);
+extern Datum float4out (PG_FUNCTION_ARGS);
+extern Datum float4mul (PG_FUNCTION_ARGS);
+extern Datum float4div (PG_FUNCTION_ARGS);
+extern Datum float4pl (PG_FUNCTION_ARGS);
+extern Datum float4mi (PG_FUNCTION_ARGS);
+extern Datum float4um (PG_FUNCTION_ARGS);
+extern Datum float4abs (PG_FUNCTION_ARGS);
+extern Datum float4_accum (PG_FUNCTION_ARGS);
+extern Datum float4larger (PG_FUNCTION_ARGS);
+extern Datum float4smaller (PG_FUNCTION_ARGS);
+extern Datum int4um (PG_FUNCTION_ARGS);
+extern Datum int2um (PG_FUNCTION_ARGS);
+extern Datum float8in (PG_FUNCTION_ARGS);
+extern Datum float8out (PG_FUNCTION_ARGS);
+extern Datum float8mul (PG_FUNCTION_ARGS);
+extern Datum float8div (PG_FUNCTION_ARGS);
+extern Datum float8pl (PG_FUNCTION_ARGS);
+extern Datum float8mi (PG_FUNCTION_ARGS);
+extern Datum float8um (PG_FUNCTION_ARGS);
+extern Datum float8abs (PG_FUNCTION_ARGS);
+extern Datum float8_accum (PG_FUNCTION_ARGS);
+extern Datum float8larger (PG_FUNCTION_ARGS);
+extern Datum float8smaller (PG_FUNCTION_ARGS);
+extern Datum lseg_center (PG_FUNCTION_ARGS);
+extern Datum path_center (PG_FUNCTION_ARGS);
+extern Datum poly_center (PG_FUNCTION_ARGS);
+extern Datum dround (PG_FUNCTION_ARGS);
+extern Datum dtrunc (PG_FUNCTION_ARGS);
+extern Datum dsqrt (PG_FUNCTION_ARGS);
+extern Datum dcbrt (PG_FUNCTION_ARGS);
+extern Datum dpow (PG_FUNCTION_ARGS);
+extern Datum dexp (PG_FUNCTION_ARGS);
+extern Datum dlog1 (PG_FUNCTION_ARGS);
+extern Datum i2tod (PG_FUNCTION_ARGS);
+extern Datum i2tof (PG_FUNCTION_ARGS);
+extern Datum dtoi2 (PG_FUNCTION_ARGS);
+extern Datum ftoi2 (PG_FUNCTION_ARGS);
+extern Datum line_distance (PG_FUNCTION_ARGS);
+extern Datum abstimein (PG_FUNCTION_ARGS);
+extern Datum abstimeout (PG_FUNCTION_ARGS);
+extern Datum reltimein (PG_FUNCTION_ARGS);
+extern Datum reltimeout (PG_FUNCTION_ARGS);
+extern Datum timepl (PG_FUNCTION_ARGS);
+extern Datum timemi (PG_FUNCTION_ARGS);
+extern Datum tintervalin (PG_FUNCTION_ARGS);
+extern Datum tintervalout (PG_FUNCTION_ARGS);
+extern Datum intinterval (PG_FUNCTION_ARGS);
+extern Datum tintervalrel (PG_FUNCTION_ARGS);
+extern Datum timenow (PG_FUNCTION_ARGS);
+extern Datum abstimeeq (PG_FUNCTION_ARGS);
+extern Datum abstimene (PG_FUNCTION_ARGS);
+extern Datum abstimelt (PG_FUNCTION_ARGS);
+extern Datum abstimegt (PG_FUNCTION_ARGS);
+extern Datum abstimele (PG_FUNCTION_ARGS);
+extern Datum abstimege (PG_FUNCTION_ARGS);
+extern Datum reltimeeq (PG_FUNCTION_ARGS);
+extern Datum reltimene (PG_FUNCTION_ARGS);
+extern Datum reltimelt (PG_FUNCTION_ARGS);
+extern Datum reltimegt (PG_FUNCTION_ARGS);
+extern Datum reltimele (PG_FUNCTION_ARGS);
+extern Datum reltimege (PG_FUNCTION_ARGS);
+extern Datum tintervalsame (PG_FUNCTION_ARGS);
+extern Datum tintervalct (PG_FUNCTION_ARGS);
+extern Datum tintervalov (PG_FUNCTION_ARGS);
+extern Datum tintervalleneq (PG_FUNCTION_ARGS);
+extern Datum tintervallenne (PG_FUNCTION_ARGS);
+extern Datum tintervallenlt (PG_FUNCTION_ARGS);
+extern Datum tintervallengt (PG_FUNCTION_ARGS);
+extern Datum tintervallenle (PG_FUNCTION_ARGS);
+extern Datum tintervallenge (PG_FUNCTION_ARGS);
+extern Datum tintervalstart (PG_FUNCTION_ARGS);
+extern Datum tintervalend (PG_FUNCTION_ARGS);
+extern Datum timeofday (PG_FUNCTION_ARGS);
+extern Datum abstime_finite (PG_FUNCTION_ARGS);
+extern Datum inter_sl (PG_FUNCTION_ARGS);
+extern Datum inter_lb (PG_FUNCTION_ARGS);
+extern Datum float48mul (PG_FUNCTION_ARGS);
+extern Datum float48div (PG_FUNCTION_ARGS);
+extern Datum float48pl (PG_FUNCTION_ARGS);
+extern Datum float48mi (PG_FUNCTION_ARGS);
+extern Datum float84mul (PG_FUNCTION_ARGS);
+extern Datum float84div (PG_FUNCTION_ARGS);
+extern Datum float84pl (PG_FUNCTION_ARGS);
+extern Datum float84mi (PG_FUNCTION_ARGS);
+extern Datum float4eq (PG_FUNCTION_ARGS);
+extern Datum float4ne (PG_FUNCTION_ARGS);
+extern Datum float4lt (PG_FUNCTION_ARGS);
+extern Datum float4le (PG_FUNCTION_ARGS);
+extern Datum float4gt (PG_FUNCTION_ARGS);
+extern Datum float4ge (PG_FUNCTION_ARGS);
+extern Datum float8eq (PG_FUNCTION_ARGS);
+extern Datum float8ne (PG_FUNCTION_ARGS);
+extern Datum float8lt (PG_FUNCTION_ARGS);
+extern Datum float8le (PG_FUNCTION_ARGS);
+extern Datum float8gt (PG_FUNCTION_ARGS);
+extern Datum float8ge (PG_FUNCTION_ARGS);
+extern Datum float48eq (PG_FUNCTION_ARGS);
+extern Datum float48ne (PG_FUNCTION_ARGS);
+extern Datum float48lt (PG_FUNCTION_ARGS);
+extern Datum float48le (PG_FUNCTION_ARGS);
+extern Datum float48gt (PG_FUNCTION_ARGS);
+extern Datum float48ge (PG_FUNCTION_ARGS);
+extern Datum float84eq (PG_FUNCTION_ARGS);
+extern Datum float84ne (PG_FUNCTION_ARGS);
+extern Datum float84lt (PG_FUNCTION_ARGS);
+extern Datum float84le (PG_FUNCTION_ARGS);
+extern Datum float84gt (PG_FUNCTION_ARGS);
+extern Datum float84ge (PG_FUNCTION_ARGS);
+extern Datum ftod (PG_FUNCTION_ARGS);
+extern Datum dtof (PG_FUNCTION_ARGS);
+extern Datum i2toi4 (PG_FUNCTION_ARGS);
+extern Datum i4toi2 (PG_FUNCTION_ARGS);
+extern Datum int2vectoreq (PG_FUNCTION_ARGS);
+extern Datum i4tod (PG_FUNCTION_ARGS);
+extern Datum dtoi4 (PG_FUNCTION_ARGS);
+extern Datum i4tof (PG_FUNCTION_ARGS);
+extern Datum ftoi4 (PG_FUNCTION_ARGS);
+extern Datum width_bucket_float8 (PG_FUNCTION_ARGS);
+extern Datum hash_aclitem (PG_FUNCTION_ARGS);
+extern Datum btgettuple (PG_FUNCTION_ARGS);
+extern Datum btinsert (PG_FUNCTION_ARGS);
+extern Datum btbulkdelete (PG_FUNCTION_ARGS);
+extern Datum btbeginscan (PG_FUNCTION_ARGS);
+extern Datum btrescan (PG_FUNCTION_ARGS);
+extern Datum btendscan (PG_FUNCTION_ARGS);
+extern Datum btmarkpos (PG_FUNCTION_ARGS);
+extern Datum btrestrpos (PG_FUNCTION_ARGS);
+extern Datum btbuild (PG_FUNCTION_ARGS);
+extern Datum poly_same (PG_FUNCTION_ARGS);
+extern Datum poly_contain (PG_FUNCTION_ARGS);
+extern Datum poly_left (PG_FUNCTION_ARGS);
+extern Datum poly_overleft (PG_FUNCTION_ARGS);
+extern Datum poly_overright (PG_FUNCTION_ARGS);
+extern Datum poly_right (PG_FUNCTION_ARGS);
+extern Datum poly_contained (PG_FUNCTION_ARGS);
+extern Datum poly_overlap (PG_FUNCTION_ARGS);
+extern Datum poly_in (PG_FUNCTION_ARGS);
+extern Datum poly_out (PG_FUNCTION_ARGS);
+extern Datum btint2cmp (PG_FUNCTION_ARGS);
+extern Datum btint4cmp (PG_FUNCTION_ARGS);
+extern Datum btfloat4cmp (PG_FUNCTION_ARGS);
+extern Datum btfloat8cmp (PG_FUNCTION_ARGS);
+extern Datum btoidcmp (PG_FUNCTION_ARGS);
+extern Datum btabstimecmp (PG_FUNCTION_ARGS);
+extern Datum btcharcmp (PG_FUNCTION_ARGS);
+extern Datum btnamecmp (PG_FUNCTION_ARGS);
+extern Datum bttextcmp (PG_FUNCTION_ARGS);
+extern Datum lseg_distance (PG_FUNCTION_ARGS);
+extern Datum lseg_interpt (PG_FUNCTION_ARGS);
+extern Datum dist_ps (PG_FUNCTION_ARGS);
+extern Datum dist_pb (PG_FUNCTION_ARGS);
+extern Datum dist_sb (PG_FUNCTION_ARGS);
+extern Datum close_ps (PG_FUNCTION_ARGS);
+extern Datum close_pb (PG_FUNCTION_ARGS);
+extern Datum close_sb (PG_FUNCTION_ARGS);
+extern Datum on_ps (PG_FUNCTION_ARGS);
+extern Datum path_distance (PG_FUNCTION_ARGS);
+extern Datum dist_ppath (PG_FUNCTION_ARGS);
+extern Datum on_sb (PG_FUNCTION_ARGS);
+extern Datum inter_sb (PG_FUNCTION_ARGS);
+extern Datum cash_cmp (PG_FUNCTION_ARGS);
+extern Datum array_push (PG_FUNCTION_ARGS);
+extern Datum btreltimecmp (PG_FUNCTION_ARGS);
+extern Datum bttintervalcmp (PG_FUNCTION_ARGS);
+extern Datum btarraycmp (PG_FUNCTION_ARGS);
+extern Datum array_cat (PG_FUNCTION_ARGS);
+extern Datum array_ne (PG_FUNCTION_ARGS);
+extern Datum array_lt (PG_FUNCTION_ARGS);
+extern Datum array_gt (PG_FUNCTION_ARGS);
+extern Datum array_le (PG_FUNCTION_ARGS);
+extern Datum text_to_array (PG_FUNCTION_ARGS);
+extern Datum array_to_text (PG_FUNCTION_ARGS);
+extern Datum array_ge (PG_FUNCTION_ARGS);
+extern Datum hashint2vector (PG_FUNCTION_ARGS);
+extern Datum hashmacaddr (PG_FUNCTION_ARGS);
+extern Datum hashtext (PG_FUNCTION_ARGS);
+extern Datum rtrim1 (PG_FUNCTION_ARGS);
+extern Datum btoidvectorcmp (PG_FUNCTION_ARGS);
+extern Datum name_text (PG_FUNCTION_ARGS);
+extern Datum text_name (PG_FUNCTION_ARGS);
+extern Datum name_bpchar (PG_FUNCTION_ARGS);
+extern Datum bpchar_name (PG_FUNCTION_ARGS);
+extern Datum hashinet (PG_FUNCTION_ARGS);
+extern Datum hashvacuumcleanup (PG_FUNCTION_ARGS);
+extern Datum hash_numeric (PG_FUNCTION_ARGS);
+extern Datum macaddr_in (PG_FUNCTION_ARGS);
+extern Datum macaddr_out (PG_FUNCTION_ARGS);
+extern Datum hashcostestimate (PG_FUNCTION_ARGS);
+extern Datum hashgettuple (PG_FUNCTION_ARGS);
+extern Datum hashinsert (PG_FUNCTION_ARGS);
+extern Datum hashbulkdelete (PG_FUNCTION_ARGS);
+extern Datum hashbeginscan (PG_FUNCTION_ARGS);
+extern Datum hashrescan (PG_FUNCTION_ARGS);
+extern Datum hashendscan (PG_FUNCTION_ARGS);
+extern Datum hashmarkpos (PG_FUNCTION_ARGS);
+extern Datum hashrestrpos (PG_FUNCTION_ARGS);
+extern Datum hashbuild (PG_FUNCTION_ARGS);
+extern Datum hashint2 (PG_FUNCTION_ARGS);
+extern Datum hashint4 (PG_FUNCTION_ARGS);
+extern Datum hashfloat4 (PG_FUNCTION_ARGS);
+extern Datum hashfloat8 (PG_FUNCTION_ARGS);
+extern Datum hashoid (PG_FUNCTION_ARGS);
+extern Datum hashchar (PG_FUNCTION_ARGS);
+extern Datum hashname (PG_FUNCTION_ARGS);
+extern Datum hashvarlena (PG_FUNCTION_ARGS);
+extern Datum hashoidvector (PG_FUNCTION_ARGS);
+extern Datum text_larger (PG_FUNCTION_ARGS);
+extern Datum text_smaller (PG_FUNCTION_ARGS);
+extern Datum int8in (PG_FUNCTION_ARGS);
+extern Datum int8out (PG_FUNCTION_ARGS);
+extern Datum int8um (PG_FUNCTION_ARGS);
+extern Datum int8pl (PG_FUNCTION_ARGS);
+extern Datum int8mi (PG_FUNCTION_ARGS);
+extern Datum int8mul (PG_FUNCTION_ARGS);
+extern Datum int8div (PG_FUNCTION_ARGS);
+extern Datum int8eq (PG_FUNCTION_ARGS);
+extern Datum int8ne (PG_FUNCTION_ARGS);
+extern Datum int8lt (PG_FUNCTION_ARGS);
+extern Datum int8gt (PG_FUNCTION_ARGS);
+extern Datum int8le (PG_FUNCTION_ARGS);
+extern Datum int8ge (PG_FUNCTION_ARGS);
+extern Datum int84eq (PG_FUNCTION_ARGS);
+extern Datum int84ne (PG_FUNCTION_ARGS);
+extern Datum int84lt (PG_FUNCTION_ARGS);
+extern Datum int84gt (PG_FUNCTION_ARGS);
+extern Datum int84le (PG_FUNCTION_ARGS);
+extern Datum int84ge (PG_FUNCTION_ARGS);
+extern Datum int84 (PG_FUNCTION_ARGS);
+extern Datum int48 (PG_FUNCTION_ARGS);
+extern Datum i8tod (PG_FUNCTION_ARGS);
+extern Datum dtoi8 (PG_FUNCTION_ARGS);
+extern Datum array_larger (PG_FUNCTION_ARGS);
+extern Datum array_smaller (PG_FUNCTION_ARGS);
+extern Datum inet_abbrev (PG_FUNCTION_ARGS);
+extern Datum cidr_abbrev (PG_FUNCTION_ARGS);
+extern Datum inet_set_masklen (PG_FUNCTION_ARGS);
+extern Datum oidvectorne (PG_FUNCTION_ARGS);
+extern Datum cidr_set_masklen (PG_FUNCTION_ARGS);
+extern Datum btgetbitmap (PG_FUNCTION_ARGS);
+extern Datum hashgetbitmap (PG_FUNCTION_ARGS);
+extern Datum gistgetbitmap (PG_FUNCTION_ARGS);
+extern Datum i8tof (PG_FUNCTION_ARGS);
+extern Datum ftoi8 (PG_FUNCTION_ARGS);
+extern Datum namelt (PG_FUNCTION_ARGS);
+extern Datum namele (PG_FUNCTION_ARGS);
+extern Datum namegt (PG_FUNCTION_ARGS);
+extern Datum namege (PG_FUNCTION_ARGS);
+extern Datum namene (PG_FUNCTION_ARGS);
+extern Datum bpchar (PG_FUNCTION_ARGS);
+extern Datum varchar (PG_FUNCTION_ARGS);
+extern Datum mktinterval (PG_FUNCTION_ARGS);
+extern Datum oidvectorlt (PG_FUNCTION_ARGS);
+extern Datum oidvectorle (PG_FUNCTION_ARGS);
+extern Datum oidvectoreq (PG_FUNCTION_ARGS);
+extern Datum oidvectorge (PG_FUNCTION_ARGS);
+extern Datum oidvectorgt (PG_FUNCTION_ARGS);
+extern Datum network_network (PG_FUNCTION_ARGS);
+extern Datum network_netmask (PG_FUNCTION_ARGS);
+extern Datum network_masklen (PG_FUNCTION_ARGS);
+extern Datum network_broadcast (PG_FUNCTION_ARGS);
+extern Datum network_host (PG_FUNCTION_ARGS);
+extern Datum current_user (PG_FUNCTION_ARGS);
+extern Datum network_family (PG_FUNCTION_ARGS);
+extern Datum int82 (PG_FUNCTION_ARGS);
+extern Datum lo_create (PG_FUNCTION_ARGS);
+extern Datum oidlt (PG_FUNCTION_ARGS);
+extern Datum oidle (PG_FUNCTION_ARGS);
+extern Datum byteaoctetlen (PG_FUNCTION_ARGS);
+extern Datum byteaGetByte (PG_FUNCTION_ARGS);
+extern Datum byteaSetByte (PG_FUNCTION_ARGS);
+extern Datum byteaGetBit (PG_FUNCTION_ARGS);
+extern Datum byteaSetBit (PG_FUNCTION_ARGS);
+extern Datum dist_pl (PG_FUNCTION_ARGS);
+extern Datum dist_lb (PG_FUNCTION_ARGS);
+extern Datum dist_sl (PG_FUNCTION_ARGS);
+extern Datum dist_cpoly (PG_FUNCTION_ARGS);
+extern Datum poly_distance (PG_FUNCTION_ARGS);
+extern Datum network_show (PG_FUNCTION_ARGS);
+extern Datum text_lt (PG_FUNCTION_ARGS);
+extern Datum text_le (PG_FUNCTION_ARGS);
+extern Datum text_gt (PG_FUNCTION_ARGS);
+extern Datum text_ge (PG_FUNCTION_ARGS);
+extern Datum array_eq (PG_FUNCTION_ARGS);
+extern Datum session_user (PG_FUNCTION_ARGS);
+extern Datum array_dims (PG_FUNCTION_ARGS);
+extern Datum array_ndims (PG_FUNCTION_ARGS);
+extern Datum array_in (PG_FUNCTION_ARGS);
+extern Datum array_out (PG_FUNCTION_ARGS);
+extern Datum macaddr_trunc (PG_FUNCTION_ARGS);
+extern Datum int28 (PG_FUNCTION_ARGS);
+extern Datum smgrin (PG_FUNCTION_ARGS);
+extern Datum smgrout (PG_FUNCTION_ARGS);
+extern Datum smgreq (PG_FUNCTION_ARGS);
+extern Datum smgrne (PG_FUNCTION_ARGS);
+extern Datum lo_import (PG_FUNCTION_ARGS);
+extern Datum lo_export (PG_FUNCTION_ARGS);
+extern Datum int4inc (PG_FUNCTION_ARGS);
+extern Datum lo_import_with_oid (PG_FUNCTION_ARGS);
+extern Datum int4larger (PG_FUNCTION_ARGS);
+extern Datum int4smaller (PG_FUNCTION_ARGS);
+extern Datum int2larger (PG_FUNCTION_ARGS);
+extern Datum int2smaller (PG_FUNCTION_ARGS);
+extern Datum gistcostestimate (PG_FUNCTION_ARGS);
+extern Datum gistgettuple (PG_FUNCTION_ARGS);
+extern Datum gistinsert (PG_FUNCTION_ARGS);
+extern Datum gistbulkdelete (PG_FUNCTION_ARGS);
+extern Datum gistbeginscan (PG_FUNCTION_ARGS);
+extern Datum gistrescan (PG_FUNCTION_ARGS);
+extern Datum gistendscan (PG_FUNCTION_ARGS);
+extern Datum gistmarkpos (PG_FUNCTION_ARGS);
+extern Datum gistrestrpos (PG_FUNCTION_ARGS);
+extern Datum gistbuild (PG_FUNCTION_ARGS);
+extern Datum tintervaleq (PG_FUNCTION_ARGS);
+extern Datum tintervalne (PG_FUNCTION_ARGS);
+extern Datum tintervallt (PG_FUNCTION_ARGS);
+extern Datum tintervalgt (PG_FUNCTION_ARGS);
+extern Datum tintervalle (PG_FUNCTION_ARGS);
+extern Datum tintervalge (PG_FUNCTION_ARGS);
+extern Datum pg_client_encoding (PG_FUNCTION_ARGS);
+extern Datum current_query (PG_FUNCTION_ARGS);
+extern Datum macaddr_eq (PG_FUNCTION_ARGS);
+extern Datum macaddr_lt (PG_FUNCTION_ARGS);
+extern Datum macaddr_le (PG_FUNCTION_ARGS);
+extern Datum macaddr_gt (PG_FUNCTION_ARGS);
+extern Datum macaddr_ge (PG_FUNCTION_ARGS);
+extern Datum macaddr_ne (PG_FUNCTION_ARGS);
+extern Datum macaddr_cmp (PG_FUNCTION_ARGS);
+extern Datum int82pl (PG_FUNCTION_ARGS);
+extern Datum int82mi (PG_FUNCTION_ARGS);
+extern Datum int82mul (PG_FUNCTION_ARGS);
+extern Datum int82div (PG_FUNCTION_ARGS);
+extern Datum int28pl (PG_FUNCTION_ARGS);
+extern Datum btint8cmp (PG_FUNCTION_ARGS);
+extern Datum cash_mul_flt4 (PG_FUNCTION_ARGS);
+extern Datum cash_div_flt4 (PG_FUNCTION_ARGS);
+extern Datum flt4_mul_cash (PG_FUNCTION_ARGS);
+extern Datum textpos (PG_FUNCTION_ARGS);
+extern Datum textlike (PG_FUNCTION_ARGS);
+extern Datum textnlike (PG_FUNCTION_ARGS);
+extern Datum int48eq (PG_FUNCTION_ARGS);
+extern Datum int48ne (PG_FUNCTION_ARGS);
+extern Datum int48lt (PG_FUNCTION_ARGS);
+extern Datum int48gt (PG_FUNCTION_ARGS);
+extern Datum int48le (PG_FUNCTION_ARGS);
+extern Datum int48ge (PG_FUNCTION_ARGS);
+extern Datum namelike (PG_FUNCTION_ARGS);
+extern Datum namenlike (PG_FUNCTION_ARGS);
+extern Datum char_bpchar (PG_FUNCTION_ARGS);
+extern Datum current_database (PG_FUNCTION_ARGS);
+extern Datum int4_mul_cash (PG_FUNCTION_ARGS);
+extern Datum int2_mul_cash (PG_FUNCTION_ARGS);
+extern Datum cash_mul_int4 (PG_FUNCTION_ARGS);
+extern Datum cash_div_int4 (PG_FUNCTION_ARGS);
+extern Datum cash_mul_int2 (PG_FUNCTION_ARGS);
+extern Datum cash_div_int2 (PG_FUNCTION_ARGS);
+extern Datum lower (PG_FUNCTION_ARGS);
+extern Datum upper (PG_FUNCTION_ARGS);
+extern Datum initcap (PG_FUNCTION_ARGS);
+extern Datum lpad (PG_FUNCTION_ARGS);
+extern Datum rpad (PG_FUNCTION_ARGS);
+extern Datum ltrim (PG_FUNCTION_ARGS);
+extern Datum rtrim (PG_FUNCTION_ARGS);
+extern Datum text_substr (PG_FUNCTION_ARGS);
+extern Datum translate (PG_FUNCTION_ARGS);
+extern Datum ltrim1 (PG_FUNCTION_ARGS);
+extern Datum text_substr_no_len (PG_FUNCTION_ARGS);
+extern Datum btrim (PG_FUNCTION_ARGS);
+extern Datum btrim1 (PG_FUNCTION_ARGS);
+extern Datum cash_in (PG_FUNCTION_ARGS);
+extern Datum cash_out (PG_FUNCTION_ARGS);
+extern Datum cash_eq (PG_FUNCTION_ARGS);
+extern Datum cash_ne (PG_FUNCTION_ARGS);
+extern Datum cash_lt (PG_FUNCTION_ARGS);
+extern Datum cash_le (PG_FUNCTION_ARGS);
+extern Datum cash_gt (PG_FUNCTION_ARGS);
+extern Datum cash_ge (PG_FUNCTION_ARGS);
+extern Datum cash_pl (PG_FUNCTION_ARGS);
+extern Datum cash_mi (PG_FUNCTION_ARGS);
+extern Datum cash_mul_flt8 (PG_FUNCTION_ARGS);
+extern Datum cash_div_flt8 (PG_FUNCTION_ARGS);
+extern Datum cashlarger (PG_FUNCTION_ARGS);
+extern Datum cashsmaller (PG_FUNCTION_ARGS);
+extern Datum inet_in (PG_FUNCTION_ARGS);
+extern Datum inet_out (PG_FUNCTION_ARGS);
+extern Datum flt8_mul_cash (PG_FUNCTION_ARGS);
+extern Datum network_eq (PG_FUNCTION_ARGS);
+extern Datum network_lt (PG_FUNCTION_ARGS);
+extern Datum network_le (PG_FUNCTION_ARGS);
+extern Datum network_gt (PG_FUNCTION_ARGS);
+extern Datum network_ge (PG_FUNCTION_ARGS);
+extern Datum network_ne (PG_FUNCTION_ARGS);
+extern Datum network_cmp (PG_FUNCTION_ARGS);
+extern Datum network_sub (PG_FUNCTION_ARGS);
+extern Datum network_subeq (PG_FUNCTION_ARGS);
+extern Datum network_sup (PG_FUNCTION_ARGS);
+extern Datum network_supeq (PG_FUNCTION_ARGS);
+extern Datum cash_words (PG_FUNCTION_ARGS);
+extern Datum generate_series_timestamp (PG_FUNCTION_ARGS);
+extern Datum generate_series_timestamptz (PG_FUNCTION_ARGS);
+extern Datum int28mi (PG_FUNCTION_ARGS);
+extern Datum int28mul (PG_FUNCTION_ARGS);
+extern Datum text_char (PG_FUNCTION_ARGS);
+extern Datum int8mod (PG_FUNCTION_ARGS);
+extern Datum char_text (PG_FUNCTION_ARGS);
+extern Datum int28div (PG_FUNCTION_ARGS);
+extern Datum hashint8 (PG_FUNCTION_ARGS);
+extern Datum lo_open (PG_FUNCTION_ARGS);
+extern Datum lo_close (PG_FUNCTION_ARGS);
+extern Datum loread (PG_FUNCTION_ARGS);
+extern Datum lowrite (PG_FUNCTION_ARGS);
+extern Datum lo_lseek (PG_FUNCTION_ARGS);
+extern Datum lo_creat (PG_FUNCTION_ARGS);
+extern Datum lo_tell (PG_FUNCTION_ARGS);
+extern Datum on_pl (PG_FUNCTION_ARGS);
+extern Datum on_sl (PG_FUNCTION_ARGS);
+extern Datum close_pl (PG_FUNCTION_ARGS);
+extern Datum close_sl (PG_FUNCTION_ARGS);
+extern Datum close_lb (PG_FUNCTION_ARGS);
+extern Datum lo_unlink (PG_FUNCTION_ARGS);
+extern Datum btvacuumcleanup (PG_FUNCTION_ARGS);
+extern Datum path_inter (PG_FUNCTION_ARGS);
+extern Datum box_area (PG_FUNCTION_ARGS);
+extern Datum box_width (PG_FUNCTION_ARGS);
+extern Datum box_height (PG_FUNCTION_ARGS);
+extern Datum box_distance (PG_FUNCTION_ARGS);
+extern Datum path_area (PG_FUNCTION_ARGS);
+extern Datum box_intersect (PG_FUNCTION_ARGS);
+extern Datum box_diagonal (PG_FUNCTION_ARGS);
+extern Datum path_n_lt (PG_FUNCTION_ARGS);
+extern Datum path_n_gt (PG_FUNCTION_ARGS);
+extern Datum path_n_eq (PG_FUNCTION_ARGS);
+extern Datum path_n_le (PG_FUNCTION_ARGS);
+extern Datum path_n_ge (PG_FUNCTION_ARGS);
+extern Datum path_length (PG_FUNCTION_ARGS);
+extern Datum point_ne (PG_FUNCTION_ARGS);
+extern Datum point_vert (PG_FUNCTION_ARGS);
+extern Datum point_horiz (PG_FUNCTION_ARGS);
+extern Datum point_distance (PG_FUNCTION_ARGS);
+extern Datum point_slope (PG_FUNCTION_ARGS);
+extern Datum lseg_construct (PG_FUNCTION_ARGS);
+extern Datum lseg_intersect (PG_FUNCTION_ARGS);
+extern Datum lseg_parallel (PG_FUNCTION_ARGS);
+extern Datum lseg_perp (PG_FUNCTION_ARGS);
+extern Datum lseg_vertical (PG_FUNCTION_ARGS);
+extern Datum lseg_horizontal (PG_FUNCTION_ARGS);
+extern Datum lseg_eq (PG_FUNCTION_ARGS);
+extern Datum lo_truncate (PG_FUNCTION_ARGS);
+extern Datum timestamptz_izone (PG_FUNCTION_ARGS);
+extern Datum aclitemin (PG_FUNCTION_ARGS);
+extern Datum aclitemout (PG_FUNCTION_ARGS);
+extern Datum aclinsert (PG_FUNCTION_ARGS);
+extern Datum aclremove (PG_FUNCTION_ARGS);
+extern Datum aclcontains (PG_FUNCTION_ARGS);
+extern Datum getdatabaseencoding (PG_FUNCTION_ARGS);
+extern Datum bpcharin (PG_FUNCTION_ARGS);
+extern Datum bpcharout (PG_FUNCTION_ARGS);
+extern Datum varcharin (PG_FUNCTION_ARGS);
+extern Datum varcharout (PG_FUNCTION_ARGS);
+extern Datum bpchareq (PG_FUNCTION_ARGS);
+extern Datum bpcharlt (PG_FUNCTION_ARGS);
+extern Datum bpcharle (PG_FUNCTION_ARGS);
+extern Datum bpchargt (PG_FUNCTION_ARGS);
+extern Datum bpcharge (PG_FUNCTION_ARGS);
+extern Datum bpcharne (PG_FUNCTION_ARGS);
+extern Datum aclitem_eq (PG_FUNCTION_ARGS);
+extern Datum bpchar_larger (PG_FUNCTION_ARGS);
+extern Datum bpchar_smaller (PG_FUNCTION_ARGS);
+extern Datum pg_prepared_xact (PG_FUNCTION_ARGS);
+extern Datum generate_series_step_int4 (PG_FUNCTION_ARGS);
+extern Datum generate_series_int4 (PG_FUNCTION_ARGS);
+extern Datum generate_series_step_int8 (PG_FUNCTION_ARGS);
+extern Datum generate_series_int8 (PG_FUNCTION_ARGS);
+extern Datum bpcharcmp (PG_FUNCTION_ARGS);
+extern Datum text_regclass (PG_FUNCTION_ARGS);
+extern Datum hashbpchar (PG_FUNCTION_ARGS);
+extern Datum format_type (PG_FUNCTION_ARGS);
+extern Datum date_in (PG_FUNCTION_ARGS);
+extern Datum date_out (PG_FUNCTION_ARGS);
+extern Datum date_eq (PG_FUNCTION_ARGS);
+extern Datum date_lt (PG_FUNCTION_ARGS);
+extern Datum date_le (PG_FUNCTION_ARGS);
+extern Datum date_gt (PG_FUNCTION_ARGS);
+extern Datum date_ge (PG_FUNCTION_ARGS);
+extern Datum date_ne (PG_FUNCTION_ARGS);
+extern Datum date_cmp (PG_FUNCTION_ARGS);
+extern Datum time_lt (PG_FUNCTION_ARGS);
+extern Datum time_le (PG_FUNCTION_ARGS);
+extern Datum time_gt (PG_FUNCTION_ARGS);
+extern Datum time_ge (PG_FUNCTION_ARGS);
+extern Datum time_ne (PG_FUNCTION_ARGS);
+extern Datum time_cmp (PG_FUNCTION_ARGS);
+extern Datum date_larger (PG_FUNCTION_ARGS);
+extern Datum date_smaller (PG_FUNCTION_ARGS);
+extern Datum date_mi (PG_FUNCTION_ARGS);
+extern Datum date_pli (PG_FUNCTION_ARGS);
+extern Datum date_mii (PG_FUNCTION_ARGS);
+extern Datum time_in (PG_FUNCTION_ARGS);
+extern Datum time_out (PG_FUNCTION_ARGS);
+extern Datum time_eq (PG_FUNCTION_ARGS);
+extern Datum circle_add_pt (PG_FUNCTION_ARGS);
+extern Datum circle_sub_pt (PG_FUNCTION_ARGS);
+extern Datum circle_mul_pt (PG_FUNCTION_ARGS);
+extern Datum circle_div_pt (PG_FUNCTION_ARGS);
+extern Datum timestamptz_in (PG_FUNCTION_ARGS);
+extern Datum timestamptz_out (PG_FUNCTION_ARGS);
+extern Datum timestamp_eq (PG_FUNCTION_ARGS);
+extern Datum timestamp_ne (PG_FUNCTION_ARGS);
+extern Datum timestamp_lt (PG_FUNCTION_ARGS);
+extern Datum timestamp_le (PG_FUNCTION_ARGS);
+extern Datum timestamp_ge (PG_FUNCTION_ARGS);
+extern Datum timestamp_gt (PG_FUNCTION_ARGS);
+extern Datum timestamptz_zone (PG_FUNCTION_ARGS);
+extern Datum interval_in (PG_FUNCTION_ARGS);
+extern Datum interval_out (PG_FUNCTION_ARGS);
+extern Datum interval_eq (PG_FUNCTION_ARGS);
+extern Datum interval_ne (PG_FUNCTION_ARGS);
+extern Datum interval_lt (PG_FUNCTION_ARGS);
+extern Datum interval_le (PG_FUNCTION_ARGS);
+extern Datum interval_ge (PG_FUNCTION_ARGS);
+extern Datum interval_gt (PG_FUNCTION_ARGS);
+extern Datum interval_um (PG_FUNCTION_ARGS);
+extern Datum interval_pl (PG_FUNCTION_ARGS);
+extern Datum interval_mi (PG_FUNCTION_ARGS);
+extern Datum timestamptz_part (PG_FUNCTION_ARGS);
+extern Datum interval_part (PG_FUNCTION_ARGS);
+extern Datum abstime_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_timestamptz (PG_FUNCTION_ARGS);
+extern Datum interval_justify_hours (PG_FUNCTION_ARGS);
+extern Datum reltime_interval (PG_FUNCTION_ARGS);
+extern Datum timestamptz_date (PG_FUNCTION_ARGS);
+extern Datum abstime_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_abstime (PG_FUNCTION_ARGS);
+extern Datum xid_age (PG_FUNCTION_ARGS);
+extern Datum timestamp_mi (PG_FUNCTION_ARGS);
+extern Datum timestamptz_pl_interval (PG_FUNCTION_ARGS);
+extern Datum timestamptz_mi_interval (PG_FUNCTION_ARGS);
+extern Datum generate_subscripts (PG_FUNCTION_ARGS);
+extern Datum generate_subscripts_nodir (PG_FUNCTION_ARGS);
+extern Datum array_fill (PG_FUNCTION_ARGS);
+extern Datum interval_reltime (PG_FUNCTION_ARGS);
+extern Datum timestamp_smaller (PG_FUNCTION_ARGS);
+extern Datum timestamp_larger (PG_FUNCTION_ARGS);
+extern Datum interval_smaller (PG_FUNCTION_ARGS);
+extern Datum interval_larger (PG_FUNCTION_ARGS);
+extern Datum timestamptz_age (PG_FUNCTION_ARGS);
+extern Datum interval_scale (PG_FUNCTION_ARGS);
+extern Datum timestamptz_trunc (PG_FUNCTION_ARGS);
+extern Datum interval_trunc (PG_FUNCTION_ARGS);
+extern Datum int8inc (PG_FUNCTION_ARGS);
+extern Datum int8abs (PG_FUNCTION_ARGS);
+extern Datum int8larger (PG_FUNCTION_ARGS);
+extern Datum int8smaller (PG_FUNCTION_ARGS);
+extern Datum texticregexeq (PG_FUNCTION_ARGS);
+extern Datum texticregexne (PG_FUNCTION_ARGS);
+extern Datum nameicregexeq (PG_FUNCTION_ARGS);
+extern Datum nameicregexne (PG_FUNCTION_ARGS);
+extern Datum boolin (PG_FUNCTION_ARGS);
+extern Datum boolout (PG_FUNCTION_ARGS);
+extern Datum byteain (PG_FUNCTION_ARGS);
+extern Datum charin (PG_FUNCTION_ARGS);
+extern Datum charlt (PG_FUNCTION_ARGS);
+extern Datum int4abs (PG_FUNCTION_ARGS);
+extern Datum nameregexne (PG_FUNCTION_ARGS);
+extern Datum int2abs (PG_FUNCTION_ARGS);
+extern Datum textregexeq (PG_FUNCTION_ARGS);
+extern Datum textregexne (PG_FUNCTION_ARGS);
+extern Datum textlen (PG_FUNCTION_ARGS);
+extern Datum textcat (PG_FUNCTION_ARGS);
+extern Datum PG_char_to_encoding (PG_FUNCTION_ARGS);
+extern Datum tidne (PG_FUNCTION_ARGS);
+extern Datum cidr_in (PG_FUNCTION_ARGS);
+extern Datum btcostestimate (PG_FUNCTION_ARGS);
+extern Datum pg_column_size (PG_FUNCTION_ARGS);
+extern Datum overlaps_timetz (PG_FUNCTION_ARGS);
+extern Datum datetime_timestamp (PG_FUNCTION_ARGS);
+extern Datum timetz_part (PG_FUNCTION_ARGS);
+extern Datum int84pl (PG_FUNCTION_ARGS);
+extern Datum int84mi (PG_FUNCTION_ARGS);
+extern Datum int84mul (PG_FUNCTION_ARGS);
+extern Datum int84div (PG_FUNCTION_ARGS);
+extern Datum int48pl (PG_FUNCTION_ARGS);
+extern Datum int48mi (PG_FUNCTION_ARGS);
+extern Datum int48mul (PG_FUNCTION_ARGS);
+extern Datum int48div (PG_FUNCTION_ARGS);
+extern Datum quote_ident (PG_FUNCTION_ARGS);
+extern Datum quote_literal (PG_FUNCTION_ARGS);
+extern Datum array_fill_with_lower_bounds (PG_FUNCTION_ARGS);
+extern Datum i8tooid (PG_FUNCTION_ARGS);
+extern Datum oidtoi8 (PG_FUNCTION_ARGS);
+extern Datum quote_nullable (PG_FUNCTION_ARGS);
+extern Datum suppress_redundant_updates_trigger (PG_FUNCTION_ARGS);
+extern Datum tideq (PG_FUNCTION_ARGS);
+extern Datum currtid_byreloid (PG_FUNCTION_ARGS);
+extern Datum currtid_byrelname (PG_FUNCTION_ARGS);
+extern Datum interval_justify_days (PG_FUNCTION_ARGS);
+extern Datum datetimetz_timestamptz (PG_FUNCTION_ARGS);
+extern Datum now (PG_FUNCTION_ARGS);
+extern Datum positionsel (PG_FUNCTION_ARGS);
+extern Datum positionjoinsel (PG_FUNCTION_ARGS);
+extern Datum contsel (PG_FUNCTION_ARGS);
+extern Datum contjoinsel (PG_FUNCTION_ARGS);
+extern Datum overlaps_timestamp (PG_FUNCTION_ARGS);
+extern Datum overlaps_time (PG_FUNCTION_ARGS);
+extern Datum timestamp_in (PG_FUNCTION_ARGS);
+extern Datum timestamp_out (PG_FUNCTION_ARGS);
+extern Datum timestamp_cmp (PG_FUNCTION_ARGS);
+extern Datum interval_cmp (PG_FUNCTION_ARGS);
+extern Datum timestamp_time (PG_FUNCTION_ARGS);
+extern Datum bpcharlen (PG_FUNCTION_ARGS);
+extern Datum interval_div (PG_FUNCTION_ARGS);
+extern Datum dlog10 (PG_FUNCTION_ARGS);
+extern Datum oidvectortypes (PG_FUNCTION_ARGS);
+extern Datum timetz_in (PG_FUNCTION_ARGS);
+extern Datum timetz_out (PG_FUNCTION_ARGS);
+extern Datum timetz_eq (PG_FUNCTION_ARGS);
+extern Datum timetz_ne (PG_FUNCTION_ARGS);
+extern Datum timetz_lt (PG_FUNCTION_ARGS);
+extern Datum timetz_le (PG_FUNCTION_ARGS);
+extern Datum timetz_ge (PG_FUNCTION_ARGS);
+extern Datum timetz_gt (PG_FUNCTION_ARGS);
+extern Datum timetz_cmp (PG_FUNCTION_ARGS);
+extern Datum network_hostmask (PG_FUNCTION_ARGS);
+extern Datum makeaclitem (PG_FUNCTION_ARGS);
+extern Datum time_interval (PG_FUNCTION_ARGS);
+extern Datum pg_lock_status (PG_FUNCTION_ARGS);
+extern Datum date_finite (PG_FUNCTION_ARGS);
+extern Datum textoctetlen (PG_FUNCTION_ARGS);
+extern Datum bpcharoctetlen (PG_FUNCTION_ARGS);
+extern Datum time_larger (PG_FUNCTION_ARGS);
+extern Datum time_smaller (PG_FUNCTION_ARGS);
+extern Datum timetz_larger (PG_FUNCTION_ARGS);
+extern Datum timetz_smaller (PG_FUNCTION_ARGS);
+extern Datum time_part (PG_FUNCTION_ARGS);
+extern Datum pg_get_constraintdef (PG_FUNCTION_ARGS);
+extern Datum timestamptz_timetz (PG_FUNCTION_ARGS);
+extern Datum timestamp_finite (PG_FUNCTION_ARGS);
+extern Datum interval_finite (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_start (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_client_addr (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_client_port (PG_FUNCTION_ARGS);
+extern Datum current_schema (PG_FUNCTION_ARGS);
+extern Datum current_schemas (PG_FUNCTION_ARGS);
+extern Datum line_parallel (PG_FUNCTION_ARGS);
+extern Datum line_perp (PG_FUNCTION_ARGS);
+extern Datum line_vertical (PG_FUNCTION_ARGS);
+extern Datum line_horizontal (PG_FUNCTION_ARGS);
+extern Datum circle_center (PG_FUNCTION_ARGS);
+extern Datum interval_time (PG_FUNCTION_ARGS);
+extern Datum points_box (PG_FUNCTION_ARGS);
+extern Datum box_add (PG_FUNCTION_ARGS);
+extern Datum box_sub (PG_FUNCTION_ARGS);
+extern Datum box_mul (PG_FUNCTION_ARGS);
+extern Datum box_div (PG_FUNCTION_ARGS);
+extern Datum cidr_out (PG_FUNCTION_ARGS);
+extern Datum poly_contain_pt (PG_FUNCTION_ARGS);
+extern Datum pt_contained_poly (PG_FUNCTION_ARGS);
+extern Datum path_isclosed (PG_FUNCTION_ARGS);
+extern Datum path_isopen (PG_FUNCTION_ARGS);
+extern Datum path_npoints (PG_FUNCTION_ARGS);
+extern Datum path_close (PG_FUNCTION_ARGS);
+extern Datum path_open (PG_FUNCTION_ARGS);
+extern Datum path_add (PG_FUNCTION_ARGS);
+extern Datum path_add_pt (PG_FUNCTION_ARGS);
+extern Datum path_sub_pt (PG_FUNCTION_ARGS);
+extern Datum path_mul_pt (PG_FUNCTION_ARGS);
+extern Datum path_div_pt (PG_FUNCTION_ARGS);
+extern Datum construct_point (PG_FUNCTION_ARGS);
+extern Datum point_add (PG_FUNCTION_ARGS);
+extern Datum point_sub (PG_FUNCTION_ARGS);
+extern Datum point_mul (PG_FUNCTION_ARGS);
+extern Datum point_div (PG_FUNCTION_ARGS);
+extern Datum poly_npoints (PG_FUNCTION_ARGS);
+extern Datum poly_box (PG_FUNCTION_ARGS);
+extern Datum poly_path (PG_FUNCTION_ARGS);
+extern Datum box_poly (PG_FUNCTION_ARGS);
+extern Datum path_poly (PG_FUNCTION_ARGS);
+extern Datum circle_in (PG_FUNCTION_ARGS);
+extern Datum circle_out (PG_FUNCTION_ARGS);
+extern Datum circle_same (PG_FUNCTION_ARGS);
+extern Datum circle_contain (PG_FUNCTION_ARGS);
+extern Datum circle_left (PG_FUNCTION_ARGS);
+extern Datum circle_overleft (PG_FUNCTION_ARGS);
+extern Datum circle_overright (PG_FUNCTION_ARGS);
+extern Datum circle_right (PG_FUNCTION_ARGS);
+extern Datum circle_contained (PG_FUNCTION_ARGS);
+extern Datum circle_overlap (PG_FUNCTION_ARGS);
+extern Datum circle_below (PG_FUNCTION_ARGS);
+extern Datum circle_above (PG_FUNCTION_ARGS);
+extern Datum circle_eq (PG_FUNCTION_ARGS);
+extern Datum circle_ne (PG_FUNCTION_ARGS);
+extern Datum circle_lt (PG_FUNCTION_ARGS);
+extern Datum circle_gt (PG_FUNCTION_ARGS);
+extern Datum circle_le (PG_FUNCTION_ARGS);
+extern Datum circle_ge (PG_FUNCTION_ARGS);
+extern Datum circle_area (PG_FUNCTION_ARGS);
+extern Datum circle_diameter (PG_FUNCTION_ARGS);
+extern Datum circle_radius (PG_FUNCTION_ARGS);
+extern Datum circle_distance (PG_FUNCTION_ARGS);
+extern Datum cr_circle (PG_FUNCTION_ARGS);
+extern Datum poly_circle (PG_FUNCTION_ARGS);
+extern Datum circle_poly (PG_FUNCTION_ARGS);
+extern Datum dist_pc (PG_FUNCTION_ARGS);
+extern Datum circle_contain_pt (PG_FUNCTION_ARGS);
+extern Datum pt_contained_circle (PG_FUNCTION_ARGS);
+extern Datum box_circle (PG_FUNCTION_ARGS);
+extern Datum circle_box (PG_FUNCTION_ARGS);
+extern Datum lseg_ne (PG_FUNCTION_ARGS);
+extern Datum lseg_lt (PG_FUNCTION_ARGS);
+extern Datum lseg_le (PG_FUNCTION_ARGS);
+extern Datum lseg_gt (PG_FUNCTION_ARGS);
+extern Datum lseg_ge (PG_FUNCTION_ARGS);
+extern Datum lseg_length (PG_FUNCTION_ARGS);
+extern Datum close_ls (PG_FUNCTION_ARGS);
+extern Datum close_lseg (PG_FUNCTION_ARGS);
+extern Datum line_in (PG_FUNCTION_ARGS);
+extern Datum line_out (PG_FUNCTION_ARGS);
+extern Datum line_eq (PG_FUNCTION_ARGS);
+extern Datum line_construct_pp (PG_FUNCTION_ARGS);
+extern Datum line_interpt (PG_FUNCTION_ARGS);
+extern Datum line_intersect (PG_FUNCTION_ARGS);
+extern Datum bit_in (PG_FUNCTION_ARGS);
+extern Datum bit_out (PG_FUNCTION_ARGS);
+extern Datum pg_get_ruledef (PG_FUNCTION_ARGS);
+extern Datum nextval_oid (PG_FUNCTION_ARGS);
+extern Datum currval_oid (PG_FUNCTION_ARGS);
+extern Datum setval_oid (PG_FUNCTION_ARGS);
+extern Datum varbit_in (PG_FUNCTION_ARGS);
+extern Datum varbit_out (PG_FUNCTION_ARGS);
+extern Datum biteq (PG_FUNCTION_ARGS);
+extern Datum bitne (PG_FUNCTION_ARGS);
+extern Datum bitge (PG_FUNCTION_ARGS);
+extern Datum bitgt (PG_FUNCTION_ARGS);
+extern Datum bitle (PG_FUNCTION_ARGS);
+extern Datum bitlt (PG_FUNCTION_ARGS);
+extern Datum bitcmp (PG_FUNCTION_ARGS);
+extern Datum PG_encoding_to_char (PG_FUNCTION_ARGS);
+extern Datum drandom (PG_FUNCTION_ARGS);
+extern Datum setseed (PG_FUNCTION_ARGS);
+extern Datum dasin (PG_FUNCTION_ARGS);
+extern Datum dacos (PG_FUNCTION_ARGS);
+extern Datum datan (PG_FUNCTION_ARGS);
+extern Datum datan2 (PG_FUNCTION_ARGS);
+extern Datum dsin (PG_FUNCTION_ARGS);
+extern Datum dcos (PG_FUNCTION_ARGS);
+extern Datum dtan (PG_FUNCTION_ARGS);
+extern Datum dcot (PG_FUNCTION_ARGS);
+extern Datum degrees (PG_FUNCTION_ARGS);
+extern Datum radians (PG_FUNCTION_ARGS);
+extern Datum dpi (PG_FUNCTION_ARGS);
+extern Datum interval_mul (PG_FUNCTION_ARGS);
+extern Datum pg_typeof (PG_FUNCTION_ARGS);
+extern Datum ascii (PG_FUNCTION_ARGS);
+extern Datum chr (PG_FUNCTION_ARGS);
+extern Datum repeat (PG_FUNCTION_ARGS);
+extern Datum similar_escape (PG_FUNCTION_ARGS);
+extern Datum mul_d_interval (PG_FUNCTION_ARGS);
+extern Datum texticlike (PG_FUNCTION_ARGS);
+extern Datum texticnlike (PG_FUNCTION_ARGS);
+extern Datum nameiclike (PG_FUNCTION_ARGS);
+extern Datum nameicnlike (PG_FUNCTION_ARGS);
+extern Datum like_escape (PG_FUNCTION_ARGS);
+extern Datum oidgt (PG_FUNCTION_ARGS);
+extern Datum oidge (PG_FUNCTION_ARGS);
+extern Datum pg_get_viewdef_name (PG_FUNCTION_ARGS);
+extern Datum pg_get_viewdef (PG_FUNCTION_ARGS);
+extern Datum pg_get_userbyid (PG_FUNCTION_ARGS);
+extern Datum pg_get_indexdef (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_check_ins (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_check_upd (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_cascade_del (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_cascade_upd (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_restrict_del (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_restrict_upd (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_setnull_del (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_setnull_upd (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_setdefault_del (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_setdefault_upd (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_noaction_del (PG_FUNCTION_ARGS);
+extern Datum RI_FKey_noaction_upd (PG_FUNCTION_ARGS);
+extern Datum pg_get_triggerdef (PG_FUNCTION_ARGS);
+extern Datum pg_get_serial_sequence (PG_FUNCTION_ARGS);
+extern Datum bitand (PG_FUNCTION_ARGS);
+extern Datum bitor (PG_FUNCTION_ARGS);
+extern Datum bitxor (PG_FUNCTION_ARGS);
+extern Datum bitnot (PG_FUNCTION_ARGS);
+extern Datum bitshiftleft (PG_FUNCTION_ARGS);
+extern Datum bitshiftright (PG_FUNCTION_ARGS);
+extern Datum bitcat (PG_FUNCTION_ARGS);
+extern Datum bitsubstr (PG_FUNCTION_ARGS);
+extern Datum bitlength (PG_FUNCTION_ARGS);
+extern Datum bitoctetlength (PG_FUNCTION_ARGS);
+extern Datum bitfromint4 (PG_FUNCTION_ARGS);
+extern Datum bittoint4 (PG_FUNCTION_ARGS);
+extern Datum bit (PG_FUNCTION_ARGS);
+extern Datum pg_get_keywords (PG_FUNCTION_ARGS);
+extern Datum varbit (PG_FUNCTION_ARGS);
+extern Datum time_hash (PG_FUNCTION_ARGS);
+extern Datum flatfile_update_trigger (PG_FUNCTION_ARGS);
+extern Datum time_mi_time (PG_FUNCTION_ARGS);
+extern Datum boolle (PG_FUNCTION_ARGS);
+extern Datum boolge (PG_FUNCTION_ARGS);
+extern Datum btboolcmp (PG_FUNCTION_ARGS);
+extern Datum timetz_hash (PG_FUNCTION_ARGS);
+extern Datum interval_hash (PG_FUNCTION_ARGS);
+extern Datum bitposition (PG_FUNCTION_ARGS);
+extern Datum numeric_in (PG_FUNCTION_ARGS);
+extern Datum numeric_out (PG_FUNCTION_ARGS);
+extern Datum numeric (PG_FUNCTION_ARGS);
+extern Datum numeric_abs (PG_FUNCTION_ARGS);
+extern Datum numeric_sign (PG_FUNCTION_ARGS);
+extern Datum numeric_round (PG_FUNCTION_ARGS);
+extern Datum numeric_trunc (PG_FUNCTION_ARGS);
+extern Datum numeric_ceil (PG_FUNCTION_ARGS);
+extern Datum numeric_floor (PG_FUNCTION_ARGS);
+extern Datum length_in_encoding (PG_FUNCTION_ARGS);
+extern Datum pg_convert_from (PG_FUNCTION_ARGS);
+extern Datum inet_to_cidr (PG_FUNCTION_ARGS);
+extern Datum pg_get_expr (PG_FUNCTION_ARGS);
+extern Datum pg_convert_to (PG_FUNCTION_ARGS);
+extern Datum numeric_eq (PG_FUNCTION_ARGS);
+extern Datum numeric_ne (PG_FUNCTION_ARGS);
+extern Datum numeric_gt (PG_FUNCTION_ARGS);
+extern Datum numeric_ge (PG_FUNCTION_ARGS);
+extern Datum numeric_lt (PG_FUNCTION_ARGS);
+extern Datum numeric_le (PG_FUNCTION_ARGS);
+extern Datum numeric_add (PG_FUNCTION_ARGS);
+extern Datum numeric_sub (PG_FUNCTION_ARGS);
+extern Datum numeric_mul (PG_FUNCTION_ARGS);
+extern Datum numeric_div (PG_FUNCTION_ARGS);
+extern Datum numeric_mod (PG_FUNCTION_ARGS);
+extern Datum numeric_sqrt (PG_FUNCTION_ARGS);
+extern Datum numeric_exp (PG_FUNCTION_ARGS);
+extern Datum numeric_ln (PG_FUNCTION_ARGS);
+extern Datum numeric_log (PG_FUNCTION_ARGS);
+extern Datum numeric_power (PG_FUNCTION_ARGS);
+extern Datum int4_numeric (PG_FUNCTION_ARGS);
+extern Datum float4_numeric (PG_FUNCTION_ARGS);
+extern Datum float8_numeric (PG_FUNCTION_ARGS);
+extern Datum numeric_int4 (PG_FUNCTION_ARGS);
+extern Datum numeric_float4 (PG_FUNCTION_ARGS);
+extern Datum numeric_float8 (PG_FUNCTION_ARGS);
+extern Datum time_pl_interval (PG_FUNCTION_ARGS);
+extern Datum time_mi_interval (PG_FUNCTION_ARGS);
+extern Datum timetz_pl_interval (PG_FUNCTION_ARGS);
+extern Datum timetz_mi_interval (PG_FUNCTION_ARGS);
+extern Datum numeric_inc (PG_FUNCTION_ARGS);
+extern Datum setval3_oid (PG_FUNCTION_ARGS);
+extern Datum numeric_smaller (PG_FUNCTION_ARGS);
+extern Datum numeric_larger (PG_FUNCTION_ARGS);
+extern Datum interval_to_char (PG_FUNCTION_ARGS);
+extern Datum numeric_cmp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_to_char (PG_FUNCTION_ARGS);
+extern Datum numeric_uminus (PG_FUNCTION_ARGS);
+extern Datum numeric_to_char (PG_FUNCTION_ARGS);
+extern Datum int4_to_char (PG_FUNCTION_ARGS);
+extern Datum int8_to_char (PG_FUNCTION_ARGS);
+extern Datum float4_to_char (PG_FUNCTION_ARGS);
+extern Datum float8_to_char (PG_FUNCTION_ARGS);
+extern Datum numeric_to_number (PG_FUNCTION_ARGS);
+extern Datum to_timestamp (PG_FUNCTION_ARGS);
+extern Datum numeric_int8 (PG_FUNCTION_ARGS);
+extern Datum to_date (PG_FUNCTION_ARGS);
+extern Datum int8_numeric (PG_FUNCTION_ARGS);
+extern Datum int2_numeric (PG_FUNCTION_ARGS);
+extern Datum numeric_int2 (PG_FUNCTION_ARGS);
+extern Datum oidin (PG_FUNCTION_ARGS);
+extern Datum oidout (PG_FUNCTION_ARGS);
+extern Datum pg_convert (PG_FUNCTION_ARGS);
+extern Datum iclikesel (PG_FUNCTION_ARGS);
+extern Datum icnlikesel (PG_FUNCTION_ARGS);
+extern Datum iclikejoinsel (PG_FUNCTION_ARGS);
+extern Datum icnlikejoinsel (PG_FUNCTION_ARGS);
+extern Datum regexeqsel (PG_FUNCTION_ARGS);
+extern Datum likesel (PG_FUNCTION_ARGS);
+extern Datum icregexeqsel (PG_FUNCTION_ARGS);
+extern Datum regexnesel (PG_FUNCTION_ARGS);
+extern Datum nlikesel (PG_FUNCTION_ARGS);
+extern Datum icregexnesel (PG_FUNCTION_ARGS);
+extern Datum regexeqjoinsel (PG_FUNCTION_ARGS);
+extern Datum likejoinsel (PG_FUNCTION_ARGS);
+extern Datum icregexeqjoinsel (PG_FUNCTION_ARGS);
+extern Datum regexnejoinsel (PG_FUNCTION_ARGS);
+extern Datum nlikejoinsel (PG_FUNCTION_ARGS);
+extern Datum icregexnejoinsel (PG_FUNCTION_ARGS);
+extern Datum float8_avg (PG_FUNCTION_ARGS);
+extern Datum float8_var_samp (PG_FUNCTION_ARGS);
+extern Datum float8_stddev_samp (PG_FUNCTION_ARGS);
+extern Datum numeric_accum (PG_FUNCTION_ARGS);
+extern Datum int2_accum (PG_FUNCTION_ARGS);
+extern Datum int4_accum (PG_FUNCTION_ARGS);
+extern Datum int8_accum (PG_FUNCTION_ARGS);
+extern Datum numeric_avg (PG_FUNCTION_ARGS);
+extern Datum numeric_var_samp (PG_FUNCTION_ARGS);
+extern Datum numeric_stddev_samp (PG_FUNCTION_ARGS);
+extern Datum int2_sum (PG_FUNCTION_ARGS);
+extern Datum int4_sum (PG_FUNCTION_ARGS);
+extern Datum int8_sum (PG_FUNCTION_ARGS);
+extern Datum interval_accum (PG_FUNCTION_ARGS);
+extern Datum interval_avg (PG_FUNCTION_ARGS);
+extern Datum to_ascii_default (PG_FUNCTION_ARGS);
+extern Datum to_ascii_enc (PG_FUNCTION_ARGS);
+extern Datum to_ascii_encname (PG_FUNCTION_ARGS);
+extern Datum int28eq (PG_FUNCTION_ARGS);
+extern Datum int28ne (PG_FUNCTION_ARGS);
+extern Datum int28lt (PG_FUNCTION_ARGS);
+extern Datum int28gt (PG_FUNCTION_ARGS);
+extern Datum int28le (PG_FUNCTION_ARGS);
+extern Datum int28ge (PG_FUNCTION_ARGS);
+extern Datum int82eq (PG_FUNCTION_ARGS);
+extern Datum int82ne (PG_FUNCTION_ARGS);
+extern Datum int82lt (PG_FUNCTION_ARGS);
+extern Datum int82gt (PG_FUNCTION_ARGS);
+extern Datum int82le (PG_FUNCTION_ARGS);
+extern Datum int82ge (PG_FUNCTION_ARGS);
+extern Datum int2and (PG_FUNCTION_ARGS);
+extern Datum int2or (PG_FUNCTION_ARGS);
+extern Datum int2xor (PG_FUNCTION_ARGS);
+extern Datum int2not (PG_FUNCTION_ARGS);
+extern Datum int2shl (PG_FUNCTION_ARGS);
+extern Datum int2shr (PG_FUNCTION_ARGS);
+extern Datum int4and (PG_FUNCTION_ARGS);
+extern Datum int4or (PG_FUNCTION_ARGS);
+extern Datum int4xor (PG_FUNCTION_ARGS);
+extern Datum int4not (PG_FUNCTION_ARGS);
+extern Datum int4shl (PG_FUNCTION_ARGS);
+extern Datum int4shr (PG_FUNCTION_ARGS);
+extern Datum int8and (PG_FUNCTION_ARGS);
+extern Datum int8or (PG_FUNCTION_ARGS);
+extern Datum int8xor (PG_FUNCTION_ARGS);
+extern Datum int8not (PG_FUNCTION_ARGS);
+extern Datum int8shl (PG_FUNCTION_ARGS);
+extern Datum int8shr (PG_FUNCTION_ARGS);
+extern Datum int8up (PG_FUNCTION_ARGS);
+extern Datum int2up (PG_FUNCTION_ARGS);
+extern Datum int4up (PG_FUNCTION_ARGS);
+extern Datum float4up (PG_FUNCTION_ARGS);
+extern Datum float8up (PG_FUNCTION_ARGS);
+extern Datum numeric_uplus (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_table_privilege_id (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_numscans (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_returned (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_fetched (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_inserted (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_updated (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_deleted (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_blocks_fetched (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_blocks_hit (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_idset (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_pid (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_dbid (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_userid (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_activity (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_numbackends (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_xact_commit (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_xact_rollback (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_blocks_fetched (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_blocks_hit (PG_FUNCTION_ARGS);
+extern Datum binary_encode (PG_FUNCTION_ARGS);
+extern Datum binary_decode (PG_FUNCTION_ARGS);
+extern Datum byteaeq (PG_FUNCTION_ARGS);
+extern Datum bytealt (PG_FUNCTION_ARGS);
+extern Datum byteale (PG_FUNCTION_ARGS);
+extern Datum byteagt (PG_FUNCTION_ARGS);
+extern Datum byteage (PG_FUNCTION_ARGS);
+extern Datum byteane (PG_FUNCTION_ARGS);
+extern Datum byteacmp (PG_FUNCTION_ARGS);
+extern Datum timestamp_scale (PG_FUNCTION_ARGS);
+extern Datum int2_avg_accum (PG_FUNCTION_ARGS);
+extern Datum int4_avg_accum (PG_FUNCTION_ARGS);
+extern Datum int8_avg (PG_FUNCTION_ARGS);
+extern Datum oidlarger (PG_FUNCTION_ARGS);
+extern Datum oidsmaller (PG_FUNCTION_ARGS);
+extern Datum timestamptz_scale (PG_FUNCTION_ARGS);
+extern Datum time_scale (PG_FUNCTION_ARGS);
+extern Datum timetz_scale (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_tuples_hot_updated (PG_FUNCTION_ARGS);
+extern Datum numeric_div_trunc (PG_FUNCTION_ARGS);
+extern Datum bytealike (PG_FUNCTION_ARGS);
+extern Datum byteanlike (PG_FUNCTION_ARGS);
+extern Datum like_escape_bytea (PG_FUNCTION_ARGS);
+extern Datum byteacat (PG_FUNCTION_ARGS);
+extern Datum bytea_substr (PG_FUNCTION_ARGS);
+extern Datum bytea_substr_no_len (PG_FUNCTION_ARGS);
+extern Datum byteapos (PG_FUNCTION_ARGS);
+extern Datum byteatrim (PG_FUNCTION_ARGS);
+extern Datum timestamptz_time (PG_FUNCTION_ARGS);
+extern Datum timestamp_trunc (PG_FUNCTION_ARGS);
+extern Datum timestamp_part (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_activity (PG_FUNCTION_ARGS);
+extern Datum abstime_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_timestamp (PG_FUNCTION_ARGS);
+extern Datum pg_backend_pid (PG_FUNCTION_ARGS);
+extern Datum timestamptz_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamp_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_abstime (PG_FUNCTION_ARGS);
+extern Datum timestamp_pl_interval (PG_FUNCTION_ARGS);
+extern Datum timestamp_mi_interval (PG_FUNCTION_ARGS);
+extern Datum pg_conf_load_time (PG_FUNCTION_ARGS);
+extern Datum timetz_zone (PG_FUNCTION_ARGS);
+extern Datum timetz_izone (PG_FUNCTION_ARGS);
+extern Datum timestamp_hash (PG_FUNCTION_ARGS);
+extern Datum timetz_time (PG_FUNCTION_ARGS);
+extern Datum time_timetz (PG_FUNCTION_ARGS);
+extern Datum timestamp_to_char (PG_FUNCTION_ARGS);
+extern Datum aggregate_dummy (PG_FUNCTION_ARGS);
+extern Datum timestamp_age (PG_FUNCTION_ARGS);
+extern Datum timestamp_zone (PG_FUNCTION_ARGS);
+extern Datum timestamp_izone (PG_FUNCTION_ARGS);
+extern Datum date_pl_interval (PG_FUNCTION_ARGS);
+extern Datum date_mi_interval (PG_FUNCTION_ARGS);
+extern Datum textregexsubstr (PG_FUNCTION_ARGS);
+extern Datum bitfromint8 (PG_FUNCTION_ARGS);
+extern Datum bittoint8 (PG_FUNCTION_ARGS);
+extern Datum show_config_by_name (PG_FUNCTION_ARGS);
+extern Datum set_config_by_name (PG_FUNCTION_ARGS);
+extern Datum pg_table_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_type_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_function_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_operator_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_opclass_is_visible (PG_FUNCTION_ARGS);
+extern Datum show_all_settings (PG_FUNCTION_ARGS);
+extern Datum replace_text (PG_FUNCTION_ARGS);
+extern Datum split_text (PG_FUNCTION_ARGS);
+extern Datum to_hex32 (PG_FUNCTION_ARGS);
+extern Datum to_hex64 (PG_FUNCTION_ARGS);
+extern Datum array_lower (PG_FUNCTION_ARGS);
+extern Datum array_upper (PG_FUNCTION_ARGS);
+extern Datum pg_conversion_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_activity_start (PG_FUNCTION_ARGS);
+extern Datum pg_terminate_backend (PG_FUNCTION_ARGS);
+extern Datum pg_get_functiondef (PG_FUNCTION_ARGS);
+extern Datum text_pattern_lt (PG_FUNCTION_ARGS);
+extern Datum text_pattern_le (PG_FUNCTION_ARGS);
+extern Datum pg_get_function_arguments (PG_FUNCTION_ARGS);
+extern Datum text_pattern_ge (PG_FUNCTION_ARGS);
+extern Datum text_pattern_gt (PG_FUNCTION_ARGS);
+extern Datum pg_get_function_result (PG_FUNCTION_ARGS);
+extern Datum bttext_pattern_cmp (PG_FUNCTION_ARGS);
+extern Datum pg_database_size_name (PG_FUNCTION_ARGS);
+extern Datum width_bucket_numeric (PG_FUNCTION_ARGS);
+extern Datum pg_cancel_backend (PG_FUNCTION_ARGS);
+extern Datum pg_start_backup (PG_FUNCTION_ARGS);
+extern Datum pg_stop_backup (PG_FUNCTION_ARGS);
+extern Datum bpchar_pattern_lt (PG_FUNCTION_ARGS);
+extern Datum bpchar_pattern_le (PG_FUNCTION_ARGS);
+extern Datum array_length (PG_FUNCTION_ARGS);
+extern Datum bpchar_pattern_ge (PG_FUNCTION_ARGS);
+extern Datum bpchar_pattern_gt (PG_FUNCTION_ARGS);
+extern Datum btbpchar_pattern_cmp (PG_FUNCTION_ARGS);
+extern Datum btint48cmp (PG_FUNCTION_ARGS);
+extern Datum btint84cmp (PG_FUNCTION_ARGS);
+extern Datum btint24cmp (PG_FUNCTION_ARGS);
+extern Datum btint42cmp (PG_FUNCTION_ARGS);
+extern Datum btint28cmp (PG_FUNCTION_ARGS);
+extern Datum btint82cmp (PG_FUNCTION_ARGS);
+extern Datum btfloat48cmp (PG_FUNCTION_ARGS);
+extern Datum btfloat84cmp (PG_FUNCTION_ARGS);
+extern Datum inet_client_addr (PG_FUNCTION_ARGS);
+extern Datum inet_client_port (PG_FUNCTION_ARGS);
+extern Datum inet_server_addr (PG_FUNCTION_ARGS);
+extern Datum inet_server_port (PG_FUNCTION_ARGS);
+extern Datum regprocedurein (PG_FUNCTION_ARGS);
+extern Datum regprocedureout (PG_FUNCTION_ARGS);
+extern Datum regoperin (PG_FUNCTION_ARGS);
+extern Datum regoperout (PG_FUNCTION_ARGS);
+extern Datum regoperatorin (PG_FUNCTION_ARGS);
+extern Datum regoperatorout (PG_FUNCTION_ARGS);
+extern Datum regclassin (PG_FUNCTION_ARGS);
+extern Datum regclassout (PG_FUNCTION_ARGS);
+extern Datum regtypein (PG_FUNCTION_ARGS);
+extern Datum regtypeout (PG_FUNCTION_ARGS);
+extern Datum pg_stat_clear_snapshot (PG_FUNCTION_ARGS);
+extern Datum pg_get_function_identity_arguments (PG_FUNCTION_ARGS);
+extern Datum fmgr_internal_validator (PG_FUNCTION_ARGS);
+extern Datum fmgr_c_validator (PG_FUNCTION_ARGS);
+extern Datum fmgr_sql_validator (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_database_privilege_id (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_function_privilege_id (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_language_privilege_id (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_schema_privilege_id (PG_FUNCTION_ARGS);
+extern Datum pg_stat_reset (PG_FUNCTION_ARGS);
+extern Datum textregexreplace_noopt (PG_FUNCTION_ARGS);
+extern Datum textregexreplace (PG_FUNCTION_ARGS);
+extern Datum pg_total_relation_size (PG_FUNCTION_ARGS);
+extern Datum pg_size_pretty (PG_FUNCTION_ARGS);
+extern Datum pg_options_to_table (PG_FUNCTION_ARGS);
+extern Datum record_in (PG_FUNCTION_ARGS);
+extern Datum record_out (PG_FUNCTION_ARGS);
+extern Datum cstring_in (PG_FUNCTION_ARGS);
+extern Datum cstring_out (PG_FUNCTION_ARGS);
+extern Datum any_in (PG_FUNCTION_ARGS);
+extern Datum any_out (PG_FUNCTION_ARGS);
+extern Datum anyarray_in (PG_FUNCTION_ARGS);
+extern Datum anyarray_out (PG_FUNCTION_ARGS);
+extern Datum void_in (PG_FUNCTION_ARGS);
+extern Datum void_out (PG_FUNCTION_ARGS);
+extern Datum trigger_in (PG_FUNCTION_ARGS);
+extern Datum trigger_out (PG_FUNCTION_ARGS);
+extern Datum language_handler_in (PG_FUNCTION_ARGS);
+extern Datum language_handler_out (PG_FUNCTION_ARGS);
+extern Datum internal_in (PG_FUNCTION_ARGS);
+extern Datum internal_out (PG_FUNCTION_ARGS);
+extern Datum opaque_in (PG_FUNCTION_ARGS);
+extern Datum opaque_out (PG_FUNCTION_ARGS);
+extern Datum dceil (PG_FUNCTION_ARGS);
+extern Datum dfloor (PG_FUNCTION_ARGS);
+extern Datum dsign (PG_FUNCTION_ARGS);
+extern Datum md5_text (PG_FUNCTION_ARGS);
+extern Datum anyelement_in (PG_FUNCTION_ARGS);
+extern Datum anyelement_out (PG_FUNCTION_ARGS);
+extern Datum postgresql_fdw_validator (PG_FUNCTION_ARGS);
+extern Datum md5_bytea (PG_FUNCTION_ARGS);
+extern Datum pg_tablespace_size_oid (PG_FUNCTION_ARGS);
+extern Datum pg_tablespace_size_name (PG_FUNCTION_ARGS);
+extern Datum pg_database_size_oid (PG_FUNCTION_ARGS);
+extern Datum array_unnest (PG_FUNCTION_ARGS);
+extern Datum pg_relation_size (PG_FUNCTION_ARGS);
+extern Datum array_agg_transfn (PG_FUNCTION_ARGS);
+extern Datum array_agg_finalfn (PG_FUNCTION_ARGS);
+extern Datum date_lt_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_le_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_eq_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_gt_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_ge_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_ne_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_cmp_timestamp (PG_FUNCTION_ARGS);
+extern Datum date_lt_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_le_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_eq_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_gt_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_ge_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_ne_timestamptz (PG_FUNCTION_ARGS);
+extern Datum date_cmp_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_lt_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_le_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_eq_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_gt_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_ge_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_ne_date (PG_FUNCTION_ARGS);
+extern Datum timestamp_cmp_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_lt_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_le_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_eq_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_gt_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_ge_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_ne_date (PG_FUNCTION_ARGS);
+extern Datum timestamptz_cmp_date (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_tablespace_privilege_id (PG_FUNCTION_ARGS);
+extern Datum shell_in (PG_FUNCTION_ARGS);
+extern Datum shell_out (PG_FUNCTION_ARGS);
+extern Datum array_recv (PG_FUNCTION_ARGS);
+extern Datum array_send (PG_FUNCTION_ARGS);
+extern Datum record_recv (PG_FUNCTION_ARGS);
+extern Datum record_send (PG_FUNCTION_ARGS);
+extern Datum int2recv (PG_FUNCTION_ARGS);
+extern Datum int2send (PG_FUNCTION_ARGS);
+extern Datum int4recv (PG_FUNCTION_ARGS);
+extern Datum int4send (PG_FUNCTION_ARGS);
+extern Datum int8recv (PG_FUNCTION_ARGS);
+extern Datum int8send (PG_FUNCTION_ARGS);
+extern Datum int2vectorrecv (PG_FUNCTION_ARGS);
+extern Datum int2vectorsend (PG_FUNCTION_ARGS);
+extern Datum bytearecv (PG_FUNCTION_ARGS);
+extern Datum byteasend (PG_FUNCTION_ARGS);
+extern Datum textrecv (PG_FUNCTION_ARGS);
+extern Datum textsend (PG_FUNCTION_ARGS);
+extern Datum unknownrecv (PG_FUNCTION_ARGS);
+extern Datum unknownsend (PG_FUNCTION_ARGS);
+extern Datum oidrecv (PG_FUNCTION_ARGS);
+extern Datum oidsend (PG_FUNCTION_ARGS);
+extern Datum oidvectorrecv (PG_FUNCTION_ARGS);
+extern Datum oidvectorsend (PG_FUNCTION_ARGS);
+extern Datum namerecv (PG_FUNCTION_ARGS);
+extern Datum namesend (PG_FUNCTION_ARGS);
+extern Datum float4recv (PG_FUNCTION_ARGS);
+extern Datum float4send (PG_FUNCTION_ARGS);
+extern Datum float8recv (PG_FUNCTION_ARGS);
+extern Datum float8send (PG_FUNCTION_ARGS);
+extern Datum point_recv (PG_FUNCTION_ARGS);
+extern Datum point_send (PG_FUNCTION_ARGS);
+extern Datum bpcharrecv (PG_FUNCTION_ARGS);
+extern Datum bpcharsend (PG_FUNCTION_ARGS);
+extern Datum varcharrecv (PG_FUNCTION_ARGS);
+extern Datum varcharsend (PG_FUNCTION_ARGS);
+extern Datum charrecv (PG_FUNCTION_ARGS);
+extern Datum charsend (PG_FUNCTION_ARGS);
+extern Datum boolrecv (PG_FUNCTION_ARGS);
+extern Datum boolsend (PG_FUNCTION_ARGS);
+extern Datum tidrecv (PG_FUNCTION_ARGS);
+extern Datum tidsend (PG_FUNCTION_ARGS);
+extern Datum xidrecv (PG_FUNCTION_ARGS);
+extern Datum xidsend (PG_FUNCTION_ARGS);
+extern Datum cidrecv (PG_FUNCTION_ARGS);
+extern Datum cidsend (PG_FUNCTION_ARGS);
+extern Datum regprocrecv (PG_FUNCTION_ARGS);
+extern Datum regprocsend (PG_FUNCTION_ARGS);
+extern Datum regprocedurerecv (PG_FUNCTION_ARGS);
+extern Datum regproceduresend (PG_FUNCTION_ARGS);
+extern Datum regoperrecv (PG_FUNCTION_ARGS);
+extern Datum regopersend (PG_FUNCTION_ARGS);
+extern Datum regoperatorrecv (PG_FUNCTION_ARGS);
+extern Datum regoperatorsend (PG_FUNCTION_ARGS);
+extern Datum regclassrecv (PG_FUNCTION_ARGS);
+extern Datum regclasssend (PG_FUNCTION_ARGS);
+extern Datum regtyperecv (PG_FUNCTION_ARGS);
+extern Datum regtypesend (PG_FUNCTION_ARGS);
+extern Datum bit_recv (PG_FUNCTION_ARGS);
+extern Datum bit_send (PG_FUNCTION_ARGS);
+extern Datum varbit_recv (PG_FUNCTION_ARGS);
+extern Datum varbit_send (PG_FUNCTION_ARGS);
+extern Datum numeric_recv (PG_FUNCTION_ARGS);
+extern Datum numeric_send (PG_FUNCTION_ARGS);
+extern Datum abstimerecv (PG_FUNCTION_ARGS);
+extern Datum abstimesend (PG_FUNCTION_ARGS);
+extern Datum reltimerecv (PG_FUNCTION_ARGS);
+extern Datum reltimesend (PG_FUNCTION_ARGS);
+extern Datum tintervalrecv (PG_FUNCTION_ARGS);
+extern Datum tintervalsend (PG_FUNCTION_ARGS);
+extern Datum date_recv (PG_FUNCTION_ARGS);
+extern Datum date_send (PG_FUNCTION_ARGS);
+extern Datum time_recv (PG_FUNCTION_ARGS);
+extern Datum time_send (PG_FUNCTION_ARGS);
+extern Datum timetz_recv (PG_FUNCTION_ARGS);
+extern Datum timetz_send (PG_FUNCTION_ARGS);
+extern Datum timestamp_recv (PG_FUNCTION_ARGS);
+extern Datum timestamp_send (PG_FUNCTION_ARGS);
+extern Datum timestamptz_recv (PG_FUNCTION_ARGS);
+extern Datum timestamptz_send (PG_FUNCTION_ARGS);
+extern Datum interval_recv (PG_FUNCTION_ARGS);
+extern Datum interval_send (PG_FUNCTION_ARGS);
+extern Datum lseg_recv (PG_FUNCTION_ARGS);
+extern Datum lseg_send (PG_FUNCTION_ARGS);
+extern Datum path_recv (PG_FUNCTION_ARGS);
+extern Datum path_send (PG_FUNCTION_ARGS);
+extern Datum box_recv (PG_FUNCTION_ARGS);
+extern Datum box_send (PG_FUNCTION_ARGS);
+extern Datum poly_recv (PG_FUNCTION_ARGS);
+extern Datum poly_send (PG_FUNCTION_ARGS);
+extern Datum line_recv (PG_FUNCTION_ARGS);
+extern Datum line_send (PG_FUNCTION_ARGS);
+extern Datum circle_recv (PG_FUNCTION_ARGS);
+extern Datum circle_send (PG_FUNCTION_ARGS);
+extern Datum cash_recv (PG_FUNCTION_ARGS);
+extern Datum cash_send (PG_FUNCTION_ARGS);
+extern Datum macaddr_recv (PG_FUNCTION_ARGS);
+extern Datum macaddr_send (PG_FUNCTION_ARGS);
+extern Datum inet_recv (PG_FUNCTION_ARGS);
+extern Datum inet_send (PG_FUNCTION_ARGS);
+extern Datum cidr_recv (PG_FUNCTION_ARGS);
+extern Datum cidr_send (PG_FUNCTION_ARGS);
+extern Datum cstring_recv (PG_FUNCTION_ARGS);
+extern Datum cstring_send (PG_FUNCTION_ARGS);
+extern Datum anyarray_recv (PG_FUNCTION_ARGS);
+extern Datum anyarray_send (PG_FUNCTION_ARGS);
+extern Datum pg_get_ruledef_ext (PG_FUNCTION_ARGS);
+extern Datum pg_get_viewdef_name_ext (PG_FUNCTION_ARGS);
+extern Datum pg_get_viewdef_ext (PG_FUNCTION_ARGS);
+extern Datum pg_get_indexdef_ext (PG_FUNCTION_ARGS);
+extern Datum pg_get_constraintdef_ext (PG_FUNCTION_ARGS);
+extern Datum pg_get_expr_ext (PG_FUNCTION_ARGS);
+extern Datum pg_prepared_statement (PG_FUNCTION_ARGS);
+extern Datum pg_cursor (PG_FUNCTION_ARGS);
+extern Datum float8_var_pop (PG_FUNCTION_ARGS);
+extern Datum float8_stddev_pop (PG_FUNCTION_ARGS);
+extern Datum numeric_var_pop (PG_FUNCTION_ARGS);
+extern Datum booland_statefunc (PG_FUNCTION_ARGS);
+extern Datum boolor_statefunc (PG_FUNCTION_ARGS);
+extern Datum timestamp_lt_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_le_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_eq_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_gt_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_ge_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_ne_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamp_cmp_timestamptz (PG_FUNCTION_ARGS);
+extern Datum timestamptz_lt_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_le_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_eq_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_gt_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_ge_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_ne_timestamp (PG_FUNCTION_ARGS);
+extern Datum timestamptz_cmp_timestamp (PG_FUNCTION_ARGS);
+extern Datum pg_tablespace_databases (PG_FUNCTION_ARGS);
+extern Datum int4_bool (PG_FUNCTION_ARGS);
+extern Datum bool_int4 (PG_FUNCTION_ARGS);
+extern Datum lastval (PG_FUNCTION_ARGS);
+extern Datum pg_postmaster_start_time (PG_FUNCTION_ARGS);
+extern Datum gistvacuumcleanup (PG_FUNCTION_ARGS);
+extern Datum box_below (PG_FUNCTION_ARGS);
+extern Datum box_overbelow (PG_FUNCTION_ARGS);
+extern Datum box_overabove (PG_FUNCTION_ARGS);
+extern Datum box_above (PG_FUNCTION_ARGS);
+extern Datum poly_below (PG_FUNCTION_ARGS);
+extern Datum poly_overbelow (PG_FUNCTION_ARGS);
+extern Datum poly_overabove (PG_FUNCTION_ARGS);
+extern Datum poly_above (PG_FUNCTION_ARGS);
+extern Datum gist_box_consistent (PG_FUNCTION_ARGS);
+extern Datum gist_box_compress (PG_FUNCTION_ARGS);
+extern Datum gist_box_decompress (PG_FUNCTION_ARGS);
+extern Datum gist_box_penalty (PG_FUNCTION_ARGS);
+extern Datum gist_box_picksplit (PG_FUNCTION_ARGS);
+extern Datum gist_box_union (PG_FUNCTION_ARGS);
+extern Datum gist_box_same (PG_FUNCTION_ARGS);
+extern Datum gist_poly_consistent (PG_FUNCTION_ARGS);
+extern Datum gist_poly_compress (PG_FUNCTION_ARGS);
+extern Datum circle_overbelow (PG_FUNCTION_ARGS);
+extern Datum circle_overabove (PG_FUNCTION_ARGS);
+extern Datum gist_circle_consistent (PG_FUNCTION_ARGS);
+extern Datum gist_circle_compress (PG_FUNCTION_ARGS);
+extern Datum numeric_stddev_pop (PG_FUNCTION_ARGS);
+extern Datum domain_in (PG_FUNCTION_ARGS);
+extern Datum domain_recv (PG_FUNCTION_ARGS);
+extern Datum pg_timezone_abbrevs (PG_FUNCTION_ARGS);
+extern Datum pg_reload_conf (PG_FUNCTION_ARGS);
+extern Datum pg_rotate_logfile (PG_FUNCTION_ARGS);
+extern Datum pg_stat_file (PG_FUNCTION_ARGS);
+extern Datum pg_read_file (PG_FUNCTION_ARGS);
+extern Datum pg_ls_dir (PG_FUNCTION_ARGS);
+extern Datum pg_sleep (PG_FUNCTION_ARGS);
+extern Datum inetnot (PG_FUNCTION_ARGS);
+extern Datum inetand (PG_FUNCTION_ARGS);
+extern Datum inetor (PG_FUNCTION_ARGS);
+extern Datum inetpl (PG_FUNCTION_ARGS);
+extern Datum inetmi_int8 (PG_FUNCTION_ARGS);
+extern Datum inetmi (PG_FUNCTION_ARGS);
+extern Datum statement_timestamp (PG_FUNCTION_ARGS);
+extern Datum clock_timestamp (PG_FUNCTION_ARGS);
+extern Datum gin_cmp_prefix (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_name_name (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_name_id (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_id_name (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_id_id (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_name (PG_FUNCTION_ARGS);
+extern Datum pg_has_role_id (PG_FUNCTION_ARGS);
+extern Datum interval_justify_interval (PG_FUNCTION_ARGS);
+extern Datum gingetbitmap (PG_FUNCTION_ARGS);
+extern Datum gininsert (PG_FUNCTION_ARGS);
+extern Datum ginbeginscan (PG_FUNCTION_ARGS);
+extern Datum ginrescan (PG_FUNCTION_ARGS);
+extern Datum ginendscan (PG_FUNCTION_ARGS);
+extern Datum ginmarkpos (PG_FUNCTION_ARGS);
+extern Datum ginrestrpos (PG_FUNCTION_ARGS);
+extern Datum ginbuild (PG_FUNCTION_ARGS);
+extern Datum ginbulkdelete (PG_FUNCTION_ARGS);
+extern Datum ginvacuumcleanup (PG_FUNCTION_ARGS);
+extern Datum gincostestimate (PG_FUNCTION_ARGS);
+extern Datum ginarrayextract (PG_FUNCTION_ARGS);
+extern Datum ginarrayconsistent (PG_FUNCTION_ARGS);
+extern Datum int8_avg_accum (PG_FUNCTION_ARGS);
+extern Datum arrayoverlap (PG_FUNCTION_ARGS);
+extern Datum arraycontains (PG_FUNCTION_ARGS);
+extern Datum arraycontained (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_tuples_returned (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_tuples_fetched (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_tuples_inserted (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_tuples_updated (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_db_tuples_deleted (PG_FUNCTION_ARGS);
+extern Datum regexp_matches_no_flags (PG_FUNCTION_ARGS);
+extern Datum regexp_matches (PG_FUNCTION_ARGS);
+extern Datum regexp_split_to_table_no_flags (PG_FUNCTION_ARGS);
+extern Datum regexp_split_to_table (PG_FUNCTION_ARGS);
+extern Datum regexp_split_to_array_no_flags (PG_FUNCTION_ARGS);
+extern Datum regexp_split_to_array (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_bgwriter_timed_checkpoints (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_bgwriter_requested_checkpoints (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_bgwriter_buf_written_checkpoints (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_bgwriter_buf_written_clean (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_bgwriter_maxwritten_clean (PG_FUNCTION_ARGS);
+extern Datum ginqueryarrayextract (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_buf_written_backend (PG_FUNCTION_ARGS);
+extern Datum anynonarray_in (PG_FUNCTION_ARGS);
+extern Datum anynonarray_out (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_last_vacuum_time (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_last_autovacuum_time (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_last_analyze_time (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_last_autoanalyze_time (PG_FUNCTION_ARGS);
+extern Datum btoptions (PG_FUNCTION_ARGS);
+extern Datum hashoptions (PG_FUNCTION_ARGS);
+extern Datum gistoptions (PG_FUNCTION_ARGS);
+extern Datum ginoptions (PG_FUNCTION_ARGS);
+extern Datum tidgt (PG_FUNCTION_ARGS);
+extern Datum tidlt (PG_FUNCTION_ARGS);
+extern Datum tidge (PG_FUNCTION_ARGS);
+extern Datum tidle (PG_FUNCTION_ARGS);
+extern Datum bttidcmp (PG_FUNCTION_ARGS);
+extern Datum tidlarger (PG_FUNCTION_ARGS);
+extern Datum tidsmaller (PG_FUNCTION_ARGS);
+extern Datum int8inc_any (PG_FUNCTION_ARGS);
+extern Datum int8inc_float8_float8 (PG_FUNCTION_ARGS);
+extern Datum float8_regr_accum (PG_FUNCTION_ARGS);
+extern Datum float8_regr_sxx (PG_FUNCTION_ARGS);
+extern Datum float8_regr_syy (PG_FUNCTION_ARGS);
+extern Datum float8_regr_sxy (PG_FUNCTION_ARGS);
+extern Datum float8_regr_avgx (PG_FUNCTION_ARGS);
+extern Datum float8_regr_avgy (PG_FUNCTION_ARGS);
+extern Datum float8_regr_r2 (PG_FUNCTION_ARGS);
+extern Datum float8_regr_slope (PG_FUNCTION_ARGS);
+extern Datum float8_regr_intercept (PG_FUNCTION_ARGS);
+extern Datum float8_covar_pop (PG_FUNCTION_ARGS);
+extern Datum float8_covar_samp (PG_FUNCTION_ARGS);
+extern Datum float8_corr (PG_FUNCTION_ARGS);
+extern Datum pg_switch_xlog (PG_FUNCTION_ARGS);
+extern Datum pg_current_xlog_location (PG_FUNCTION_ARGS);
+extern Datum pg_xlogfile_name_offset (PG_FUNCTION_ARGS);
+extern Datum pg_xlogfile_name (PG_FUNCTION_ARGS);
+extern Datum pg_current_xlog_insert_location (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_waiting (PG_FUNCTION_ARGS);
+extern Datum pg_my_temp_schema (PG_FUNCTION_ARGS);
+extern Datum pg_is_other_temp_schema (PG_FUNCTION_ARGS);
+extern Datum pg_timezone_names (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_backend_xact_start (PG_FUNCTION_ARGS);
+extern Datum numeric_avg_accum (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_buf_alloc (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_live_tuples (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_dead_tuples (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_lock_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_lock_shared_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_try_advisory_lock_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_try_advisory_lock_shared_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_unlock_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_unlock_shared_int8 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_lock_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_lock_shared_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_try_advisory_lock_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_try_advisory_lock_shared_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_unlock_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_unlock_shared_int4 (PG_FUNCTION_ARGS);
+extern Datum pg_advisory_unlock_all (PG_FUNCTION_ARGS);
+extern Datum xml_in (PG_FUNCTION_ARGS);
+extern Datum xml_out (PG_FUNCTION_ARGS);
+extern Datum xmlcomment (PG_FUNCTION_ARGS);
+extern Datum texttoxml (PG_FUNCTION_ARGS);
+extern Datum xmlvalidate (PG_FUNCTION_ARGS);
+extern Datum xml_recv (PG_FUNCTION_ARGS);
+extern Datum xml_send (PG_FUNCTION_ARGS);
+extern Datum xmlconcat2 (PG_FUNCTION_ARGS);
+extern Datum varbittypmodin (PG_FUNCTION_ARGS);
+extern Datum intervaltypmodin (PG_FUNCTION_ARGS);
+extern Datum intervaltypmodout (PG_FUNCTION_ARGS);
+extern Datum timestamptypmodin (PG_FUNCTION_ARGS);
+extern Datum timestamptypmodout (PG_FUNCTION_ARGS);
+extern Datum timestamptztypmodin (PG_FUNCTION_ARGS);
+extern Datum timestamptztypmodout (PG_FUNCTION_ARGS);
+extern Datum timetypmodin (PG_FUNCTION_ARGS);
+extern Datum timetypmodout (PG_FUNCTION_ARGS);
+extern Datum timetztypmodin (PG_FUNCTION_ARGS);
+extern Datum timetztypmodout (PG_FUNCTION_ARGS);
+extern Datum bpchartypmodin (PG_FUNCTION_ARGS);
+extern Datum bpchartypmodout (PG_FUNCTION_ARGS);
+extern Datum varchartypmodin (PG_FUNCTION_ARGS);
+extern Datum varchartypmodout (PG_FUNCTION_ARGS);
+extern Datum numerictypmodin (PG_FUNCTION_ARGS);
+extern Datum numerictypmodout (PG_FUNCTION_ARGS);
+extern Datum bittypmodin (PG_FUNCTION_ARGS);
+extern Datum bittypmodout (PG_FUNCTION_ARGS);
+extern Datum varbittypmodout (PG_FUNCTION_ARGS);
+extern Datum xmltotext (PG_FUNCTION_ARGS);
+extern Datum table_to_xml (PG_FUNCTION_ARGS);
+extern Datum query_to_xml (PG_FUNCTION_ARGS);
+extern Datum cursor_to_xml (PG_FUNCTION_ARGS);
+extern Datum table_to_xmlschema (PG_FUNCTION_ARGS);
+extern Datum query_to_xmlschema (PG_FUNCTION_ARGS);
+extern Datum cursor_to_xmlschema (PG_FUNCTION_ARGS);
+extern Datum table_to_xml_and_xmlschema (PG_FUNCTION_ARGS);
+extern Datum query_to_xml_and_xmlschema (PG_FUNCTION_ARGS);
+extern Datum xpath (PG_FUNCTION_ARGS);
+extern Datum schema_to_xml (PG_FUNCTION_ARGS);
+extern Datum schema_to_xmlschema (PG_FUNCTION_ARGS);
+extern Datum schema_to_xml_and_xmlschema (PG_FUNCTION_ARGS);
+extern Datum database_to_xml (PG_FUNCTION_ARGS);
+extern Datum database_to_xmlschema (PG_FUNCTION_ARGS);
+extern Datum database_to_xml_and_xmlschema (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_in (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_out (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_recv (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_send (PG_FUNCTION_ARGS);
+extern Datum txid_current (PG_FUNCTION_ARGS);
+extern Datum txid_current_snapshot (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_xmin (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_xmax (PG_FUNCTION_ARGS);
+extern Datum txid_snapshot_xip (PG_FUNCTION_ARGS);
+extern Datum txid_visible_in_snapshot (PG_FUNCTION_ARGS);
+extern Datum uuid_in (PG_FUNCTION_ARGS);
+extern Datum uuid_out (PG_FUNCTION_ARGS);
+extern Datum uuid_lt (PG_FUNCTION_ARGS);
+extern Datum uuid_le (PG_FUNCTION_ARGS);
+extern Datum uuid_eq (PG_FUNCTION_ARGS);
+extern Datum uuid_ge (PG_FUNCTION_ARGS);
+extern Datum uuid_gt (PG_FUNCTION_ARGS);
+extern Datum uuid_ne (PG_FUNCTION_ARGS);
+extern Datum uuid_cmp (PG_FUNCTION_ARGS);
+extern Datum uuid_recv (PG_FUNCTION_ARGS);
+extern Datum uuid_send (PG_FUNCTION_ARGS);
+extern Datum uuid_hash (PG_FUNCTION_ARGS);
+extern Datum booltext (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_function_calls (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_function_time (PG_FUNCTION_ARGS);
+extern Datum pg_stat_get_function_self_time (PG_FUNCTION_ARGS);
+extern Datum record_eq (PG_FUNCTION_ARGS);
+extern Datum record_ne (PG_FUNCTION_ARGS);
+extern Datum record_lt (PG_FUNCTION_ARGS);
+extern Datum record_gt (PG_FUNCTION_ARGS);
+extern Datum record_le (PG_FUNCTION_ARGS);
+extern Datum record_ge (PG_FUNCTION_ARGS);
+extern Datum btrecordcmp (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_foreign_data_wrapper_privilege_id (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_server_privilege_id (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_name_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_name_attnum (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_id_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_id_attnum (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_name_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_name_attnum (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_id_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_id_attnum (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_name_attnum (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_column_privilege_id_attnum (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_name_name (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_name_id (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_id_name (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_id_id (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_name (PG_FUNCTION_ARGS);
+extern Datum has_any_column_privilege_id (PG_FUNCTION_ARGS);
+extern Datum window_row_number (PG_FUNCTION_ARGS);
+extern Datum window_rank (PG_FUNCTION_ARGS);
+extern Datum window_dense_rank (PG_FUNCTION_ARGS);
+extern Datum window_percent_rank (PG_FUNCTION_ARGS);
+extern Datum window_cume_dist (PG_FUNCTION_ARGS);
+extern Datum window_ntile (PG_FUNCTION_ARGS);
+extern Datum window_lag (PG_FUNCTION_ARGS);
+extern Datum window_lag_with_offset (PG_FUNCTION_ARGS);
+extern Datum window_lag_with_offset_and_default (PG_FUNCTION_ARGS);
+extern Datum window_lead (PG_FUNCTION_ARGS);
+extern Datum window_lead_with_offset (PG_FUNCTION_ARGS);
+extern Datum window_lead_with_offset_and_default (PG_FUNCTION_ARGS);
+extern Datum window_first_value (PG_FUNCTION_ARGS);
+extern Datum window_last_value (PG_FUNCTION_ARGS);
+extern Datum window_nth_value (PG_FUNCTION_ARGS);
+extern Datum anyenum_in (PG_FUNCTION_ARGS);
+extern Datum anyenum_out (PG_FUNCTION_ARGS);
+extern Datum enum_in (PG_FUNCTION_ARGS);
+extern Datum enum_out (PG_FUNCTION_ARGS);
+extern Datum enum_eq (PG_FUNCTION_ARGS);
+extern Datum enum_ne (PG_FUNCTION_ARGS);
+extern Datum enum_lt (PG_FUNCTION_ARGS);
+extern Datum enum_gt (PG_FUNCTION_ARGS);
+extern Datum enum_le (PG_FUNCTION_ARGS);
+extern Datum enum_ge (PG_FUNCTION_ARGS);
+extern Datum enum_cmp (PG_FUNCTION_ARGS);
+extern Datum hashenum (PG_FUNCTION_ARGS);
+extern Datum enum_smaller (PG_FUNCTION_ARGS);
+extern Datum enum_larger (PG_FUNCTION_ARGS);
+extern Datum enum_first (PG_FUNCTION_ARGS);
+extern Datum enum_last (PG_FUNCTION_ARGS);
+extern Datum enum_range_bounds (PG_FUNCTION_ARGS);
+extern Datum enum_range_all (PG_FUNCTION_ARGS);
+extern Datum enum_recv (PG_FUNCTION_ARGS);
+extern Datum enum_send (PG_FUNCTION_ARGS);
+extern Datum tsvectorin (PG_FUNCTION_ARGS);
+extern Datum tsvectorout (PG_FUNCTION_ARGS);
+extern Datum tsqueryin (PG_FUNCTION_ARGS);
+extern Datum tsqueryout (PG_FUNCTION_ARGS);
+extern Datum tsvector_lt (PG_FUNCTION_ARGS);
+extern Datum tsvector_le (PG_FUNCTION_ARGS);
+extern Datum tsvector_eq (PG_FUNCTION_ARGS);
+extern Datum tsvector_ne (PG_FUNCTION_ARGS);
+extern Datum tsvector_ge (PG_FUNCTION_ARGS);
+extern Datum tsvector_gt (PG_FUNCTION_ARGS);
+extern Datum tsvector_cmp (PG_FUNCTION_ARGS);
+extern Datum tsvector_strip (PG_FUNCTION_ARGS);
+extern Datum tsvector_setweight (PG_FUNCTION_ARGS);
+extern Datum tsvector_concat (PG_FUNCTION_ARGS);
+extern Datum ts_match_vq (PG_FUNCTION_ARGS);
+extern Datum ts_match_qv (PG_FUNCTION_ARGS);
+extern Datum tsvectorsend (PG_FUNCTION_ARGS);
+extern Datum tsvectorrecv (PG_FUNCTION_ARGS);
+extern Datum tsquerysend (PG_FUNCTION_ARGS);
+extern Datum tsqueryrecv (PG_FUNCTION_ARGS);
+extern Datum gtsvectorin (PG_FUNCTION_ARGS);
+extern Datum gtsvectorout (PG_FUNCTION_ARGS);
+extern Datum gtsvector_compress (PG_FUNCTION_ARGS);
+extern Datum gtsvector_decompress (PG_FUNCTION_ARGS);
+extern Datum gtsvector_picksplit (PG_FUNCTION_ARGS);
+extern Datum gtsvector_union (PG_FUNCTION_ARGS);
+extern Datum gtsvector_same (PG_FUNCTION_ARGS);
+extern Datum gtsvector_penalty (PG_FUNCTION_ARGS);
+extern Datum gtsvector_consistent (PG_FUNCTION_ARGS);
+extern Datum gin_extract_tsvector (PG_FUNCTION_ARGS);
+extern Datum gin_extract_tsquery (PG_FUNCTION_ARGS);
+extern Datum gin_tsquery_consistent (PG_FUNCTION_ARGS);
+extern Datum tsquery_lt (PG_FUNCTION_ARGS);
+extern Datum tsquery_le (PG_FUNCTION_ARGS);
+extern Datum tsquery_eq (PG_FUNCTION_ARGS);
+extern Datum tsquery_ne (PG_FUNCTION_ARGS);
+extern Datum tsquery_ge (PG_FUNCTION_ARGS);
+extern Datum tsquery_gt (PG_FUNCTION_ARGS);
+extern Datum tsquery_cmp (PG_FUNCTION_ARGS);
+extern Datum tsquery_and (PG_FUNCTION_ARGS);
+extern Datum tsquery_or (PG_FUNCTION_ARGS);
+extern Datum tsquery_not (PG_FUNCTION_ARGS);
+extern Datum tsquery_numnode (PG_FUNCTION_ARGS);
+extern Datum tsquerytree (PG_FUNCTION_ARGS);
+extern Datum tsquery_rewrite (PG_FUNCTION_ARGS);
+extern Datum tsquery_rewrite_query (PG_FUNCTION_ARGS);
+extern Datum tsmatchsel (PG_FUNCTION_ARGS);
+extern Datum tsmatchjoinsel (PG_FUNCTION_ARGS);
+extern Datum ts_typanalyze (PG_FUNCTION_ARGS);
+extern Datum ts_stat1 (PG_FUNCTION_ARGS);
+extern Datum ts_stat2 (PG_FUNCTION_ARGS);
+extern Datum tsq_mcontains (PG_FUNCTION_ARGS);
+extern Datum tsq_mcontained (PG_FUNCTION_ARGS);
+extern Datum gtsquery_compress (PG_FUNCTION_ARGS);
+extern Datum gtsquery_decompress (PG_FUNCTION_ARGS);
+extern Datum gtsquery_picksplit (PG_FUNCTION_ARGS);
+extern Datum gtsquery_union (PG_FUNCTION_ARGS);
+extern Datum gtsquery_same (PG_FUNCTION_ARGS);
+extern Datum gtsquery_penalty (PG_FUNCTION_ARGS);
+extern Datum gtsquery_consistent (PG_FUNCTION_ARGS);
+extern Datum ts_rank_wttf (PG_FUNCTION_ARGS);
+extern Datum ts_rank_wtt (PG_FUNCTION_ARGS);
+extern Datum ts_rank_ttf (PG_FUNCTION_ARGS);
+extern Datum ts_rank_tt (PG_FUNCTION_ARGS);
+extern Datum ts_rankcd_wttf (PG_FUNCTION_ARGS);
+extern Datum ts_rankcd_wtt (PG_FUNCTION_ARGS);
+extern Datum ts_rankcd_ttf (PG_FUNCTION_ARGS);
+extern Datum ts_rankcd_tt (PG_FUNCTION_ARGS);
+extern Datum tsvector_length (PG_FUNCTION_ARGS);
+extern Datum ts_token_type_byid (PG_FUNCTION_ARGS);
+extern Datum ts_token_type_byname (PG_FUNCTION_ARGS);
+extern Datum ts_parse_byid (PG_FUNCTION_ARGS);
+extern Datum ts_parse_byname (PG_FUNCTION_ARGS);
+extern Datum prsd_start (PG_FUNCTION_ARGS);
+extern Datum prsd_nexttoken (PG_FUNCTION_ARGS);
+extern Datum prsd_end (PG_FUNCTION_ARGS);
+extern Datum prsd_headline (PG_FUNCTION_ARGS);
+extern Datum prsd_lextype (PG_FUNCTION_ARGS);
+extern Datum ts_lexize (PG_FUNCTION_ARGS);
+extern Datum gin_cmp_tslexeme (PG_FUNCTION_ARGS);
+extern Datum dsimple_init (PG_FUNCTION_ARGS);
+extern Datum dsimple_lexize (PG_FUNCTION_ARGS);
+extern Datum dsynonym_init (PG_FUNCTION_ARGS);
+extern Datum dsynonym_lexize (PG_FUNCTION_ARGS);
+extern Datum dispell_init (PG_FUNCTION_ARGS);
+extern Datum dispell_lexize (PG_FUNCTION_ARGS);
+extern Datum regconfigin (PG_FUNCTION_ARGS);
+extern Datum regconfigout (PG_FUNCTION_ARGS);
+extern Datum regconfigrecv (PG_FUNCTION_ARGS);
+extern Datum regconfigsend (PG_FUNCTION_ARGS);
+extern Datum thesaurus_init (PG_FUNCTION_ARGS);
+extern Datum thesaurus_lexize (PG_FUNCTION_ARGS);
+extern Datum ts_headline_byid_opt (PG_FUNCTION_ARGS);
+extern Datum ts_headline_byid (PG_FUNCTION_ARGS);
+extern Datum to_tsvector_byid (PG_FUNCTION_ARGS);
+extern Datum to_tsquery_byid (PG_FUNCTION_ARGS);
+extern Datum plainto_tsquery_byid (PG_FUNCTION_ARGS);
+extern Datum to_tsvector (PG_FUNCTION_ARGS);
+extern Datum to_tsquery (PG_FUNCTION_ARGS);
+extern Datum plainto_tsquery (PG_FUNCTION_ARGS);
+extern Datum tsvector_update_trigger_byid (PG_FUNCTION_ARGS);
+extern Datum tsvector_update_trigger_bycolumn (PG_FUNCTION_ARGS);
+extern Datum ts_headline_opt (PG_FUNCTION_ARGS);
+extern Datum ts_headline (PG_FUNCTION_ARGS);
+extern Datum pg_ts_parser_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_ts_dict_is_visible (PG_FUNCTION_ARGS);
+extern Datum pg_ts_config_is_visible (PG_FUNCTION_ARGS);
+extern Datum get_current_ts_config (PG_FUNCTION_ARGS);
+extern Datum ts_match_tt (PG_FUNCTION_ARGS);
+extern Datum ts_match_tq (PG_FUNCTION_ARGS);
+extern Datum pg_ts_template_is_visible (PG_FUNCTION_ARGS);
+extern Datum regdictionaryin (PG_FUNCTION_ARGS);
+extern Datum regdictionaryout (PG_FUNCTION_ARGS);
+extern Datum regdictionaryrecv (PG_FUNCTION_ARGS);
+extern Datum regdictionarysend (PG_FUNCTION_ARGS);
+
+const FmgrBuiltin fmgr_builtins[] = {
+  { 31, "byteaout", 1, true, false, byteaout },
+  { 33, "charout", 1, true, false, charout },
+  { 34, "namein", 1, true, false, namein },
+  { 35, "nameout", 1, true, false, nameout },
+  { 38, "int2in", 1, true, false, int2in },
+  { 39, "int2out", 1, true, false, int2out },
+  { 40, "int2vectorin", 1, true, false, int2vectorin },
+  { 41, "int2vectorout", 1, true, false, int2vectorout },
+  { 42, "int4in", 1, true, false, int4in },
+  { 43, "int4out", 1, true, false, int4out },
+  { 44, "regprocin", 1, true, false, regprocin },
+  { 45, "regprocout", 1, true, false, regprocout },
+  { 46, "textin", 1, true, false, textin },
+  { 47, "textout", 1, true, false, textout },
+  { 48, "tidin", 1, true, false, tidin },
+  { 49, "tidout", 1, true, false, tidout },
+  { 50, "xidin", 1, true, false, xidin },
+  { 51, "xidout", 1, true, false, xidout },
+  { 52, "cidin", 1, true, false, cidin },
+  { 53, "cidout", 1, true, false, cidout },
+  { 54, "oidvectorin", 1, true, false, oidvectorin },
+  { 55, "oidvectorout", 1, true, false, oidvectorout },
+  { 56, "boollt", 2, true, false, boollt },
+  { 57, "boolgt", 2, true, false, boolgt },
+  { 60, "booleq", 2, true, false, booleq },
+  { 61, "chareq", 2, true, false, chareq },
+  { 62, "nameeq", 2, true, false, nameeq },
+  { 63, "int2eq", 2, true, false, int2eq },
+  { 64, "int2lt", 2, true, false, int2lt },
+  { 65, "int4eq", 2, true, false, int4eq },
+  { 66, "int4lt", 2, true, false, int4lt },
+  { 67, "texteq", 2, true, false, texteq },
+  { 68, "xideq", 2, true, false, xideq },
+  { 69, "cideq", 2, true, false, cideq },
+  { 70, "charne", 2, true, false, charne },
+  { 72, "charle", 2, true, false, charle },
+  { 73, "chargt", 2, true, false, chargt },
+  { 74, "charge", 2, true, false, charge },
+  { 77, "chartoi4", 1, true, false, chartoi4 },
+  { 78, "i4tochar", 1, true, false, i4tochar },
+  { 79, "nameregexeq", 2, true, false, nameregexeq },
+  { 84, "boolne", 2, true, false, boolne },
+  { 89, "pgsql_version", 0, true, false, pgsql_version },
+  { 101, "eqsel", 4, true, false, eqsel },
+  { 102, "neqsel", 4, true, false, neqsel },
+  { 103, "scalarltsel", 4, true, false, scalarltsel },
+  { 104, "scalargtsel", 4, true, false, scalargtsel },
+  { 105, "eqjoinsel", 5, true, false, eqjoinsel },
+  { 106, "neqjoinsel", 5, true, false, neqjoinsel },
+  { 107, "scalarltjoinsel", 5, true, false, scalarltjoinsel },
+  { 108, "scalargtjoinsel", 5, true, false, scalargtjoinsel },
+  { 109, "unknownin", 1, true, false, unknownin },
+  { 110, "unknownout", 1, true, false, unknownout },
+  { 111, "numeric_fac", 1, true, false, numeric_fac },
+  { 115, "box_above_eq", 2, true, false, box_above_eq },
+  { 116, "box_below_eq", 2, true, false, box_below_eq },
+  { 117, "point_in", 1, true, false, point_in },
+  { 118, "point_out", 1, true, false, point_out },
+  { 119, "lseg_in", 1, true, false, lseg_in },
+  { 120, "lseg_out", 1, true, false, lseg_out },
+  { 121, "path_in", 1, true, false, path_in },
+  { 122, "path_out", 1, true, false, path_out },
+  { 123, "box_in", 1, true, false, box_in },
+  { 124, "box_out", 1, true, false, box_out },
+  { 125, "box_overlap", 2, true, false, box_overlap },
+  { 126, "box_ge", 2, true, false, box_ge },
+  { 127, "box_gt", 2, true, false, box_gt },
+  { 128, "box_eq", 2, true, false, box_eq },
+  { 129, "box_lt", 2, true, false, box_lt },
+  { 130, "box_le", 2, true, false, box_le },
+  { 131, "point_above", 2, true, false, point_above },
+  { 132, "point_left", 2, true, false, point_left },
+  { 133, "point_right", 2, true, false, point_right },
+  { 134, "point_below", 2, true, false, point_below },
+  { 135, "point_eq", 2, true, false, point_eq },
+  { 136, "on_pb", 2, true, false, on_pb },
+  { 137, "on_ppath", 2, true, false, on_ppath },
+  { 138, "box_center", 1, true, false, box_center },
+  { 139, "areasel", 4, true, false, areasel },
+  { 140, "areajoinsel", 5, true, false, areajoinsel },
+  { 141, "int4mul", 2, true, false, int4mul },
+  { 144, "int4ne", 2, true, false, int4ne },
+  { 145, "int2ne", 2, true, false, int2ne },
+  { 146, "int2gt", 2, true, false, int2gt },
+  { 147, "int4gt", 2, true, false, int4gt },
+  { 148, "int2le", 2, true, false, int2le },
+  { 149, "int4le", 2, true, false, int4le },
+  { 150, "int4ge", 2, true, false, int4ge },
+  { 151, "int2ge", 2, true, false, int2ge },
+  { 152, "int2mul", 2, true, false, int2mul },
+  { 153, "int2div", 2, true, false, int2div },
+  { 154, "int4div", 2, true, false, int4div },
+  { 155, "int2mod", 2, true, false, int2mod },
+  { 156, "int4mod", 2, true, false, int4mod },
+  { 157, "textne", 2, true, false, textne },
+  { 158, "int24eq", 2, true, false, int24eq },
+  { 159, "int42eq", 2, true, false, int42eq },
+  { 160, "int24lt", 2, true, false, int24lt },
+  { 161, "int42lt", 2, true, false, int42lt },
+  { 162, "int24gt", 2, true, false, int24gt },
+  { 163, "int42gt", 2, true, false, int42gt },
+  { 164, "int24ne", 2, true, false, int24ne },
+  { 165, "int42ne", 2, true, false, int42ne },
+  { 166, "int24le", 2, true, false, int24le },
+  { 167, "int42le", 2, true, false, int42le },
+  { 168, "int24ge", 2, true, false, int24ge },
+  { 169, "int42ge", 2, true, false, int42ge },
+  { 170, "int24mul", 2, true, false, int24mul },
+  { 171, "int42mul", 2, true, false, int42mul },
+  { 172, "int24div", 2, true, false, int24div },
+  { 173, "int42div", 2, true, false, int42div },
+  { 176, "int2pl", 2, true, false, int2pl },
+  { 177, "int4pl", 2, true, false, int4pl },
+  { 178, "int24pl", 2, true, false, int24pl },
+  { 179, "int42pl", 2, true, false, int42pl },
+  { 180, "int2mi", 2, true, false, int2mi },
+  { 181, "int4mi", 2, true, false, int4mi },
+  { 182, "int24mi", 2, true, false, int24mi },
+  { 183, "int42mi", 2, true, false, int42mi },
+  { 184, "oideq", 2, true, false, oideq },
+  { 185, "oidne", 2, true, false, oidne },
+  { 186, "box_same", 2, true, false, box_same },
+  { 187, "box_contain", 2, true, false, box_contain },
+  { 188, "box_left", 2, true, false, box_left },
+  { 189, "box_overleft", 2, true, false, box_overleft },
+  { 190, "box_overright", 2, true, false, box_overright },
+  { 191, "box_right", 2, true, false, box_right },
+  { 192, "box_contained", 2, true, false, box_contained },
+  { 200, "float4in", 1, true, false, float4in },
+  { 201, "float4out", 1, true, false, float4out },
+  { 202, "float4mul", 2, true, false, float4mul },
+  { 203, "float4div", 2, true, false, float4div },
+  { 204, "float4pl", 2, true, false, float4pl },
+  { 205, "float4mi", 2, true, false, float4mi },
+  { 206, "float4um", 1, true, false, float4um },
+  { 207, "float4abs", 1, true, false, float4abs },
+  { 208, "float4_accum", 2, true, false, float4_accum },
+  { 209, "float4larger", 2, true, false, float4larger },
+  { 211, "float4smaller", 2, true, false, float4smaller },
+  { 212, "int4um", 1, true, false, int4um },
+  { 213, "int2um", 1, true, false, int2um },
+  { 214, "float8in", 1, true, false, float8in },
+  { 215, "float8out", 1, true, false, float8out },
+  { 216, "float8mul", 2, true, false, float8mul },
+  { 217, "float8div", 2, true, false, float8div },
+  { 218, "float8pl", 2, true, false, float8pl },
+  { 219, "float8mi", 2, true, false, float8mi },
+  { 220, "float8um", 1, true, false, float8um },
+  { 221, "float8abs", 1, true, false, float8abs },
+  { 222, "float8_accum", 2, true, false, float8_accum },
+  { 223, "float8larger", 2, true, false, float8larger },
+  { 224, "float8smaller", 2, true, false, float8smaller },
+  { 225, "lseg_center", 1, true, false, lseg_center },
+  { 226, "path_center", 1, true, false, path_center },
+  { 227, "poly_center", 1, true, false, poly_center },
+  { 228, "dround", 1, true, false, dround },
+  { 229, "dtrunc", 1, true, false, dtrunc },
+  { 230, "dsqrt", 1, true, false, dsqrt },
+  { 231, "dcbrt", 1, true, false, dcbrt },
+  { 232, "dpow", 2, true, false, dpow },
+  { 233, "dexp", 1, true, false, dexp },
+  { 234, "dlog1", 1, true, false, dlog1 },
+  { 235, "i2tod", 1, true, false, i2tod },
+  { 236, "i2tof", 1, true, false, i2tof },
+  { 237, "dtoi2", 1, true, false, dtoi2 },
+  { 238, "ftoi2", 1, true, false, ftoi2 },
+  { 239, "line_distance", 2, true, false, line_distance },
+  { 240, "abstimein", 1, true, false, abstimein },
+  { 241, "abstimeout", 1, true, false, abstimeout },
+  { 242, "reltimein", 1, true, false, reltimein },
+  { 243, "reltimeout", 1, true, false, reltimeout },
+  { 244, "timepl", 2, true, false, timepl },
+  { 245, "timemi", 2, true, false, timemi },
+  { 246, "tintervalin", 1, true, false, tintervalin },
+  { 247, "tintervalout", 1, true, false, tintervalout },
+  { 248, "intinterval", 2, true, false, intinterval },
+  { 249, "tintervalrel", 1, true, false, tintervalrel },
+  { 250, "timenow", 0, true, false, timenow },
+  { 251, "abstimeeq", 2, true, false, abstimeeq },
+  { 252, "abstimene", 2, true, false, abstimene },
+  { 253, "abstimelt", 2, true, false, abstimelt },
+  { 254, "abstimegt", 2, true, false, abstimegt },
+  { 255, "abstimele", 2, true, false, abstimele },
+  { 256, "abstimege", 2, true, false, abstimege },
+  { 257, "reltimeeq", 2, true, false, reltimeeq },
+  { 258, "reltimene", 2, true, false, reltimene },
+  { 259, "reltimelt", 2, true, false, reltimelt },
+  { 260, "reltimegt", 2, true, false, reltimegt },
+  { 261, "reltimele", 2, true, false, reltimele },
+  { 262, "reltimege", 2, true, false, reltimege },
+  { 263, "tintervalsame", 2, true, false, tintervalsame },
+  { 264, "tintervalct", 2, true, false, tintervalct },
+  { 265, "tintervalov", 2, true, false, tintervalov },
+  { 266, "tintervalleneq", 2, true, false, tintervalleneq },
+  { 267, "tintervallenne", 2, true, false, tintervallenne },
+  { 268, "tintervallenlt", 2, true, false, tintervallenlt },
+  { 269, "tintervallengt", 2, true, false, tintervallengt },
+  { 270, "tintervallenle", 2, true, false, tintervallenle },
+  { 271, "tintervallenge", 2, true, false, tintervallenge },
+  { 272, "tintervalstart", 1, true, false, tintervalstart },
+  { 273, "tintervalend", 1, true, false, tintervalend },
+  { 274, "timeofday", 0, true, false, timeofday },
+  { 275, "abstime_finite", 1, true, false, abstime_finite },
+  { 277, "inter_sl", 2, true, false, inter_sl },
+  { 278, "inter_lb", 2, true, false, inter_lb },
+  { 279, "float48mul", 2, true, false, float48mul },
+  { 280, "float48div", 2, true, false, float48div },
+  { 281, "float48pl", 2, true, false, float48pl },
+  { 282, "float48mi", 2, true, false, float48mi },
+  { 283, "float84mul", 2, true, false, float84mul },
+  { 284, "float84div", 2, true, false, float84div },
+  { 285, "float84pl", 2, true, false, float84pl },
+  { 286, "float84mi", 2, true, false, float84mi },
+  { 287, "float4eq", 2, true, false, float4eq },
+  { 288, "float4ne", 2, true, false, float4ne },
+  { 289, "float4lt", 2, true, false, float4lt },
+  { 290, "float4le", 2, true, false, float4le },
+  { 291, "float4gt", 2, true, false, float4gt },
+  { 292, "float4ge", 2, true, false, float4ge },
+  { 293, "float8eq", 2, true, false, float8eq },
+  { 294, "float8ne", 2, true, false, float8ne },
+  { 295, "float8lt", 2, true, false, float8lt },
+  { 296, "float8le", 2, true, false, float8le },
+  { 297, "float8gt", 2, true, false, float8gt },
+  { 298, "float8ge", 2, true, false, float8ge },
+  { 299, "float48eq", 2, true, false, float48eq },
+  { 300, "float48ne", 2, true, false, float48ne },
+  { 301, "float48lt", 2, true, false, float48lt },
+  { 302, "float48le", 2, true, false, float48le },
+  { 303, "float48gt", 2, true, false, float48gt },
+  { 304, "float48ge", 2, true, false, float48ge },
+  { 305, "float84eq", 2, true, false, float84eq },
+  { 306, "float84ne", 2, true, false, float84ne },
+  { 307, "float84lt", 2, true, false, float84lt },
+  { 308, "float84le", 2, true, false, float84le },
+  { 309, "float84gt", 2, true, false, float84gt },
+  { 310, "float84ge", 2, true, false, float84ge },
+  { 311, "ftod", 1, true, false, ftod },
+  { 312, "dtof", 1, true, false, dtof },
+  { 313, "i2toi4", 1, true, false, i2toi4 },
+  { 314, "i4toi2", 1, true, false, i4toi2 },
+  { 315, "int2vectoreq", 2, true, false, int2vectoreq },
+  { 316, "i4tod", 1, true, false, i4tod },
+  { 317, "dtoi4", 1, true, false, dtoi4 },
+  { 318, "i4tof", 1, true, false, i4tof },
+  { 319, "ftoi4", 1, true, false, ftoi4 },
+  { 320, "width_bucket_float8", 4, true, false, width_bucket_float8 },
+  { 329, "hash_aclitem", 1, true, false, hash_aclitem },
+  { 330, "btgettuple", 2, true, false, btgettuple },
+  { 331, "btinsert", 6, true, false, btinsert },
+  { 332, "btbulkdelete", 4, true, false, btbulkdelete },
+  { 333, "btbeginscan", 3, true, false, btbeginscan },
+  { 334, "btrescan", 2, true, false, btrescan },
+  { 335, "btendscan", 1, true, false, btendscan },
+  { 336, "btmarkpos", 1, true, false, btmarkpos },
+  { 337, "btrestrpos", 1, true, false, btrestrpos },
+  { 338, "btbuild", 3, true, false, btbuild },
+  { 339, "poly_same", 2, true, false, poly_same },
+  { 340, "poly_contain", 2, true, false, poly_contain },
+  { 341, "poly_left", 2, true, false, poly_left },
+  { 342, "poly_overleft", 2, true, false, poly_overleft },
+  { 343, "poly_overright", 2, true, false, poly_overright },
+  { 344, "poly_right", 2, true, false, poly_right },
+  { 345, "poly_contained", 2, true, false, poly_contained },
+  { 346, "poly_overlap", 2, true, false, poly_overlap },
+  { 347, "poly_in", 1, true, false, poly_in },
+  { 348, "poly_out", 1, true, false, poly_out },
+  { 350, "btint2cmp", 2, true, false, btint2cmp },
+  { 351, "btint4cmp", 2, true, false, btint4cmp },
+  { 354, "btfloat4cmp", 2, true, false, btfloat4cmp },
+  { 355, "btfloat8cmp", 2, true, false, btfloat8cmp },
+  { 356, "btoidcmp", 2, true, false, btoidcmp },
+  { 357, "btabstimecmp", 2, true, false, btabstimecmp },
+  { 358, "btcharcmp", 2, true, false, btcharcmp },
+  { 359, "btnamecmp", 2, true, false, btnamecmp },
+  { 360, "bttextcmp", 2, true, false, bttextcmp },
+  { 361, "lseg_distance", 2, true, false, lseg_distance },
+  { 362, "lseg_interpt", 2, true, false, lseg_interpt },
+  { 363, "dist_ps", 2, true, false, dist_ps },
+  { 364, "dist_pb", 2, true, false, dist_pb },
+  { 365, "dist_sb", 2, true, false, dist_sb },
+  { 366, "close_ps", 2, true, false, close_ps },
+  { 367, "close_pb", 2, true, false, close_pb },
+  { 368, "close_sb", 2, true, false, close_sb },
+  { 369, "on_ps", 2, true, false, on_ps },
+  { 370, "path_distance", 2, true, false, path_distance },
+  { 371, "dist_ppath", 2, true, false, dist_ppath },
+  { 372, "on_sb", 2, true, false, on_sb },
+  { 373, "inter_sb", 2, true, false, inter_sb },
+  { 377, "cash_cmp", 2, true, false, cash_cmp },
+  { 378, "array_push", 2, false, false, array_push },
+  { 379, "array_push", 2, false, false, array_push },
+  { 380, "btreltimecmp", 2, true, false, btreltimecmp },
+  { 381, "bttintervalcmp", 2, true, false, bttintervalcmp },
+  { 382, "btarraycmp", 2, true, false, btarraycmp },
+  { 383, "array_cat", 2, false, false, array_cat },
+  { 390, "array_ne", 2, true, false, array_ne },
+  { 391, "array_lt", 2, true, false, array_lt },
+  { 392, "array_gt", 2, true, false, array_gt },
+  { 393, "array_le", 2, true, false, array_le },
+  { 394, "text_to_array", 2, true, false, text_to_array },
+  { 395, "array_to_text", 2, true, false, array_to_text },
+  { 396, "array_ge", 2, true, false, array_ge },
+  { 398, "hashint2vector", 1, true, false, hashint2vector },
+  { 399, "hashmacaddr", 1, true, false, hashmacaddr },
+  { 400, "hashtext", 1, true, false, hashtext },
+  { 401, "rtrim1", 1, true, false, rtrim1 },
+  { 404, "btoidvectorcmp", 2, true, false, btoidvectorcmp },
+  { 406, "name_text", 1, true, false, name_text },
+  { 407, "text_name", 1, true, false, text_name },
+  { 408, "name_bpchar", 1, true, false, name_bpchar },
+  { 409, "bpchar_name", 1, true, false, bpchar_name },
+  { 422, "hashinet", 1, true, false, hashinet },
+  { 425, "hashvacuumcleanup", 2, true, false, hashvacuumcleanup },
+  { 432, "hash_numeric", 1, true, false, hash_numeric },
+  { 436, "macaddr_in", 1, true, false, macaddr_in },
+  { 437, "macaddr_out", 1, true, false, macaddr_out },
+  { 438, "hashcostestimate", 8, true, false, hashcostestimate },
+  { 440, "hashgettuple", 2, true, false, hashgettuple },
+  { 441, "hashinsert", 6, true, false, hashinsert },
+  { 442, "hashbulkdelete", 4, true, false, hashbulkdelete },
+  { 443, "hashbeginscan", 3, true, false, hashbeginscan },
+  { 444, "hashrescan", 2, true, false, hashrescan },
+  { 445, "hashendscan", 1, true, false, hashendscan },
+  { 446, "hashmarkpos", 1, true, false, hashmarkpos },
+  { 447, "hashrestrpos", 1, true, false, hashrestrpos },
+  { 448, "hashbuild", 3, true, false, hashbuild },
+  { 449, "hashint2", 1, true, false, hashint2 },
+  { 450, "hashint4", 1, true, false, hashint4 },
+  { 451, "hashfloat4", 1, true, false, hashfloat4 },
+  { 452, "hashfloat8", 1, true, false, hashfloat8 },
+  { 453, "hashoid", 1, true, false, hashoid },
+  { 454, "hashchar", 1, true, false, hashchar },
+  { 455, "hashname", 1, true, false, hashname },
+  { 456, "hashvarlena", 1, true, false, hashvarlena },
+  { 457, "hashoidvector", 1, true, false, hashoidvector },
+  { 458, "text_larger", 2, true, false, text_larger },
+  { 459, "text_smaller", 2, true, false, text_smaller },
+  { 460, "int8in", 1, true, false, int8in },
+  { 461, "int8out", 1, true, false, int8out },
+  { 462, "int8um", 1, true, false, int8um },
+  { 463, "int8pl", 2, true, false, int8pl },
+  { 464, "int8mi", 2, true, false, int8mi },
+  { 465, "int8mul", 2, true, false, int8mul },
+  { 466, "int8div", 2, true, false, int8div },
+  { 467, "int8eq", 2, true, false, int8eq },
+  { 468, "int8ne", 2, true, false, int8ne },
+  { 469, "int8lt", 2, true, false, int8lt },
+  { 470, "int8gt", 2, true, false, int8gt },
+  { 471, "int8le", 2, true, false, int8le },
+  { 472, "int8ge", 2, true, false, int8ge },
+  { 474, "int84eq", 2, true, false, int84eq },
+  { 475, "int84ne", 2, true, false, int84ne },
+  { 476, "int84lt", 2, true, false, int84lt },
+  { 477, "int84gt", 2, true, false, int84gt },
+  { 478, "int84le", 2, true, false, int84le },
+  { 479, "int84ge", 2, true, false, int84ge },
+  { 480, "int84", 1, true, false, int84 },
+  { 481, "int48", 1, true, false, int48 },
+  { 482, "i8tod", 1, true, false, i8tod },
+  { 483, "dtoi8", 1, true, false, dtoi8 },
+  { 515, "array_larger", 2, true, false, array_larger },
+  { 516, "array_smaller", 2, true, false, array_smaller },
+  { 598, "inet_abbrev", 1, true, false, inet_abbrev },
+  { 599, "cidr_abbrev", 1, true, false, cidr_abbrev },
+  { 605, "inet_set_masklen", 2, true, false, inet_set_masklen },
+  { 619, "oidvectorne", 2, true, false, oidvectorne },
+  { 635, "cidr_set_masklen", 2, true, false, cidr_set_masklen },
+  { 636, "btgetbitmap", 2, true, false, btgetbitmap },
+  { 637, "hashgetbitmap", 2, true, false, hashgetbitmap },
+  { 638, "gistgetbitmap", 2, true, false, gistgetbitmap },
+  { 652, "i8tof", 1, true, false, i8tof },
+  { 653, "ftoi8", 1, true, false, ftoi8 },
+  { 655, "namelt", 2, true, false, namelt },
+  { 656, "namele", 2, true, false, namele },
+  { 657, "namegt", 2, true, false, namegt },
+  { 658, "namege", 2, true, false, namege },
+  { 659, "namene", 2, true, false, namene },
+  { 668, "bpchar", 3, true, false, bpchar },
+  { 669, "varchar", 3, true, false, varchar },
+  { 676, "mktinterval", 2, true, false, mktinterval },
+  { 677, "oidvectorlt", 2, true, false, oidvectorlt },
+  { 678, "oidvectorle", 2, true, false, oidvectorle },
+  { 679, "oidvectoreq", 2, true, false, oidvectoreq },
+  { 680, "oidvectorge", 2, true, false, oidvectorge },
+  { 681, "oidvectorgt", 2, true, false, oidvectorgt },
+  { 683, "network_network", 1, true, false, network_network },
+  { 696, "network_netmask", 1, true, false, network_netmask },
+  { 697, "network_masklen", 1, true, false, network_masklen },
+  { 698, "network_broadcast", 1, true, false, network_broadcast },
+  { 699, "network_host", 1, true, false, network_host },
+  { 710, "current_user", 0, true, false, current_user },
+  { 711, "network_family", 1, true, false, network_family },
+  { 714, "int82", 1, true, false, int82 },
+  { 715, "lo_create", 1, true, false, lo_create },
+  { 716, "oidlt", 2, true, false, oidlt },
+  { 717, "oidle", 2, true, false, oidle },
+  { 720, "byteaoctetlen", 1, true, false, byteaoctetlen },
+  { 721, "byteaGetByte", 2, true, false, byteaGetByte },
+  { 722, "byteaSetByte", 3, true, false, byteaSetByte },
+  { 723, "byteaGetBit", 2, true, false, byteaGetBit },
+  { 724, "byteaSetBit", 3, true, false, byteaSetBit },
+  { 725, "dist_pl", 2, true, false, dist_pl },
+  { 726, "dist_lb", 2, true, false, dist_lb },
+  { 727, "dist_sl", 2, true, false, dist_sl },
+  { 728, "dist_cpoly", 2, true, false, dist_cpoly },
+  { 729, "poly_distance", 2, true, false, poly_distance },
+  { 730, "network_show", 1, true, false, network_show },
+  { 740, "text_lt", 2, true, false, text_lt },
+  { 741, "text_le", 2, true, false, text_le },
+  { 742, "text_gt", 2, true, false, text_gt },
+  { 743, "text_ge", 2, true, false, text_ge },
+  { 744, "array_eq", 2, true, false, array_eq },
+  { 745, "current_user", 0, true, false, current_user },
+  { 746, "session_user", 0, true, false, session_user },
+  { 747, "array_dims", 1, true, false, array_dims },
+  { 748, "array_ndims", 1, true, false, array_ndims },
+  { 750, "array_in", 3, true, false, array_in },
+  { 751, "array_out", 1, true, false, array_out },
+  { 753, "macaddr_trunc", 1, true, false, macaddr_trunc },
+  { 754, "int28", 1, true, false, int28 },
+  { 760, "smgrin", 1, true, false, smgrin },
+  { 761, "smgrout", 1, true, false, smgrout },
+  { 762, "smgreq", 2, true, false, smgreq },
+  { 763, "smgrne", 2, true, false, smgrne },
+  { 764, "lo_import", 1, true, false, lo_import },
+  { 765, "lo_export", 2, true, false, lo_export },
+  { 766, "int4inc", 1, true, false, int4inc },
+  { 767, "lo_import_with_oid", 2, true, false, lo_import_with_oid },
+  { 768, "int4larger", 2, true, false, int4larger },
+  { 769, "int4smaller", 2, true, false, int4smaller },
+  { 770, "int2larger", 2, true, false, int2larger },
+  { 771, "int2smaller", 2, true, false, int2smaller },
+  { 772, "gistcostestimate", 8, true, false, gistcostestimate },
+  { 774, "gistgettuple", 2, true, false, gistgettuple },
+  { 775, "gistinsert", 6, true, false, gistinsert },
+  { 776, "gistbulkdelete", 4, true, false, gistbulkdelete },
+  { 777, "gistbeginscan", 3, true, false, gistbeginscan },
+  { 778, "gistrescan", 2, true, false, gistrescan },
+  { 779, "gistendscan", 1, true, false, gistendscan },
+  { 780, "gistmarkpos", 1, true, false, gistmarkpos },
+  { 781, "gistrestrpos", 1, true, false, gistrestrpos },
+  { 782, "gistbuild", 3, true, false, gistbuild },
+  { 784, "tintervaleq", 2, true, false, tintervaleq },
+  { 785, "tintervalne", 2, true, false, tintervalne },
+  { 786, "tintervallt", 2, true, false, tintervallt },
+  { 787, "tintervalgt", 2, true, false, tintervalgt },
+  { 788, "tintervalle", 2, true, false, tintervalle },
+  { 789, "tintervalge", 2, true, false, tintervalge },
+  { 810, "pg_client_encoding", 0, true, false, pg_client_encoding },
+  { 817, "current_query", 0, false, false, current_query },
+  { 830, "macaddr_eq", 2, true, false, macaddr_eq },
+  { 831, "macaddr_lt", 2, true, false, macaddr_lt },
+  { 832, "macaddr_le", 2, true, false, macaddr_le },
+  { 833, "macaddr_gt", 2, true, false, macaddr_gt },
+  { 834, "macaddr_ge", 2, true, false, macaddr_ge },
+  { 835, "macaddr_ne", 2, true, false, macaddr_ne },
+  { 836, "macaddr_cmp", 2, true, false, macaddr_cmp },
+  { 837, "int82pl", 2, true, false, int82pl },
+  { 838, "int82mi", 2, true, false, int82mi },
+  { 839, "int82mul", 2, true, false, int82mul },
+  { 840, "int82div", 2, true, false, int82div },
+  { 841, "int28pl", 2, true, false, int28pl },
+  { 842, "btint8cmp", 2, true, false, btint8cmp },
+  { 846, "cash_mul_flt4", 2, true, false, cash_mul_flt4 },
+  { 847, "cash_div_flt4", 2, true, false, cash_div_flt4 },
+  { 848, "flt4_mul_cash", 2, true, false, flt4_mul_cash },
+  { 849, "textpos", 2, true, false, textpos },
+  { 850, "textlike", 2, true, false, textlike },
+  { 851, "textnlike", 2, true, false, textnlike },
+  { 852, "int48eq", 2, true, false, int48eq },
+  { 853, "int48ne", 2, true, false, int48ne },
+  { 854, "int48lt", 2, true, false, int48lt },
+  { 855, "int48gt", 2, true, false, int48gt },
+  { 856, "int48le", 2, true, false, int48le },
+  { 857, "int48ge", 2, true, false, int48ge },
+  { 858, "namelike", 2, true, false, namelike },
+  { 859, "namenlike", 2, true, false, namenlike },
+  { 860, "char_bpchar", 1, true, false, char_bpchar },
+  { 861, "current_database", 0, true, false, current_database },
+  { 862, "int4_mul_cash", 2, true, false, int4_mul_cash },
+  { 863, "int2_mul_cash", 2, true, false, int2_mul_cash },
+  { 864, "cash_mul_int4", 2, true, false, cash_mul_int4 },
+  { 865, "cash_div_int4", 2, true, false, cash_div_int4 },
+  { 866, "cash_mul_int2", 2, true, false, cash_mul_int2 },
+  { 867, "cash_div_int2", 2, true, false, cash_div_int2 },
+  { 868, "textpos", 2, true, false, textpos },
+  { 870, "lower", 1, true, false, lower },
+  { 871, "upper", 1, true, false, upper },
+  { 872, "initcap", 1, true, false, initcap },
+  { 873, "lpad", 3, true, false, lpad },
+  { 874, "rpad", 3, true, false, rpad },
+  { 875, "ltrim", 2, true, false, ltrim },
+  { 876, "rtrim", 2, true, false, rtrim },
+  { 877, "text_substr", 3, true, false, text_substr },
+  { 878, "translate", 3, true, false, translate },
+  { 881, "ltrim1", 1, true, false, ltrim1 },
+  { 882, "rtrim1", 1, true, false, rtrim1 },
+  { 883, "text_substr_no_len", 2, true, false, text_substr_no_len },
+  { 884, "btrim", 2, true, false, btrim },
+  { 885, "btrim1", 1, true, false, btrim1 },
+  { 886, "cash_in", 1, true, false, cash_in },
+  { 887, "cash_out", 1, true, false, cash_out },
+  { 888, "cash_eq", 2, true, false, cash_eq },
+  { 889, "cash_ne", 2, true, false, cash_ne },
+  { 890, "cash_lt", 2, true, false, cash_lt },
+  { 891, "cash_le", 2, true, false, cash_le },
+  { 892, "cash_gt", 2, true, false, cash_gt },
+  { 893, "cash_ge", 2, true, false, cash_ge },
+  { 894, "cash_pl", 2, true, false, cash_pl },
+  { 895, "cash_mi", 2, true, false, cash_mi },
+  { 896, "cash_mul_flt8", 2, true, false, cash_mul_flt8 },
+  { 897, "cash_div_flt8", 2, true, false, cash_div_flt8 },
+  { 898, "cashlarger", 2, true, false, cashlarger },
+  { 899, "cashsmaller", 2, true, false, cashsmaller },
+  { 910, "inet_in", 1, true, false, inet_in },
+  { 911, "inet_out", 1, true, false, inet_out },
+  { 919, "flt8_mul_cash", 2, true, false, flt8_mul_cash },
+  { 920, "network_eq", 2, true, false, network_eq },
+  { 921, "network_lt", 2, true, false, network_lt },
+  { 922, "network_le", 2, true, false, network_le },
+  { 923, "network_gt", 2, true, false, network_gt },
+  { 924, "network_ge", 2, true, false, network_ge },
+  { 925, "network_ne", 2, true, false, network_ne },
+  { 926, "network_cmp", 2, true, false, network_cmp },
+  { 927, "network_sub", 2, true, false, network_sub },
+  { 928, "network_subeq", 2, true, false, network_subeq },
+  { 929, "network_sup", 2, true, false, network_sup },
+  { 930, "network_supeq", 2, true, false, network_supeq },
+  { 935, "cash_words", 1, true, false, cash_words },
+  { 936, "text_substr", 3, true, false, text_substr },
+  { 937, "text_substr_no_len", 2, true, false, text_substr_no_len },
+  { 938, "generate_series_timestamp", 3, true, true, generate_series_timestamp },
+  { 939, "generate_series_timestamptz", 3, true, true, generate_series_timestamptz },
+  { 940, "int2mod", 2, true, false, int2mod },
+  { 941, "int4mod", 2, true, false, int4mod },
+  { 942, "int28mi", 2, true, false, int28mi },
+  { 943, "int28mul", 2, true, false, int28mul },
+  { 944, "text_char", 1, true, false, text_char },
+  { 945, "int8mod", 2, true, false, int8mod },
+  { 946, "char_text", 1, true, false, char_text },
+  { 947, "int8mod", 2, true, false, int8mod },
+  { 948, "int28div", 2, true, false, int28div },
+  { 949, "hashint8", 1, true, false, hashint8 },
+  { 952, "lo_open", 2, true, false, lo_open },
+  { 953, "lo_close", 1, true, false, lo_close },
+  { 954, "loread", 2, true, false, loread },
+  { 955, "lowrite", 2, true, false, lowrite },
+  { 956, "lo_lseek", 3, true, false, lo_lseek },
+  { 957, "lo_creat", 1, true, false, lo_creat },
+  { 958, "lo_tell", 1, true, false, lo_tell },
+  { 959, "on_pl", 2, true, false, on_pl },
+  { 960, "on_sl", 2, true, false, on_sl },
+  { 961, "close_pl", 2, true, false, close_pl },
+  { 962, "close_sl", 2, true, false, close_sl },
+  { 963, "close_lb", 2, true, false, close_lb },
+  { 964, "lo_unlink", 1, true, false, lo_unlink },
+  { 972, "btvacuumcleanup", 2, true, false, btvacuumcleanup },
+  { 973, "path_inter", 2, true, false, path_inter },
+  { 975, "box_area", 1, true, false, box_area },
+  { 976, "box_width", 1, true, false, box_width },
+  { 977, "box_height", 1, true, false, box_height },
+  { 978, "box_distance", 2, true, false, box_distance },
+  { 979, "path_area", 1, true, false, path_area },
+  { 980, "box_intersect", 2, true, false, box_intersect },
+  { 981, "box_diagonal", 1, true, false, box_diagonal },
+  { 982, "path_n_lt", 2, true, false, path_n_lt },
+  { 983, "path_n_gt", 2, true, false, path_n_gt },
+  { 984, "path_n_eq", 2, true, false, path_n_eq },
+  { 985, "path_n_le", 2, true, false, path_n_le },
+  { 986, "path_n_ge", 2, true, false, path_n_ge },
+  { 987, "path_length", 1, true, false, path_length },
+  { 988, "point_ne", 2, true, false, point_ne },
+  { 989, "point_vert", 2, true, false, point_vert },
+  { 990, "point_horiz", 2, true, false, point_horiz },
+  { 991, "point_distance", 2, true, false, point_distance },
+  { 992, "point_slope", 2, true, false, point_slope },
+  { 993, "lseg_construct", 2, true, false, lseg_construct },
+  { 994, "lseg_intersect", 2, true, false, lseg_intersect },
+  { 995, "lseg_parallel", 2, true, false, lseg_parallel },
+  { 996, "lseg_perp", 2, true, false, lseg_perp },
+  { 997, "lseg_vertical", 1, true, false, lseg_vertical },
+  { 998, "lseg_horizontal", 1, true, false, lseg_horizontal },
+  { 999, "lseg_eq", 2, true, false, lseg_eq },
+  { 1004, "lo_truncate", 2, true, false, lo_truncate },
+  { 1026, "timestamptz_izone", 2, true, false, timestamptz_izone },
+  { 1031, "aclitemin", 1, true, false, aclitemin },
+  { 1032, "aclitemout", 1, true, false, aclitemout },
+  { 1035, "aclinsert", 2, true, false, aclinsert },
+  { 1036, "aclremove", 2, true, false, aclremove },
+  { 1037, "aclcontains", 2, true, false, aclcontains },
+  { 1039, "getdatabaseencoding", 0, true, false, getdatabaseencoding },
+  { 1044, "bpcharin", 3, true, false, bpcharin },
+  { 1045, "bpcharout", 1, true, false, bpcharout },
+  { 1046, "varcharin", 3, true, false, varcharin },
+  { 1047, "varcharout", 1, true, false, varcharout },
+  { 1048, "bpchareq", 2, true, false, bpchareq },
+  { 1049, "bpcharlt", 2, true, false, bpcharlt },
+  { 1050, "bpcharle", 2, true, false, bpcharle },
+  { 1051, "bpchargt", 2, true, false, bpchargt },
+  { 1052, "bpcharge", 2, true, false, bpcharge },
+  { 1053, "bpcharne", 2, true, false, bpcharne },
+  { 1062, "aclitem_eq", 2, true, false, aclitem_eq },
+  { 1063, "bpchar_larger", 2, true, false, bpchar_larger },
+  { 1064, "bpchar_smaller", 2, true, false, bpchar_smaller },
+  { 1065, "pg_prepared_xact", 0, true, true, pg_prepared_xact },
+  { 1066, "generate_series_step_int4", 3, true, true, generate_series_step_int4 },
+  { 1067, "generate_series_int4", 2, true, true, generate_series_int4 },
+  { 1068, "generate_series_step_int8", 3, true, true, generate_series_step_int8 },
+  { 1069, "generate_series_int8", 2, true, true, generate_series_int8 },
+  { 1078, "bpcharcmp", 2, true, false, bpcharcmp },
+  { 1079, "text_regclass", 1, true, false, text_regclass },
+  { 1080, "hashbpchar", 1, true, false, hashbpchar },
+  { 1081, "format_type", 2, false, false, format_type },
+  { 1084, "date_in", 1, true, false, date_in },
+  { 1085, "date_out", 1, true, false, date_out },
+  { 1086, "date_eq", 2, true, false, date_eq },
+  { 1087, "date_lt", 2, true, false, date_lt },
+  { 1088, "date_le", 2, true, false, date_le },
+  { 1089, "date_gt", 2, true, false, date_gt },
+  { 1090, "date_ge", 2, true, false, date_ge },
+  { 1091, "date_ne", 2, true, false, date_ne },
+  { 1092, "date_cmp", 2, true, false, date_cmp },
+  { 1102, "time_lt", 2, true, false, time_lt },
+  { 1103, "time_le", 2, true, false, time_le },
+  { 1104, "time_gt", 2, true, false, time_gt },
+  { 1105, "time_ge", 2, true, false, time_ge },
+  { 1106, "time_ne", 2, true, false, time_ne },
+  { 1107, "time_cmp", 2, true, false, time_cmp },
+  { 1138, "date_larger", 2, true, false, date_larger },
+  { 1139, "date_smaller", 2, true, false, date_smaller },
+  { 1140, "date_mi", 2, true, false, date_mi },
+  { 1141, "date_pli", 2, true, false, date_pli },
+  { 1142, "date_mii", 2, true, false, date_mii },
+  { 1143, "time_in", 3, true, false, time_in },
+  { 1144, "time_out", 1, true, false, time_out },
+  { 1145, "time_eq", 2, true, false, time_eq },
+  { 1146, "circle_add_pt", 2, true, false, circle_add_pt },
+  { 1147, "circle_sub_pt", 2, true, false, circle_sub_pt },
+  { 1148, "circle_mul_pt", 2, true, false, circle_mul_pt },
+  { 1149, "circle_div_pt", 2, true, false, circle_div_pt },
+  { 1150, "timestamptz_in", 3, true, false, timestamptz_in },
+  { 1151, "timestamptz_out", 1, true, false, timestamptz_out },
+  { 1152, "timestamp_eq", 2, true, false, timestamp_eq },
+  { 1153, "timestamp_ne", 2, true, false, timestamp_ne },
+  { 1154, "timestamp_lt", 2, true, false, timestamp_lt },
+  { 1155, "timestamp_le", 2, true, false, timestamp_le },
+  { 1156, "timestamp_ge", 2, true, false, timestamp_ge },
+  { 1157, "timestamp_gt", 2, true, false, timestamp_gt },
+  { 1159, "timestamptz_zone", 2, true, false, timestamptz_zone },
+  { 1160, "interval_in", 3, true, false, interval_in },
+  { 1161, "interval_out", 1, true, false, interval_out },
+  { 1162, "interval_eq", 2, true, false, interval_eq },
+  { 1163, "interval_ne", 2, true, false, interval_ne },
+  { 1164, "interval_lt", 2, true, false, interval_lt },
+  { 1165, "interval_le", 2, true, false, interval_le },
+  { 1166, "interval_ge", 2, true, false, interval_ge },
+  { 1167, "interval_gt", 2, true, false, interval_gt },
+  { 1168, "interval_um", 1, true, false, interval_um },
+  { 1169, "interval_pl", 2, true, false, interval_pl },
+  { 1170, "interval_mi", 2, true, false, interval_mi },
+  { 1171, "timestamptz_part", 2, true, false, timestamptz_part },
+  { 1172, "interval_part", 2, true, false, interval_part },
+  { 1173, "abstime_timestamptz", 1, true, false, abstime_timestamptz },
+  { 1174, "date_timestamptz", 1, true, false, date_timestamptz },
+  { 1175, "interval_justify_hours", 1, true, false, interval_justify_hours },
+  { 1177, "reltime_interval", 1, true, false, reltime_interval },
+  { 1178, "timestamptz_date", 1, true, false, timestamptz_date },
+  { 1179, "abstime_date", 1, true, false, abstime_date },
+  { 1180, "timestamptz_abstime", 1, true, false, timestamptz_abstime },
+  { 1181, "xid_age", 1, true, false, xid_age },
+  { 1188, "timestamp_mi", 2, true, false, timestamp_mi },
+  { 1189, "timestamptz_pl_interval", 2, true, false, timestamptz_pl_interval },
+  { 1190, "timestamptz_mi_interval", 2, true, false, timestamptz_mi_interval },
+  { 1191, "generate_subscripts", 3, true, true, generate_subscripts },
+  { 1192, "generate_subscripts_nodir", 2, true, true, generate_subscripts_nodir },
+  { 1193, "array_fill", 2, false, false, array_fill },
+  { 1194, "interval_reltime", 1, true, false, interval_reltime },
+  { 1195, "timestamp_smaller", 2, true, false, timestamp_smaller },
+  { 1196, "timestamp_larger", 2, true, false, timestamp_larger },
+  { 1197, "interval_smaller", 2, true, false, interval_smaller },
+  { 1198, "interval_larger", 2, true, false, interval_larger },
+  { 1199, "timestamptz_age", 2, true, false, timestamptz_age },
+  { 1200, "interval_scale", 2, true, false, interval_scale },
+  { 1217, "timestamptz_trunc", 2, true, false, timestamptz_trunc },
+  { 1218, "interval_trunc", 2, true, false, interval_trunc },
+  { 1219, "int8inc", 1, true, false, int8inc },
+  { 1230, "int8abs", 1, true, false, int8abs },
+  { 1236, "int8larger", 2, true, false, int8larger },
+  { 1237, "int8smaller", 2, true, false, int8smaller },
+  { 1238, "texticregexeq", 2, true, false, texticregexeq },
+  { 1239, "texticregexne", 2, true, false, texticregexne },
+  { 1240, "nameicregexeq", 2, true, false, nameicregexeq },
+  { 1241, "nameicregexne", 2, true, false, nameicregexne },
+  { 1242, "boolin", 1, true, false, boolin },
+  { 1243, "boolout", 1, true, false, boolout },
+  { 1244, "byteain", 1, true, false, byteain },
+  { 1245, "charin", 1, true, false, charin },
+  { 1246, "charlt", 2, true, false, charlt },
+  { 1251, "int4abs", 1, true, false, int4abs },
+  { 1252, "nameregexne", 2, true, false, nameregexne },
+  { 1253, "int2abs", 1, true, false, int2abs },
+  { 1254, "textregexeq", 2, true, false, textregexeq },
+  { 1256, "textregexne", 2, true, false, textregexne },
+  { 1257, "textlen", 1, true, false, textlen },
+  { 1258, "textcat", 2, true, false, textcat },
+  { 1264, "PG_char_to_encoding", 1, true, false, PG_char_to_encoding },
+  { 1265, "tidne", 2, true, false, tidne },
+  { 1267, "cidr_in", 1, true, false, cidr_in },
+  { 1268, "btcostestimate", 8, true, false, btcostestimate },
+  { 1269, "pg_column_size", 1, true, false, pg_column_size },
+  { 1271, "overlaps_timetz", 4, false, false, overlaps_timetz },
+  { 1272, "datetime_timestamp", 2, true, false, datetime_timestamp },
+  { 1273, "timetz_part", 2, true, false, timetz_part },
+  { 1274, "int84pl", 2, true, false, int84pl },
+  { 1275, "int84mi", 2, true, false, int84mi },
+  { 1276, "int84mul", 2, true, false, int84mul },
+  { 1277, "int84div", 2, true, false, int84div },
+  { 1278, "int48pl", 2, true, false, int48pl },
+  { 1279, "int48mi", 2, true, false, int48mi },
+  { 1280, "int48mul", 2, true, false, int48mul },
+  { 1281, "int48div", 2, true, false, int48div },
+  { 1282, "quote_ident", 1, true, false, quote_ident },
+  { 1283, "quote_literal", 1, true, false, quote_literal },
+  { 1286, "array_fill_with_lower_bounds", 3, false, false, array_fill_with_lower_bounds },
+  { 1287, "i8tooid", 1, true, false, i8tooid },
+  { 1288, "oidtoi8", 1, true, false, oidtoi8 },
+  { 1289, "quote_nullable", 1, false, false, quote_nullable },
+  { 1291, "suppress_redundant_updates_trigger", 0, true, false, suppress_redundant_updates_trigger },
+  { 1292, "tideq", 2, true, false, tideq },
+  { 1293, "currtid_byreloid", 2, true, false, currtid_byreloid },
+  { 1294, "currtid_byrelname", 2, true, false, currtid_byrelname },
+  { 1295, "interval_justify_days", 1, true, false, interval_justify_days },
+  { 1297, "datetimetz_timestamptz", 2, true, false, datetimetz_timestamptz },
+  { 1299, "now", 0, true, false, now },
+  { 1300, "positionsel", 4, true, false, positionsel },
+  { 1301, "positionjoinsel", 5, true, false, positionjoinsel },
+  { 1302, "contsel", 4, true, false, contsel },
+  { 1303, "contjoinsel", 5, true, false, contjoinsel },
+  { 1304, "overlaps_timestamp", 4, false, false, overlaps_timestamp },
+  { 1308, "overlaps_time", 4, false, false, overlaps_time },
+  { 1312, "timestamp_in", 3, true, false, timestamp_in },
+  { 1313, "timestamp_out", 1, true, false, timestamp_out },
+  { 1314, "timestamp_cmp", 2, true, false, timestamp_cmp },
+  { 1315, "interval_cmp", 2, true, false, interval_cmp },
+  { 1316, "timestamp_time", 1, true, false, timestamp_time },
+  { 1317, "textlen", 1, true, false, textlen },
+  { 1318, "bpcharlen", 1, true, false, bpcharlen },
+  { 1319, "xideq", 2, true, false, xideq },
+  { 1326, "interval_div", 2, true, false, interval_div },
+  { 1339, "dlog10", 1, true, false, dlog10 },
+  { 1340, "dlog10", 1, true, false, dlog10 },
+  { 1341, "dlog1", 1, true, false, dlog1 },
+  { 1342, "dround", 1, true, false, dround },
+  { 1343, "dtrunc", 1, true, false, dtrunc },
+  { 1344, "dsqrt", 1, true, false, dsqrt },
+  { 1345, "dcbrt", 1, true, false, dcbrt },
+  { 1346, "dpow", 2, true, false, dpow },
+  { 1347, "dexp", 1, true, false, dexp },
+  { 1349, "oidvectortypes", 1, true, false, oidvectortypes },
+  { 1350, "timetz_in", 3, true, false, timetz_in },
+  { 1351, "timetz_out", 1, true, false, timetz_out },
+  { 1352, "timetz_eq", 2, true, false, timetz_eq },
+  { 1353, "timetz_ne", 2, true, false, timetz_ne },
+  { 1354, "timetz_lt", 2, true, false, timetz_lt },
+  { 1355, "timetz_le", 2, true, false, timetz_le },
+  { 1356, "timetz_ge", 2, true, false, timetz_ge },
+  { 1357, "timetz_gt", 2, true, false, timetz_gt },
+  { 1358, "timetz_cmp", 2, true, false, timetz_cmp },
+  { 1359, "datetimetz_timestamptz", 2, true, false, datetimetz_timestamptz },
+  { 1362, "network_hostmask", 1, true, false, network_hostmask },
+  { 1365, "makeaclitem", 4, true, false, makeaclitem },
+  { 1367, "bpcharlen", 1, true, false, bpcharlen },
+  { 1368, "dpow", 2, true, false, dpow },
+  { 1369, "textlen", 1, true, false, textlen },
+  { 1370, "time_interval", 1, true, false, time_interval },
+  { 1371, "pg_lock_status", 0, true, true, pg_lock_status },
+  { 1372, "bpcharlen", 1, true, false, bpcharlen },
+  { 1373, "date_finite", 1, true, false, date_finite },
+  { 1374, "textoctetlen", 1, true, false, textoctetlen },
+  { 1375, "bpcharoctetlen", 1, true, false, bpcharoctetlen },
+  { 1376, "numeric_fac", 1, true, false, numeric_fac },
+  { 1377, "time_larger", 2, true, false, time_larger },
+  { 1378, "time_smaller", 2, true, false, time_smaller },
+  { 1379, "timetz_larger", 2, true, false, timetz_larger },
+  { 1380, "timetz_smaller", 2, true, false, timetz_smaller },
+  { 1381, "textlen", 1, true, false, textlen },
+  { 1385, "time_part", 2, true, false, time_part },
+  { 1387, "pg_get_constraintdef", 1, true, false, pg_get_constraintdef },
+  { 1388, "timestamptz_timetz", 1, true, false, timestamptz_timetz },
+  { 1389, "timestamp_finite", 1, true, false, timestamp_finite },
+  { 1390, "interval_finite", 1, true, false, interval_finite },
+  { 1391, "pg_stat_get_backend_start", 1, true, false, pg_stat_get_backend_start },
+  { 1392, "pg_stat_get_backend_client_addr", 1, true, false, pg_stat_get_backend_client_addr },
+  { 1393, "pg_stat_get_backend_client_port", 1, true, false, pg_stat_get_backend_client_port },
+  { 1394, "float4abs", 1, true, false, float4abs },
+  { 1395, "float8abs", 1, true, false, float8abs },
+  { 1396, "int8abs", 1, true, false, int8abs },
+  { 1397, "int4abs", 1, true, false, int4abs },
+  { 1398, "int2abs", 1, true, false, int2abs },
+  { 1400, "text_name", 1, true, false, text_name },
+  { 1401, "name_text", 1, true, false, name_text },
+  { 1402, "current_schema", 0, true, false, current_schema },
+  { 1403, "current_schemas", 1, true, false, current_schemas },
+  { 1406, "point_vert", 2, true, false, point_vert },
+  { 1407, "point_horiz", 2, true, false, point_horiz },
+  { 1408, "lseg_parallel", 2, true, false, lseg_parallel },
+  { 1409, "lseg_perp", 2, true, false, lseg_perp },
+  { 1410, "lseg_vertical", 1, true, false, lseg_vertical },
+  { 1411, "lseg_horizontal", 1, true, false, lseg_horizontal },
+  { 1412, "line_parallel", 2, true, false, line_parallel },
+  { 1413, "line_perp", 2, true, false, line_perp },
+  { 1414, "line_vertical", 1, true, false, line_vertical },
+  { 1415, "line_horizontal", 1, true, false, line_horizontal },
+  { 1416, "circle_center", 1, true, false, circle_center },
+  { 1419, "interval_time", 1, true, false, interval_time },
+  { 1421, "points_box", 2, true, false, points_box },
+  { 1422, "box_add", 2, true, false, box_add },
+  { 1423, "box_sub", 2, true, false, box_sub },
+  { 1424, "box_mul", 2, true, false, box_mul },
+  { 1425, "box_div", 2, true, false, box_div },
+  { 1427, "cidr_out", 1, true, false, cidr_out },
+  { 1428, "poly_contain_pt", 2, true, false, poly_contain_pt },
+  { 1429, "pt_contained_poly", 2, true, false, pt_contained_poly },
+  { 1430, "path_isclosed", 1, true, false, path_isclosed },
+  { 1431, "path_isopen", 1, true, false, path_isopen },
+  { 1432, "path_npoints", 1, true, false, path_npoints },
+  { 1433, "path_close", 1, true, false, path_close },
+  { 1434, "path_open", 1, true, false, path_open },
+  { 1435, "path_add", 2, true, false, path_add },
+  { 1436, "path_add_pt", 2, true, false, path_add_pt },
+  { 1437, "path_sub_pt", 2, true, false, path_sub_pt },
+  { 1438, "path_mul_pt", 2, true, false, path_mul_pt },
+  { 1439, "path_div_pt", 2, true, false, path_div_pt },
+  { 1440, "construct_point", 2, true, false, construct_point },
+  { 1441, "point_add", 2, true, false, point_add },
+  { 1442, "point_sub", 2, true, false, point_sub },
+  { 1443, "point_mul", 2, true, false, point_mul },
+  { 1444, "point_div", 2, true, false, point_div },
+  { 1445, "poly_npoints", 1, true, false, poly_npoints },
+  { 1446, "poly_box", 1, true, false, poly_box },
+  { 1447, "poly_path", 1, true, false, poly_path },
+  { 1448, "box_poly", 1, true, false, box_poly },
+  { 1449, "path_poly", 1, true, false, path_poly },
+  { 1450, "circle_in", 1, true, false, circle_in },
+  { 1451, "circle_out", 1, true, false, circle_out },
+  { 1452, "circle_same", 2, true, false, circle_same },
+  { 1453, "circle_contain", 2, true, false, circle_contain },
+  { 1454, "circle_left", 2, true, false, circle_left },
+  { 1455, "circle_overleft", 2, true, false, circle_overleft },
+  { 1456, "circle_overright", 2, true, false, circle_overright },
+  { 1457, "circle_right", 2, true, false, circle_right },
+  { 1458, "circle_contained", 2, true, false, circle_contained },
+  { 1459, "circle_overlap", 2, true, false, circle_overlap },
+  { 1460, "circle_below", 2, true, false, circle_below },
+  { 1461, "circle_above", 2, true, false, circle_above },
+  { 1462, "circle_eq", 2, true, false, circle_eq },
+  { 1463, "circle_ne", 2, true, false, circle_ne },
+  { 1464, "circle_lt", 2, true, false, circle_lt },
+  { 1465, "circle_gt", 2, true, false, circle_gt },
+  { 1466, "circle_le", 2, true, false, circle_le },
+  { 1467, "circle_ge", 2, true, false, circle_ge },
+  { 1468, "circle_area", 1, true, false, circle_area },
+  { 1469, "circle_diameter", 1, true, false, circle_diameter },
+  { 1470, "circle_radius", 1, true, false, circle_radius },
+  { 1471, "circle_distance", 2, true, false, circle_distance },
+  { 1472, "circle_center", 1, true, false, circle_center },
+  { 1473, "cr_circle", 2, true, false, cr_circle },
+  { 1474, "poly_circle", 1, true, false, poly_circle },
+  { 1475, "circle_poly", 2, true, false, circle_poly },
+  { 1476, "dist_pc", 2, true, false, dist_pc },
+  { 1477, "circle_contain_pt", 2, true, false, circle_contain_pt },
+  { 1478, "pt_contained_circle", 2, true, false, pt_contained_circle },
+  { 1479, "box_circle", 1, true, false, box_circle },
+  { 1480, "circle_box", 1, true, false, circle_box },
+  { 1481, "mktinterval", 2, true, false, mktinterval },
+  { 1482, "lseg_ne", 2, true, false, lseg_ne },
+  { 1483, "lseg_lt", 2, true, false, lseg_lt },
+  { 1484, "lseg_le", 2, true, false, lseg_le },
+  { 1485, "lseg_gt", 2, true, false, lseg_gt },
+  { 1486, "lseg_ge", 2, true, false, lseg_ge },
+  { 1487, "lseg_length", 1, true, false, lseg_length },
+  { 1488, "close_ls", 2, true, false, close_ls },
+  { 1489, "close_lseg", 2, true, false, close_lseg },
+  { 1490, "line_in", 1, true, false, line_in },
+  { 1491, "line_out", 1, true, false, line_out },
+  { 1492, "line_eq", 2, true, false, line_eq },
+  { 1493, "line_construct_pp", 2, true, false, line_construct_pp },
+  { 1494, "line_interpt", 2, true, false, line_interpt },
+  { 1495, "line_intersect", 2, true, false, line_intersect },
+  { 1496, "line_parallel", 2, true, false, line_parallel },
+  { 1497, "line_perp", 2, true, false, line_perp },
+  { 1498, "line_vertical", 1, true, false, line_vertical },
+  { 1499, "line_horizontal", 1, true, false, line_horizontal },
+  { 1530, "lseg_length", 1, true, false, lseg_length },
+  { 1531, "path_length", 1, true, false, path_length },
+  { 1532, "lseg_center", 1, true, false, lseg_center },
+  { 1533, "path_center", 1, true, false, path_center },
+  { 1534, "box_center", 1, true, false, box_center },
+  { 1540, "poly_center", 1, true, false, poly_center },
+  { 1541, "box_diagonal", 1, true, false, box_diagonal },
+  { 1542, "box_center", 1, true, false, box_center },
+  { 1543, "circle_center", 1, true, false, circle_center },
+  { 1545, "path_npoints", 1, true, false, path_npoints },
+  { 1556, "poly_npoints", 1, true, false, poly_npoints },
+  { 1564, "bit_in", 3, true, false, bit_in },
+  { 1565, "bit_out", 1, true, false, bit_out },
+  { 1569, "textlike", 2, true, false, textlike },
+  { 1570, "textnlike", 2, true, false, textnlike },
+  { 1571, "namelike", 2, true, false, namelike },
+  { 1572, "namenlike", 2, true, false, namenlike },
+  { 1573, "pg_get_ruledef", 1, true, false, pg_get_ruledef },
+  { 1574, "nextval_oid", 1, true, false, nextval_oid },
+  { 1575, "currval_oid", 1, true, false, currval_oid },
+  { 1576, "setval_oid", 2, true, false, setval_oid },
+  { 1579, "varbit_in", 3, true, false, varbit_in },
+  { 1580, "varbit_out", 1, true, false, varbit_out },
+  { 1581, "biteq", 2, true, false, biteq },
+  { 1582, "bitne", 2, true, false, bitne },
+  { 1592, "bitge", 2, true, false, bitge },
+  { 1593, "bitgt", 2, true, false, bitgt },
+  { 1594, "bitle", 2, true, false, bitle },
+  { 1595, "bitlt", 2, true, false, bitlt },
+  { 1596, "bitcmp", 2, true, false, bitcmp },
+  { 1597, "PG_encoding_to_char", 1, true, false, PG_encoding_to_char },
+  { 1598, "drandom", 0, true, false, drandom },
+  { 1599, "setseed", 1, true, false, setseed },
+  { 1600, "dasin", 1, true, false, dasin },
+  { 1601, "dacos", 1, true, false, dacos },
+  { 1602, "datan", 1, true, false, datan },
+  { 1603, "datan2", 2, true, false, datan2 },
+  { 1604, "dsin", 1, true, false, dsin },
+  { 1605, "dcos", 1, true, false, dcos },
+  { 1606, "dtan", 1, true, false, dtan },
+  { 1607, "dcot", 1, true, false, dcot },
+  { 1608, "degrees", 1, true, false, degrees },
+  { 1609, "radians", 1, true, false, radians },
+  { 1610, "dpi", 0, true, false, dpi },
+  { 1618, "interval_mul", 2, true, false, interval_mul },
+  { 1619, "pg_typeof", 1, false, false, pg_typeof },
+  { 1620, "ascii", 1, true, false, ascii },
+  { 1621, "chr", 1, true, false, chr },
+  { 1622, "repeat", 2, true, false, repeat },
+  { 1623, "similar_escape", 2, false, false, similar_escape },
+  { 1624, "mul_d_interval", 2, true, false, mul_d_interval },
+  { 1631, "textlike", 2, true, false, textlike },
+  { 1632, "textnlike", 2, true, false, textnlike },
+  { 1633, "texticlike", 2, true, false, texticlike },
+  { 1634, "texticnlike", 2, true, false, texticnlike },
+  { 1635, "nameiclike", 2, true, false, nameiclike },
+  { 1636, "nameicnlike", 2, true, false, nameicnlike },
+  { 1637, "like_escape", 2, true, false, like_escape },
+  { 1638, "oidgt", 2, true, false, oidgt },
+  { 1639, "oidge", 2, true, false, oidge },
+  { 1640, "pg_get_viewdef_name", 1, true, false, pg_get_viewdef_name },
+  { 1641, "pg_get_viewdef", 1, true, false, pg_get_viewdef },
+  { 1642, "pg_get_userbyid", 1, true, false, pg_get_userbyid },
+  { 1643, "pg_get_indexdef", 1, true, false, pg_get_indexdef },
+  { 1644, "RI_FKey_check_ins", 0, true, false, RI_FKey_check_ins },
+  { 1645, "RI_FKey_check_upd", 0, true, false, RI_FKey_check_upd },
+  { 1646, "RI_FKey_cascade_del", 0, true, false, RI_FKey_cascade_del },
+  { 1647, "RI_FKey_cascade_upd", 0, true, false, RI_FKey_cascade_upd },
+  { 1648, "RI_FKey_restrict_del", 0, true, false, RI_FKey_restrict_del },
+  { 1649, "RI_FKey_restrict_upd", 0, true, false, RI_FKey_restrict_upd },
+  { 1650, "RI_FKey_setnull_del", 0, true, false, RI_FKey_setnull_del },
+  { 1651, "RI_FKey_setnull_upd", 0, true, false, RI_FKey_setnull_upd },
+  { 1652, "RI_FKey_setdefault_del", 0, true, false, RI_FKey_setdefault_del },
+  { 1653, "RI_FKey_setdefault_upd", 0, true, false, RI_FKey_setdefault_upd },
+  { 1654, "RI_FKey_noaction_del", 0, true, false, RI_FKey_noaction_del },
+  { 1655, "RI_FKey_noaction_upd", 0, true, false, RI_FKey_noaction_upd },
+  { 1656, "texticregexeq", 2, true, false, texticregexeq },
+  { 1657, "texticregexne", 2, true, false, texticregexne },
+  { 1658, "textregexeq", 2, true, false, textregexeq },
+  { 1659, "textregexne", 2, true, false, textregexne },
+  { 1660, "texticlike", 2, true, false, texticlike },
+  { 1661, "texticnlike", 2, true, false, texticnlike },
+  { 1662, "pg_get_triggerdef", 1, true, false, pg_get_triggerdef },
+  { 1665, "pg_get_serial_sequence", 2, true, false, pg_get_serial_sequence },
+  { 1666, "biteq", 2, true, false, biteq },
+  { 1667, "bitne", 2, true, false, bitne },
+  { 1668, "bitge", 2, true, false, bitge },
+  { 1669, "bitgt", 2, true, false, bitgt },
+  { 1670, "bitle", 2, true, false, bitle },
+  { 1671, "bitlt", 2, true, false, bitlt },
+  { 1672, "bitcmp", 2, true, false, bitcmp },
+  { 1673, "bitand", 2, true, false, bitand },
+  { 1674, "bitor", 2, true, false, bitor },
+  { 1675, "bitxor", 2, true, false, bitxor },
+  { 1676, "bitnot", 1, true, false, bitnot },
+  { 1677, "bitshiftleft", 2, true, false, bitshiftleft },
+  { 1678, "bitshiftright", 2, true, false, bitshiftright },
+  { 1679, "bitcat", 2, true, false, bitcat },
+  { 1680, "bitsubstr", 3, true, false, bitsubstr },
+  { 1681, "bitlength", 1, true, false, bitlength },
+  { 1682, "bitoctetlength", 1, true, false, bitoctetlength },
+  { 1683, "bitfromint4", 2, true, false, bitfromint4 },
+  { 1684, "bittoint4", 1, true, false, bittoint4 },
+  { 1685, "bit", 3, true, false, bit },
+  { 1686, "pg_get_keywords", 0, true, true, pg_get_keywords },
+  { 1687, "varbit", 3, true, false, varbit },
+  { 1688, "time_hash", 1, true, false, time_hash },
+  { 1689, "flatfile_update_trigger", 0, true, false, flatfile_update_trigger },
+  { 1690, "time_mi_time", 2, true, false, time_mi_time },
+  { 1691, "boolle", 2, true, false, boolle },
+  { 1692, "boolge", 2, true, false, boolge },
+  { 1693, "btboolcmp", 2, true, false, btboolcmp },
+  { 1696, "timetz_hash", 1, true, false, timetz_hash },
+  { 1697, "interval_hash", 1, true, false, interval_hash },
+  { 1698, "bitposition", 2, true, false, bitposition },
+  { 1701, "numeric_in", 3, true, false, numeric_in },
+  { 1702, "numeric_out", 1, true, false, numeric_out },
+  { 1703, "numeric", 2, true, false, numeric },
+  { 1704, "numeric_abs", 1, true, false, numeric_abs },
+  { 1705, "numeric_abs", 1, true, false, numeric_abs },
+  { 1706, "numeric_sign", 1, true, false, numeric_sign },
+  { 1707, "numeric_round", 2, true, false, numeric_round },
+  { 1709, "numeric_trunc", 2, true, false, numeric_trunc },
+  { 1711, "numeric_ceil", 1, true, false, numeric_ceil },
+  { 1712, "numeric_floor", 1, true, false, numeric_floor },
+  { 1713, "length_in_encoding", 2, true, false, length_in_encoding },
+  { 1714, "pg_convert_from", 2, true, false, pg_convert_from },
+  { 1715, "inet_to_cidr", 1, true, false, inet_to_cidr },
+  { 1716, "pg_get_expr", 2, true, false, pg_get_expr },
+  { 1717, "pg_convert_to", 2, true, false, pg_convert_to },
+  { 1718, "numeric_eq", 2, true, false, numeric_eq },
+  { 1719, "numeric_ne", 2, true, false, numeric_ne },
+  { 1720, "numeric_gt", 2, true, false, numeric_gt },
+  { 1721, "numeric_ge", 2, true, false, numeric_ge },
+  { 1722, "numeric_lt", 2, true, false, numeric_lt },
+  { 1723, "numeric_le", 2, true, false, numeric_le },
+  { 1724, "numeric_add", 2, true, false, numeric_add },
+  { 1725, "numeric_sub", 2, true, false, numeric_sub },
+  { 1726, "numeric_mul", 2, true, false, numeric_mul },
+  { 1727, "numeric_div", 2, true, false, numeric_div },
+  { 1728, "numeric_mod", 2, true, false, numeric_mod },
+  { 1729, "numeric_mod", 2, true, false, numeric_mod },
+  { 1730, "numeric_sqrt", 1, true, false, numeric_sqrt },
+  { 1731, "numeric_sqrt", 1, true, false, numeric_sqrt },
+  { 1732, "numeric_exp", 1, true, false, numeric_exp },
+  { 1733, "numeric_exp", 1, true, false, numeric_exp },
+  { 1734, "numeric_ln", 1, true, false, numeric_ln },
+  { 1735, "numeric_ln", 1, true, false, numeric_ln },
+  { 1736, "numeric_log", 2, true, false, numeric_log },
+  { 1737, "numeric_log", 2, true, false, numeric_log },
+  { 1738, "numeric_power", 2, true, false, numeric_power },
+  { 1739, "numeric_power", 2, true, false, numeric_power },
+  { 1740, "int4_numeric", 1, true, false, int4_numeric },
+  { 1742, "float4_numeric", 1, true, false, float4_numeric },
+  { 1743, "float8_numeric", 1, true, false, float8_numeric },
+  { 1744, "numeric_int4", 1, true, false, numeric_int4 },
+  { 1745, "numeric_float4", 1, true, false, numeric_float4 },
+  { 1746, "numeric_float8", 1, true, false, numeric_float8 },
+  { 1747, "time_pl_interval", 2, true, false, time_pl_interval },
+  { 1748, "time_mi_interval", 2, true, false, time_mi_interval },
+  { 1749, "timetz_pl_interval", 2, true, false, timetz_pl_interval },
+  { 1750, "timetz_mi_interval", 2, true, false, timetz_mi_interval },
+  { 1764, "numeric_inc", 1, true, false, numeric_inc },
+  { 1765, "setval3_oid", 3, true, false, setval3_oid },
+  { 1766, "numeric_smaller", 2, true, false, numeric_smaller },
+  { 1767, "numeric_larger", 2, true, false, numeric_larger },
+  { 1768, "interval_to_char", 2, true, false, interval_to_char },
+  { 1769, "numeric_cmp", 2, true, false, numeric_cmp },
+  { 1770, "timestamptz_to_char", 2, true, false, timestamptz_to_char },
+  { 1771, "numeric_uminus", 1, true, false, numeric_uminus },
+  { 1772, "numeric_to_char", 2, true, false, numeric_to_char },
+  { 1773, "int4_to_char", 2, true, false, int4_to_char },
+  { 1774, "int8_to_char", 2, true, false, int8_to_char },
+  { 1775, "float4_to_char", 2, true, false, float4_to_char },
+  { 1776, "float8_to_char", 2, true, false, float8_to_char },
+  { 1777, "numeric_to_number", 2, true, false, numeric_to_number },
+  { 1778, "to_timestamp", 2, true, false, to_timestamp },
+  { 1779, "numeric_int8", 1, true, false, numeric_int8 },
+  { 1780, "to_date", 2, true, false, to_date },
+  { 1781, "int8_numeric", 1, true, false, int8_numeric },
+  { 1782, "int2_numeric", 1, true, false, int2_numeric },
+  { 1783, "numeric_int2", 1, true, false, numeric_int2 },
+  { 1798, "oidin", 1, true, false, oidin },
+  { 1799, "oidout", 1, true, false, oidout },
+  { 1813, "pg_convert", 3, true, false, pg_convert },
+  { 1814, "iclikesel", 4, true, false, iclikesel },
+  { 1815, "icnlikesel", 4, true, false, icnlikesel },
+  { 1816, "iclikejoinsel", 5, true, false, iclikejoinsel },
+  { 1817, "icnlikejoinsel", 5, true, false, icnlikejoinsel },
+  { 1818, "regexeqsel", 4, true, false, regexeqsel },
+  { 1819, "likesel", 4, true, false, likesel },
+  { 1820, "icregexeqsel", 4, true, false, icregexeqsel },
+  { 1821, "regexnesel", 4, true, false, regexnesel },
+  { 1822, "nlikesel", 4, true, false, nlikesel },
+  { 1823, "icregexnesel", 4, true, false, icregexnesel },
+  { 1824, "regexeqjoinsel", 5, true, false, regexeqjoinsel },
+  { 1825, "likejoinsel", 5, true, false, likejoinsel },
+  { 1826, "icregexeqjoinsel", 5, true, false, icregexeqjoinsel },
+  { 1827, "regexnejoinsel", 5, true, false, regexnejoinsel },
+  { 1828, "nlikejoinsel", 5, true, false, nlikejoinsel },
+  { 1829, "icregexnejoinsel", 5, true, false, icregexnejoinsel },
+  { 1830, "float8_avg", 1, true, false, float8_avg },
+  { 1831, "float8_var_samp", 1, true, false, float8_var_samp },
+  { 1832, "float8_stddev_samp", 1, true, false, float8_stddev_samp },
+  { 1833, "numeric_accum", 2, true, false, numeric_accum },
+  { 1834, "int2_accum", 2, true, false, int2_accum },
+  { 1835, "int4_accum", 2, true, false, int4_accum },
+  { 1836, "int8_accum", 2, true, false, int8_accum },
+  { 1837, "numeric_avg", 1, true, false, numeric_avg },
+  { 1838, "numeric_var_samp", 1, true, false, numeric_var_samp },
+  { 1839, "numeric_stddev_samp", 1, true, false, numeric_stddev_samp },
+  { 1840, "int2_sum", 2, false, false, int2_sum },
+  { 1841, "int4_sum", 2, false, false, int4_sum },
+  { 1842, "int8_sum", 2, false, false, int8_sum },
+  { 1843, "interval_accum", 2, true, false, interval_accum },
+  { 1844, "interval_avg", 1, true, false, interval_avg },
+  { 1845, "to_ascii_default", 1, true, false, to_ascii_default },
+  { 1846, "to_ascii_enc", 2, true, false, to_ascii_enc },
+  { 1847, "to_ascii_encname", 2, true, false, to_ascii_encname },
+  { 1850, "int28eq", 2, true, false, int28eq },
+  { 1851, "int28ne", 2, true, false, int28ne },
+  { 1852, "int28lt", 2, true, false, int28lt },
+  { 1853, "int28gt", 2, true, false, int28gt },
+  { 1854, "int28le", 2, true, false, int28le },
+  { 1855, "int28ge", 2, true, false, int28ge },
+  { 1856, "int82eq", 2, true, false, int82eq },
+  { 1857, "int82ne", 2, true, false, int82ne },
+  { 1858, "int82lt", 2, true, false, int82lt },
+  { 1859, "int82gt", 2, true, false, int82gt },
+  { 1860, "int82le", 2, true, false, int82le },
+  { 1861, "int82ge", 2, true, false, int82ge },
+  { 1892, "int2and", 2, true, false, int2and },
+  { 1893, "int2or", 2, true, false, int2or },
+  { 1894, "int2xor", 2, true, false, int2xor },
+  { 1895, "int2not", 1, true, false, int2not },
+  { 1896, "int2shl", 2, true, false, int2shl },
+  { 1897, "int2shr", 2, true, false, int2shr },
+  { 1898, "int4and", 2, true, false, int4and },
+  { 1899, "int4or", 2, true, false, int4or },
+  { 1900, "int4xor", 2, true, false, int4xor },
+  { 1901, "int4not", 1, true, false, int4not },
+  { 1902, "int4shl", 2, true, false, int4shl },
+  { 1903, "int4shr", 2, true, false, int4shr },
+  { 1904, "int8and", 2, true, false, int8and },
+  { 1905, "int8or", 2, true, false, int8or },
+  { 1906, "int8xor", 2, true, false, int8xor },
+  { 1907, "int8not", 1, true, false, int8not },
+  { 1908, "int8shl", 2, true, false, int8shl },
+  { 1909, "int8shr", 2, true, false, int8shr },
+  { 1910, "int8up", 1, true, false, int8up },
+  { 1911, "int2up", 1, true, false, int2up },
+  { 1912, "int4up", 1, true, false, int4up },
+  { 1913, "float4up", 1, true, false, float4up },
+  { 1914, "float8up", 1, true, false, float8up },
+  { 1915, "numeric_uplus", 1, true, false, numeric_uplus },
+  { 1922, "has_table_privilege_name_name", 3, true, false, has_table_privilege_name_name },
+  { 1923, "has_table_privilege_name_id", 3, true, false, has_table_privilege_name_id },
+  { 1924, "has_table_privilege_id_name", 3, true, false, has_table_privilege_id_name },
+  { 1925, "has_table_privilege_id_id", 3, true, false, has_table_privilege_id_id },
+  { 1926, "has_table_privilege_name", 2, true, false, has_table_privilege_name },
+  { 1927, "has_table_privilege_id", 2, true, false, has_table_privilege_id },
+  { 1928, "pg_stat_get_numscans", 1, true, false, pg_stat_get_numscans },
+  { 1929, "pg_stat_get_tuples_returned", 1, true, false, pg_stat_get_tuples_returned },
+  { 1930, "pg_stat_get_tuples_fetched", 1, true, false, pg_stat_get_tuples_fetched },
+  { 1931, "pg_stat_get_tuples_inserted", 1, true, false, pg_stat_get_tuples_inserted },
+  { 1932, "pg_stat_get_tuples_updated", 1, true, false, pg_stat_get_tuples_updated },
+  { 1933, "pg_stat_get_tuples_deleted", 1, true, false, pg_stat_get_tuples_deleted },
+  { 1934, "pg_stat_get_blocks_fetched", 1, true, false, pg_stat_get_blocks_fetched },
+  { 1935, "pg_stat_get_blocks_hit", 1, true, false, pg_stat_get_blocks_hit },
+  { 1936, "pg_stat_get_backend_idset", 0, true, true, pg_stat_get_backend_idset },
+  { 1937, "pg_stat_get_backend_pid", 1, true, false, pg_stat_get_backend_pid },
+  { 1938, "pg_stat_get_backend_dbid", 1, true, false, pg_stat_get_backend_dbid },
+  { 1939, "pg_stat_get_backend_userid", 1, true, false, pg_stat_get_backend_userid },
+  { 1940, "pg_stat_get_backend_activity", 1, true, false, pg_stat_get_backend_activity },
+  { 1941, "pg_stat_get_db_numbackends", 1, true, false, pg_stat_get_db_numbackends },
+  { 1942, "pg_stat_get_db_xact_commit", 1, true, false, pg_stat_get_db_xact_commit },
+  { 1943, "pg_stat_get_db_xact_rollback", 1, true, false, pg_stat_get_db_xact_rollback },
+  { 1944, "pg_stat_get_db_blocks_fetched", 1, true, false, pg_stat_get_db_blocks_fetched },
+  { 1945, "pg_stat_get_db_blocks_hit", 1, true, false, pg_stat_get_db_blocks_hit },
+  { 1946, "binary_encode", 2, true, false, binary_encode },
+  { 1947, "binary_decode", 2, true, false, binary_decode },
+  { 1948, "byteaeq", 2, true, false, byteaeq },
+  { 1949, "bytealt", 2, true, false, bytealt },
+  { 1950, "byteale", 2, true, false, byteale },
+  { 1951, "byteagt", 2, true, false, byteagt },
+  { 1952, "byteage", 2, true, false, byteage },
+  { 1953, "byteane", 2, true, false, byteane },
+  { 1954, "byteacmp", 2, true, false, byteacmp },
+  { 1961, "timestamp_scale", 2, true, false, timestamp_scale },
+  { 1962, "int2_avg_accum", 2, true, false, int2_avg_accum },
+  { 1963, "int4_avg_accum", 2, true, false, int4_avg_accum },
+  { 1964, "int8_avg", 1, true, false, int8_avg },
+  { 1965, "oidlarger", 2, true, false, oidlarger },
+  { 1966, "oidsmaller", 2, true, false, oidsmaller },
+  { 1967, "timestamptz_scale", 2, true, false, timestamptz_scale },
+  { 1968, "time_scale", 2, true, false, time_scale },
+  { 1969, "timetz_scale", 2, true, false, timetz_scale },
+  { 1972, "pg_stat_get_tuples_hot_updated", 1, true, false, pg_stat_get_tuples_hot_updated },
+  { 1973, "numeric_div_trunc", 2, true, false, numeric_div_trunc },
+  { 1980, "numeric_div_trunc", 2, true, false, numeric_div_trunc },
+  { 2005, "bytealike", 2, true, false, bytealike },
+  { 2006, "byteanlike", 2, true, false, byteanlike },
+  { 2007, "bytealike", 2, true, false, bytealike },
+  { 2008, "byteanlike", 2, true, false, byteanlike },
+  { 2009, "like_escape_bytea", 2, true, false, like_escape_bytea },
+  { 2010, "byteaoctetlen", 1, true, false, byteaoctetlen },
+  { 2011, "byteacat", 2, true, false, byteacat },
+  { 2012, "bytea_substr", 3, true, false, bytea_substr },
+  { 2013, "bytea_substr_no_len", 2, true, false, bytea_substr_no_len },
+  { 2014, "byteapos", 2, true, false, byteapos },
+  { 2015, "byteatrim", 2, true, false, byteatrim },
+  { 2019, "timestamptz_time", 1, true, false, timestamptz_time },
+  { 2020, "timestamp_trunc", 2, true, false, timestamp_trunc },
+  { 2021, "timestamp_part", 2, true, false, timestamp_part },
+  { 2022, "pg_stat_get_activity", 1, false, true, pg_stat_get_activity },
+  { 2023, "abstime_timestamp", 1, true, false, abstime_timestamp },
+  { 2024, "date_timestamp", 1, true, false, date_timestamp },
+  { 2025, "datetime_timestamp", 2, true, false, datetime_timestamp },
+  { 2026, "pg_backend_pid", 0, true, false, pg_backend_pid },
+  { 2027, "timestamptz_timestamp", 1, true, false, timestamptz_timestamp },
+  { 2028, "timestamp_timestamptz", 1, true, false, timestamp_timestamptz },
+  { 2029, "timestamp_date", 1, true, false, timestamp_date },
+  { 2030, "timestamp_abstime", 1, true, false, timestamp_abstime },
+  { 2031, "timestamp_mi", 2, true, false, timestamp_mi },
+  { 2032, "timestamp_pl_interval", 2, true, false, timestamp_pl_interval },
+  { 2033, "timestamp_mi_interval", 2, true, false, timestamp_mi_interval },
+  { 2034, "pg_conf_load_time", 0, true, false, pg_conf_load_time },
+  { 2035, "timestamp_smaller", 2, true, false, timestamp_smaller },
+  { 2036, "timestamp_larger", 2, true, false, timestamp_larger },
+  { 2037, "timetz_zone", 2, true, false, timetz_zone },
+  { 2038, "timetz_izone", 2, true, false, timetz_izone },
+  { 2039, "timestamp_hash", 1, true, false, timestamp_hash },
+  { 2041, "overlaps_timestamp", 4, false, false, overlaps_timestamp },
+  { 2045, "timestamp_cmp", 2, true, false, timestamp_cmp },
+  { 2046, "timetz_time", 1, true, false, timetz_time },
+  { 2047, "time_timetz", 1, true, false, time_timetz },
+  { 2048, "timestamp_finite", 1, true, false, timestamp_finite },
+  { 2049, "timestamp_to_char", 2, true, false, timestamp_to_char },
+  { 2050, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2051, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2052, "timestamp_eq", 2, true, false, timestamp_eq },
+  { 2053, "timestamp_ne", 2, true, false, timestamp_ne },
+  { 2054, "timestamp_lt", 2, true, false, timestamp_lt },
+  { 2055, "timestamp_le", 2, true, false, timestamp_le },
+  { 2056, "timestamp_ge", 2, true, false, timestamp_ge },
+  { 2057, "timestamp_gt", 2, true, false, timestamp_gt },
+  { 2058, "timestamp_age", 2, true, false, timestamp_age },
+  { 2069, "timestamp_zone", 2, true, false, timestamp_zone },
+  { 2070, "timestamp_izone", 2, true, false, timestamp_izone },
+  { 2071, "date_pl_interval", 2, true, false, date_pl_interval },
+  { 2072, "date_mi_interval", 2, true, false, date_mi_interval },
+  { 2073, "textregexsubstr", 2, true, false, textregexsubstr },
+  { 2075, "bitfromint8", 2, true, false, bitfromint8 },
+  { 2076, "bittoint8", 1, true, false, bittoint8 },
+  { 2077, "show_config_by_name", 1, true, false, show_config_by_name },
+  { 2078, "set_config_by_name", 3, false, false, set_config_by_name },
+  { 2079, "pg_table_is_visible", 1, true, false, pg_table_is_visible },
+  { 2080, "pg_type_is_visible", 1, true, false, pg_type_is_visible },
+  { 2081, "pg_function_is_visible", 1, true, false, pg_function_is_visible },
+  { 2082, "pg_operator_is_visible", 1, true, false, pg_operator_is_visible },
+  { 2083, "pg_opclass_is_visible", 1, true, false, pg_opclass_is_visible },
+  { 2084, "show_all_settings", 0, true, true, show_all_settings },
+  { 2085, "bytea_substr", 3, true, false, bytea_substr },
+  { 2086, "bytea_substr_no_len", 2, true, false, bytea_substr_no_len },
+  { 2087, "replace_text", 3, true, false, replace_text },
+  { 2088, "split_text", 3, true, false, split_text },
+  { 2089, "to_hex32", 1, true, false, to_hex32 },
+  { 2090, "to_hex64", 1, true, false, to_hex64 },
+  { 2091, "array_lower", 2, true, false, array_lower },
+  { 2092, "array_upper", 2, true, false, array_upper },
+  { 2093, "pg_conversion_is_visible", 1, true, false, pg_conversion_is_visible },
+  { 2094, "pg_stat_get_backend_activity_start", 1, true, false, pg_stat_get_backend_activity_start },
+  { 2096, "pg_terminate_backend", 1, true, false, pg_terminate_backend },
+  { 2098, "pg_get_functiondef", 1, true, false, pg_get_functiondef },
+  { 2100, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2101, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2102, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2103, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2104, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2105, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2106, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2107, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2108, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2109, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2110, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2111, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2112, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2113, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2114, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2115, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2116, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2117, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2118, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2119, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2120, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2121, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2122, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2123, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2124, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2125, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2126, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2127, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2128, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2129, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2130, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2131, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2132, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2133, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2134, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2135, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2136, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2137, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2138, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2139, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2140, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2141, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2142, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2143, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2144, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2145, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2146, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2147, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2148, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2149, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2150, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2151, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2152, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2153, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2154, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2155, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2156, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2157, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2158, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2159, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2160, "text_pattern_lt", 2, true, false, text_pattern_lt },
+  { 2161, "text_pattern_le", 2, true, false, text_pattern_le },
+  { 2162, "pg_get_function_arguments", 1, true, false, pg_get_function_arguments },
+  { 2163, "text_pattern_ge", 2, true, false, text_pattern_ge },
+  { 2164, "text_pattern_gt", 2, true, false, text_pattern_gt },
+  { 2165, "pg_get_function_result", 1, true, false, pg_get_function_result },
+  { 2166, "bttext_pattern_cmp", 2, true, false, bttext_pattern_cmp },
+  { 2167, "numeric_ceil", 1, true, false, numeric_ceil },
+  { 2168, "pg_database_size_name", 1, true, false, pg_database_size_name },
+  { 2169, "numeric_power", 2, true, false, numeric_power },
+  { 2170, "width_bucket_numeric", 4, true, false, width_bucket_numeric },
+  { 2171, "pg_cancel_backend", 1, true, false, pg_cancel_backend },
+  { 2172, "pg_start_backup", 2, true, false, pg_start_backup },
+  { 2173, "pg_stop_backup", 0, true, false, pg_stop_backup },
+  { 2174, "bpchar_pattern_lt", 2, true, false, bpchar_pattern_lt },
+  { 2175, "bpchar_pattern_le", 2, true, false, bpchar_pattern_le },
+  { 2176, "array_length", 2, true, false, array_length },
+  { 2177, "bpchar_pattern_ge", 2, true, false, bpchar_pattern_ge },
+  { 2178, "bpchar_pattern_gt", 2, true, false, bpchar_pattern_gt },
+  { 2180, "btbpchar_pattern_cmp", 2, true, false, btbpchar_pattern_cmp },
+  { 2188, "btint48cmp", 2, true, false, btint48cmp },
+  { 2189, "btint84cmp", 2, true, false, btint84cmp },
+  { 2190, "btint24cmp", 2, true, false, btint24cmp },
+  { 2191, "btint42cmp", 2, true, false, btint42cmp },
+  { 2192, "btint28cmp", 2, true, false, btint28cmp },
+  { 2193, "btint82cmp", 2, true, false, btint82cmp },
+  { 2194, "btfloat48cmp", 2, true, false, btfloat48cmp },
+  { 2195, "btfloat84cmp", 2, true, false, btfloat84cmp },
+  { 2196, "inet_client_addr", 0, false, false, inet_client_addr },
+  { 2197, "inet_client_port", 0, false, false, inet_client_port },
+  { 2198, "inet_server_addr", 0, false, false, inet_server_addr },
+  { 2199, "inet_server_port", 0, false, false, inet_server_port },
+  { 2212, "regprocedurein", 1, true, false, regprocedurein },
+  { 2213, "regprocedureout", 1, true, false, regprocedureout },
+  { 2214, "regoperin", 1, true, false, regoperin },
+  { 2215, "regoperout", 1, true, false, regoperout },
+  { 2216, "regoperatorin", 1, true, false, regoperatorin },
+  { 2217, "regoperatorout", 1, true, false, regoperatorout },
+  { 2218, "regclassin", 1, true, false, regclassin },
+  { 2219, "regclassout", 1, true, false, regclassout },
+  { 2220, "regtypein", 1, true, false, regtypein },
+  { 2221, "regtypeout", 1, true, false, regtypeout },
+  { 2230, "pg_stat_clear_snapshot", 0, false, false, pg_stat_clear_snapshot },
+  { 2232, "pg_get_function_identity_arguments", 1, true, false, pg_get_function_identity_arguments },
+  { 2236, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2237, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2238, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2239, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2240, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2241, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2242, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2243, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2244, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2245, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2246, "fmgr_internal_validator", 1, true, false, fmgr_internal_validator },
+  { 2247, "fmgr_c_validator", 1, true, false, fmgr_c_validator },
+  { 2248, "fmgr_sql_validator", 1, true, false, fmgr_sql_validator },
+  { 2250, "has_database_privilege_name_name", 3, true, false, has_database_privilege_name_name },
+  { 2251, "has_database_privilege_name_id", 3, true, false, has_database_privilege_name_id },
+  { 2252, "has_database_privilege_id_name", 3, true, false, has_database_privilege_id_name },
+  { 2253, "has_database_privilege_id_id", 3, true, false, has_database_privilege_id_id },
+  { 2254, "has_database_privilege_name", 2, true, false, has_database_privilege_name },
+  { 2255, "has_database_privilege_id", 2, true, false, has_database_privilege_id },
+  { 2256, "has_function_privilege_name_name", 3, true, false, has_function_privilege_name_name },
+  { 2257, "has_function_privilege_name_id", 3, true, false, has_function_privilege_name_id },
+  { 2258, "has_function_privilege_id_name", 3, true, false, has_function_privilege_id_name },
+  { 2259, "has_function_privilege_id_id", 3, true, false, has_function_privilege_id_id },
+  { 2260, "has_function_privilege_name", 2, true, false, has_function_privilege_name },
+  { 2261, "has_function_privilege_id", 2, true, false, has_function_privilege_id },
+  { 2262, "has_language_privilege_name_name", 3, true, false, has_language_privilege_name_name },
+  { 2263, "has_language_privilege_name_id", 3, true, false, has_language_privilege_name_id },
+  { 2264, "has_language_privilege_id_name", 3, true, false, has_language_privilege_id_name },
+  { 2265, "has_language_privilege_id_id", 3, true, false, has_language_privilege_id_id },
+  { 2266, "has_language_privilege_name", 2, true, false, has_language_privilege_name },
+  { 2267, "has_language_privilege_id", 2, true, false, has_language_privilege_id },
+  { 2268, "has_schema_privilege_name_name", 3, true, false, has_schema_privilege_name_name },
+  { 2269, "has_schema_privilege_name_id", 3, true, false, has_schema_privilege_name_id },
+  { 2270, "has_schema_privilege_id_name", 3, true, false, has_schema_privilege_id_name },
+  { 2271, "has_schema_privilege_id_id", 3, true, false, has_schema_privilege_id_id },
+  { 2272, "has_schema_privilege_name", 2, true, false, has_schema_privilege_name },
+  { 2273, "has_schema_privilege_id", 2, true, false, has_schema_privilege_id },
+  { 2274, "pg_stat_reset", 0, false, false, pg_stat_reset },
+  { 2284, "textregexreplace_noopt", 3, true, false, textregexreplace_noopt },
+  { 2285, "textregexreplace", 4, true, false, textregexreplace },
+  { 2286, "pg_total_relation_size", 1, true, false, pg_total_relation_size },
+  { 2288, "pg_size_pretty", 1, true, false, pg_size_pretty },
+  { 2289, "pg_options_to_table", 1, true, true, pg_options_to_table },
+  { 2290, "record_in", 3, true, false, record_in },
+  { 2291, "record_out", 1, true, false, record_out },
+  { 2292, "cstring_in", 1, true, false, cstring_in },
+  { 2293, "cstring_out", 1, true, false, cstring_out },
+  { 2294, "any_in", 1, true, false, any_in },
+  { 2295, "any_out", 1, true, false, any_out },
+  { 2296, "anyarray_in", 1, true, false, anyarray_in },
+  { 2297, "anyarray_out", 1, true, false, anyarray_out },
+  { 2298, "void_in", 1, true, false, void_in },
+  { 2299, "void_out", 1, true, false, void_out },
+  { 2300, "trigger_in", 1, false, false, trigger_in },
+  { 2301, "trigger_out", 1, true, false, trigger_out },
+  { 2302, "language_handler_in", 1, false, false, language_handler_in },
+  { 2303, "language_handler_out", 1, true, false, language_handler_out },
+  { 2304, "internal_in", 1, false, false, internal_in },
+  { 2305, "internal_out", 1, true, false, internal_out },
+  { 2306, "opaque_in", 1, false, false, opaque_in },
+  { 2307, "opaque_out", 1, true, false, opaque_out },
+  { 2308, "dceil", 1, true, false, dceil },
+  { 2309, "dfloor", 1, true, false, dfloor },
+  { 2310, "dsign", 1, true, false, dsign },
+  { 2311, "md5_text", 1, true, false, md5_text },
+  { 2312, "anyelement_in", 1, true, false, anyelement_in },
+  { 2313, "anyelement_out", 1, true, false, anyelement_out },
+  { 2316, "postgresql_fdw_validator", 2, true, false, postgresql_fdw_validator },
+  { 2320, "dceil", 1, true, false, dceil },
+  { 2321, "md5_bytea", 1, true, false, md5_bytea },
+  { 2322, "pg_tablespace_size_oid", 1, true, false, pg_tablespace_size_oid },
+  { 2323, "pg_tablespace_size_name", 1, true, false, pg_tablespace_size_name },
+  { 2324, "pg_database_size_oid", 1, true, false, pg_database_size_oid },
+  { 2331, "array_unnest", 1, true, true, array_unnest },
+  { 2332, "pg_relation_size", 2, true, false, pg_relation_size },
+  { 2333, "array_agg_transfn", 2, false, false, array_agg_transfn },
+  { 2334, "array_agg_finalfn", 1, false, false, array_agg_finalfn },
+  { 2335, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2338, "date_lt_timestamp", 2, true, false, date_lt_timestamp },
+  { 2339, "date_le_timestamp", 2, true, false, date_le_timestamp },
+  { 2340, "date_eq_timestamp", 2, true, false, date_eq_timestamp },
+  { 2341, "date_gt_timestamp", 2, true, false, date_gt_timestamp },
+  { 2342, "date_ge_timestamp", 2, true, false, date_ge_timestamp },
+  { 2343, "date_ne_timestamp", 2, true, false, date_ne_timestamp },
+  { 2344, "date_cmp_timestamp", 2, true, false, date_cmp_timestamp },
+  { 2351, "date_lt_timestamptz", 2, true, false, date_lt_timestamptz },
+  { 2352, "date_le_timestamptz", 2, true, false, date_le_timestamptz },
+  { 2353, "date_eq_timestamptz", 2, true, false, date_eq_timestamptz },
+  { 2354, "date_gt_timestamptz", 2, true, false, date_gt_timestamptz },
+  { 2355, "date_ge_timestamptz", 2, true, false, date_ge_timestamptz },
+  { 2356, "date_ne_timestamptz", 2, true, false, date_ne_timestamptz },
+  { 2357, "date_cmp_timestamptz", 2, true, false, date_cmp_timestamptz },
+  { 2364, "timestamp_lt_date", 2, true, false, timestamp_lt_date },
+  { 2365, "timestamp_le_date", 2, true, false, timestamp_le_date },
+  { 2366, "timestamp_eq_date", 2, true, false, timestamp_eq_date },
+  { 2367, "timestamp_gt_date", 2, true, false, timestamp_gt_date },
+  { 2368, "timestamp_ge_date", 2, true, false, timestamp_ge_date },
+  { 2369, "timestamp_ne_date", 2, true, false, timestamp_ne_date },
+  { 2370, "timestamp_cmp_date", 2, true, false, timestamp_cmp_date },
+  { 2377, "timestamptz_lt_date", 2, true, false, timestamptz_lt_date },
+  { 2378, "timestamptz_le_date", 2, true, false, timestamptz_le_date },
+  { 2379, "timestamptz_eq_date", 2, true, false, timestamptz_eq_date },
+  { 2380, "timestamptz_gt_date", 2, true, false, timestamptz_gt_date },
+  { 2381, "timestamptz_ge_date", 2, true, false, timestamptz_ge_date },
+  { 2382, "timestamptz_ne_date", 2, true, false, timestamptz_ne_date },
+  { 2383, "timestamptz_cmp_date", 2, true, false, timestamptz_cmp_date },
+  { 2390, "has_tablespace_privilege_name_name", 3, true, false, has_tablespace_privilege_name_name },
+  { 2391, "has_tablespace_privilege_name_id", 3, true, false, has_tablespace_privilege_name_id },
+  { 2392, "has_tablespace_privilege_id_name", 3, true, false, has_tablespace_privilege_id_name },
+  { 2393, "has_tablespace_privilege_id_id", 3, true, false, has_tablespace_privilege_id_id },
+  { 2394, "has_tablespace_privilege_name", 2, true, false, has_tablespace_privilege_name },
+  { 2395, "has_tablespace_privilege_id", 2, true, false, has_tablespace_privilege_id },
+  { 2398, "shell_in", 1, false, false, shell_in },
+  { 2399, "shell_out", 1, true, false, shell_out },
+  { 2400, "array_recv", 3, true, false, array_recv },
+  { 2401, "array_send", 1, true, false, array_send },
+  { 2402, "record_recv", 3, true, false, record_recv },
+  { 2403, "record_send", 1, true, false, record_send },
+  { 2404, "int2recv", 1, true, false, int2recv },
+  { 2405, "int2send", 1, true, false, int2send },
+  { 2406, "int4recv", 1, true, false, int4recv },
+  { 2407, "int4send", 1, true, false, int4send },
+  { 2408, "int8recv", 1, true, false, int8recv },
+  { 2409, "int8send", 1, true, false, int8send },
+  { 2410, "int2vectorrecv", 1, true, false, int2vectorrecv },
+  { 2411, "int2vectorsend", 1, true, false, int2vectorsend },
+  { 2412, "bytearecv", 1, true, false, bytearecv },
+  { 2413, "byteasend", 1, true, false, byteasend },
+  { 2414, "textrecv", 1, true, false, textrecv },
+  { 2415, "textsend", 1, true, false, textsend },
+  { 2416, "unknownrecv", 1, true, false, unknownrecv },
+  { 2417, "unknownsend", 1, true, false, unknownsend },
+  { 2418, "oidrecv", 1, true, false, oidrecv },
+  { 2419, "oidsend", 1, true, false, oidsend },
+  { 2420, "oidvectorrecv", 1, true, false, oidvectorrecv },
+  { 2421, "oidvectorsend", 1, true, false, oidvectorsend },
+  { 2422, "namerecv", 1, true, false, namerecv },
+  { 2423, "namesend", 1, true, false, namesend },
+  { 2424, "float4recv", 1, true, false, float4recv },
+  { 2425, "float4send", 1, true, false, float4send },
+  { 2426, "float8recv", 1, true, false, float8recv },
+  { 2427, "float8send", 1, true, false, float8send },
+  { 2428, "point_recv", 1, true, false, point_recv },
+  { 2429, "point_send", 1, true, false, point_send },
+  { 2430, "bpcharrecv", 3, true, false, bpcharrecv },
+  { 2431, "bpcharsend", 1, true, false, bpcharsend },
+  { 2432, "varcharrecv", 3, true, false, varcharrecv },
+  { 2433, "varcharsend", 1, true, false, varcharsend },
+  { 2434, "charrecv", 1, true, false, charrecv },
+  { 2435, "charsend", 1, true, false, charsend },
+  { 2436, "boolrecv", 1, true, false, boolrecv },
+  { 2437, "boolsend", 1, true, false, boolsend },
+  { 2438, "tidrecv", 1, true, false, tidrecv },
+  { 2439, "tidsend", 1, true, false, tidsend },
+  { 2440, "xidrecv", 1, true, false, xidrecv },
+  { 2441, "xidsend", 1, true, false, xidsend },
+  { 2442, "cidrecv", 1, true, false, cidrecv },
+  { 2443, "cidsend", 1, true, false, cidsend },
+  { 2444, "regprocrecv", 1, true, false, regprocrecv },
+  { 2445, "regprocsend", 1, true, false, regprocsend },
+  { 2446, "regprocedurerecv", 1, true, false, regprocedurerecv },
+  { 2447, "regproceduresend", 1, true, false, regproceduresend },
+  { 2448, "regoperrecv", 1, true, false, regoperrecv },
+  { 2449, "regopersend", 1, true, false, regopersend },
+  { 2450, "regoperatorrecv", 1, true, false, regoperatorrecv },
+  { 2451, "regoperatorsend", 1, true, false, regoperatorsend },
+  { 2452, "regclassrecv", 1, true, false, regclassrecv },
+  { 2453, "regclasssend", 1, true, false, regclasssend },
+  { 2454, "regtyperecv", 1, true, false, regtyperecv },
+  { 2455, "regtypesend", 1, true, false, regtypesend },
+  { 2456, "bit_recv", 3, true, false, bit_recv },
+  { 2457, "bit_send", 1, true, false, bit_send },
+  { 2458, "varbit_recv", 3, true, false, varbit_recv },
+  { 2459, "varbit_send", 1, true, false, varbit_send },
+  { 2460, "numeric_recv", 3, true, false, numeric_recv },
+  { 2461, "numeric_send", 1, true, false, numeric_send },
+  { 2462, "abstimerecv", 1, true, false, abstimerecv },
+  { 2463, "abstimesend", 1, true, false, abstimesend },
+  { 2464, "reltimerecv", 1, true, false, reltimerecv },
+  { 2465, "reltimesend", 1, true, false, reltimesend },
+  { 2466, "tintervalrecv", 1, true, false, tintervalrecv },
+  { 2467, "tintervalsend", 1, true, false, tintervalsend },
+  { 2468, "date_recv", 1, true, false, date_recv },
+  { 2469, "date_send", 1, true, false, date_send },
+  { 2470, "time_recv", 3, true, false, time_recv },
+  { 2471, "time_send", 1, true, false, time_send },
+  { 2472, "timetz_recv", 3, true, false, timetz_recv },
+  { 2473, "timetz_send", 1, true, false, timetz_send },
+  { 2474, "timestamp_recv", 3, true, false, timestamp_recv },
+  { 2475, "timestamp_send", 1, true, false, timestamp_send },
+  { 2476, "timestamptz_recv", 3, true, false, timestamptz_recv },
+  { 2477, "timestamptz_send", 1, true, false, timestamptz_send },
+  { 2478, "interval_recv", 3, true, false, interval_recv },
+  { 2479, "interval_send", 1, true, false, interval_send },
+  { 2480, "lseg_recv", 1, true, false, lseg_recv },
+  { 2481, "lseg_send", 1, true, false, lseg_send },
+  { 2482, "path_recv", 1, true, false, path_recv },
+  { 2483, "path_send", 1, true, false, path_send },
+  { 2484, "box_recv", 1, true, false, box_recv },
+  { 2485, "box_send", 1, true, false, box_send },
+  { 2486, "poly_recv", 1, true, false, poly_recv },
+  { 2487, "poly_send", 1, true, false, poly_send },
+  { 2488, "line_recv", 1, true, false, line_recv },
+  { 2489, "line_send", 1, true, false, line_send },
+  { 2490, "circle_recv", 1, true, false, circle_recv },
+  { 2491, "circle_send", 1, true, false, circle_send },
+  { 2492, "cash_recv", 1, true, false, cash_recv },
+  { 2493, "cash_send", 1, true, false, cash_send },
+  { 2494, "macaddr_recv", 1, true, false, macaddr_recv },
+  { 2495, "macaddr_send", 1, true, false, macaddr_send },
+  { 2496, "inet_recv", 1, true, false, inet_recv },
+  { 2497, "inet_send", 1, true, false, inet_send },
+  { 2498, "cidr_recv", 1, true, false, cidr_recv },
+  { 2499, "cidr_send", 1, true, false, cidr_send },
+  { 2500, "cstring_recv", 1, true, false, cstring_recv },
+  { 2501, "cstring_send", 1, true, false, cstring_send },
+  { 2502, "anyarray_recv", 1, true, false, anyarray_recv },
+  { 2503, "anyarray_send", 1, true, false, anyarray_send },
+  { 2504, "pg_get_ruledef_ext", 2, true, false, pg_get_ruledef_ext },
+  { 2505, "pg_get_viewdef_name_ext", 2, true, false, pg_get_viewdef_name_ext },
+  { 2506, "pg_get_viewdef_ext", 2, true, false, pg_get_viewdef_ext },
+  { 2507, "pg_get_indexdef_ext", 3, true, false, pg_get_indexdef_ext },
+  { 2508, "pg_get_constraintdef_ext", 2, true, false, pg_get_constraintdef_ext },
+  { 2509, "pg_get_expr_ext", 3, true, false, pg_get_expr_ext },
+  { 2510, "pg_prepared_statement", 0, true, true, pg_prepared_statement },
+  { 2511, "pg_cursor", 0, true, true, pg_cursor },
+  { 2512, "float8_var_pop", 1, true, false, float8_var_pop },
+  { 2513, "float8_stddev_pop", 1, true, false, float8_stddev_pop },
+  { 2514, "numeric_var_pop", 1, true, false, numeric_var_pop },
+  { 2515, "booland_statefunc", 2, true, false, booland_statefunc },
+  { 2516, "boolor_statefunc", 2, true, false, boolor_statefunc },
+  { 2517, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2518, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2519, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2520, "timestamp_lt_timestamptz", 2, true, false, timestamp_lt_timestamptz },
+  { 2521, "timestamp_le_timestamptz", 2, true, false, timestamp_le_timestamptz },
+  { 2522, "timestamp_eq_timestamptz", 2, true, false, timestamp_eq_timestamptz },
+  { 2523, "timestamp_gt_timestamptz", 2, true, false, timestamp_gt_timestamptz },
+  { 2524, "timestamp_ge_timestamptz", 2, true, false, timestamp_ge_timestamptz },
+  { 2525, "timestamp_ne_timestamptz", 2, true, false, timestamp_ne_timestamptz },
+  { 2526, "timestamp_cmp_timestamptz", 2, true, false, timestamp_cmp_timestamptz },
+  { 2527, "timestamptz_lt_timestamp", 2, true, false, timestamptz_lt_timestamp },
+  { 2528, "timestamptz_le_timestamp", 2, true, false, timestamptz_le_timestamp },
+  { 2529, "timestamptz_eq_timestamp", 2, true, false, timestamptz_eq_timestamp },
+  { 2530, "timestamptz_gt_timestamp", 2, true, false, timestamptz_gt_timestamp },
+  { 2531, "timestamptz_ge_timestamp", 2, true, false, timestamptz_ge_timestamp },
+  { 2532, "timestamptz_ne_timestamp", 2, true, false, timestamptz_ne_timestamp },
+  { 2533, "timestamptz_cmp_timestamp", 2, true, false, timestamptz_cmp_timestamp },
+  { 2556, "pg_tablespace_databases", 1, true, true, pg_tablespace_databases },
+  { 2557, "int4_bool", 1, true, false, int4_bool },
+  { 2558, "bool_int4", 1, true, false, bool_int4 },
+  { 2559, "lastval", 0, true, false, lastval },
+  { 2560, "pg_postmaster_start_time", 0, true, false, pg_postmaster_start_time },
+  { 2561, "gistvacuumcleanup", 2, true, false, gistvacuumcleanup },
+  { 2562, "box_below", 2, true, false, box_below },
+  { 2563, "box_overbelow", 2, true, false, box_overbelow },
+  { 2564, "box_overabove", 2, true, false, box_overabove },
+  { 2565, "box_above", 2, true, false, box_above },
+  { 2566, "poly_below", 2, true, false, poly_below },
+  { 2567, "poly_overbelow", 2, true, false, poly_overbelow },
+  { 2568, "poly_overabove", 2, true, false, poly_overabove },
+  { 2569, "poly_above", 2, true, false, poly_above },
+  { 2578, "gist_box_consistent", 5, true, false, gist_box_consistent },
+  { 2579, "gist_box_compress", 1, true, false, gist_box_compress },
+  { 2580, "gist_box_decompress", 1, true, false, gist_box_decompress },
+  { 2581, "gist_box_penalty", 3, true, false, gist_box_penalty },
+  { 2582, "gist_box_picksplit", 2, true, false, gist_box_picksplit },
+  { 2583, "gist_box_union", 2, true, false, gist_box_union },
+  { 2584, "gist_box_same", 3, true, false, gist_box_same },
+  { 2585, "gist_poly_consistent", 5, true, false, gist_poly_consistent },
+  { 2586, "gist_poly_compress", 1, true, false, gist_poly_compress },
+  { 2587, "circle_overbelow", 2, true, false, circle_overbelow },
+  { 2588, "circle_overabove", 2, true, false, circle_overabove },
+  { 2591, "gist_circle_consistent", 5, true, false, gist_circle_consistent },
+  { 2592, "gist_circle_compress", 1, true, false, gist_circle_compress },
+  { 2596, "numeric_stddev_pop", 1, true, false, numeric_stddev_pop },
+  { 2597, "domain_in", 3, false, false, domain_in },
+  { 2598, "domain_recv", 3, false, false, domain_recv },
+  { 2599, "pg_timezone_abbrevs", 0, true, true, pg_timezone_abbrevs },
+  { 2621, "pg_reload_conf", 0, true, false, pg_reload_conf },
+  { 2622, "pg_rotate_logfile", 0, true, false, pg_rotate_logfile },
+  { 2623, "pg_stat_file", 1, true, false, pg_stat_file },
+  { 2624, "pg_read_file", 3, true, false, pg_read_file },
+  { 2625, "pg_ls_dir", 1, true, true, pg_ls_dir },
+  { 2626, "pg_sleep", 1, true, false, pg_sleep },
+  { 2627, "inetnot", 1, true, false, inetnot },
+  { 2628, "inetand", 2, true, false, inetand },
+  { 2629, "inetor", 2, true, false, inetor },
+  { 2630, "inetpl", 2, true, false, inetpl },
+  { 2632, "inetmi_int8", 2, true, false, inetmi_int8 },
+  { 2633, "inetmi", 2, true, false, inetmi },
+  { 2641, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2642, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2643, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2644, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2645, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2646, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2647, "now", 0, true, false, now },
+  { 2648, "statement_timestamp", 0, true, false, statement_timestamp },
+  { 2649, "clock_timestamp", 0, true, false, clock_timestamp },
+  { 2700, "gin_cmp_prefix", 4, true, false, gin_cmp_prefix },
+  { 2705, "pg_has_role_name_name", 3, true, false, pg_has_role_name_name },
+  { 2706, "pg_has_role_name_id", 3, true, false, pg_has_role_name_id },
+  { 2707, "pg_has_role_id_name", 3, true, false, pg_has_role_id_name },
+  { 2708, "pg_has_role_id_id", 3, true, false, pg_has_role_id_id },
+  { 2709, "pg_has_role_name", 2, true, false, pg_has_role_name },
+  { 2710, "pg_has_role_id", 2, true, false, pg_has_role_id },
+  { 2711, "interval_justify_interval", 1, true, false, interval_justify_interval },
+  { 2712, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2713, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2714, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2715, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2716, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2717, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2718, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2719, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2720, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2721, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2722, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2723, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2724, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2725, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2726, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2727, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2728, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2729, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2731, "gingetbitmap", 2, true, false, gingetbitmap },
+  { 2732, "gininsert", 6, true, false, gininsert },
+  { 2733, "ginbeginscan", 3, true, false, ginbeginscan },
+  { 2734, "ginrescan", 2, true, false, ginrescan },
+  { 2735, "ginendscan", 1, true, false, ginendscan },
+  { 2736, "ginmarkpos", 1, true, false, ginmarkpos },
+  { 2737, "ginrestrpos", 1, true, false, ginrestrpos },
+  { 2738, "ginbuild", 3, true, false, ginbuild },
+  { 2739, "ginbulkdelete", 4, true, false, ginbulkdelete },
+  { 2740, "ginvacuumcleanup", 2, true, false, ginvacuumcleanup },
+  { 2741, "gincostestimate", 8, true, false, gincostestimate },
+  { 2743, "ginarrayextract", 2, true, false, ginarrayextract },
+  { 2744, "ginarrayconsistent", 6, true, false, ginarrayconsistent },
+  { 2746, "int8_avg_accum", 2, true, false, int8_avg_accum },
+  { 2747, "arrayoverlap", 2, true, false, arrayoverlap },
+  { 2748, "arraycontains", 2, true, false, arraycontains },
+  { 2749, "arraycontained", 2, true, false, arraycontained },
+  { 2758, "pg_stat_get_db_tuples_returned", 1, true, false, pg_stat_get_db_tuples_returned },
+  { 2759, "pg_stat_get_db_tuples_fetched", 1, true, false, pg_stat_get_db_tuples_fetched },
+  { 2760, "pg_stat_get_db_tuples_inserted", 1, true, false, pg_stat_get_db_tuples_inserted },
+  { 2761, "pg_stat_get_db_tuples_updated", 1, true, false, pg_stat_get_db_tuples_updated },
+  { 2762, "pg_stat_get_db_tuples_deleted", 1, true, false, pg_stat_get_db_tuples_deleted },
+  { 2763, "regexp_matches_no_flags", 2, true, true, regexp_matches_no_flags },
+  { 2764, "regexp_matches", 3, true, true, regexp_matches },
+  { 2765, "regexp_split_to_table_no_flags", 2, true, true, regexp_split_to_table_no_flags },
+  { 2766, "regexp_split_to_table", 3, true, true, regexp_split_to_table },
+  { 2767, "regexp_split_to_array_no_flags", 2, true, false, regexp_split_to_array_no_flags },
+  { 2768, "regexp_split_to_array", 3, true, false, regexp_split_to_array },
+  { 2769, "pg_stat_get_bgwriter_timed_checkpoints", 0, true, false, pg_stat_get_bgwriter_timed_checkpoints },
+  { 2770, "pg_stat_get_bgwriter_requested_checkpoints", 0, true, false, pg_stat_get_bgwriter_requested_checkpoints },
+  { 2771, "pg_stat_get_bgwriter_buf_written_checkpoints", 0, true, false, pg_stat_get_bgwriter_buf_written_checkpoints },
+  { 2772, "pg_stat_get_bgwriter_buf_written_clean", 0, true, false, pg_stat_get_bgwriter_buf_written_clean },
+  { 2773, "pg_stat_get_bgwriter_maxwritten_clean", 0, true, false, pg_stat_get_bgwriter_maxwritten_clean },
+  { 2774, "ginqueryarrayextract", 5, true, false, ginqueryarrayextract },
+  { 2775, "pg_stat_get_buf_written_backend", 0, true, false, pg_stat_get_buf_written_backend },
+  { 2777, "anynonarray_in", 1, true, false, anynonarray_in },
+  { 2778, "anynonarray_out", 1, true, false, anynonarray_out },
+  { 2781, "pg_stat_get_last_vacuum_time", 1, true, false, pg_stat_get_last_vacuum_time },
+  { 2782, "pg_stat_get_last_autovacuum_time", 1, true, false, pg_stat_get_last_autovacuum_time },
+  { 2783, "pg_stat_get_last_analyze_time", 1, true, false, pg_stat_get_last_analyze_time },
+  { 2784, "pg_stat_get_last_autoanalyze_time", 1, true, false, pg_stat_get_last_autoanalyze_time },
+  { 2785, "btoptions", 2, true, false, btoptions },
+  { 2786, "hashoptions", 2, true, false, hashoptions },
+  { 2787, "gistoptions", 2, true, false, gistoptions },
+  { 2788, "ginoptions", 2, true, false, ginoptions },
+  { 2790, "tidgt", 2, true, false, tidgt },
+  { 2791, "tidlt", 2, true, false, tidlt },
+  { 2792, "tidge", 2, true, false, tidge },
+  { 2793, "tidle", 2, true, false, tidle },
+  { 2794, "bttidcmp", 2, true, false, bttidcmp },
+  { 2795, "tidlarger", 2, true, false, tidlarger },
+  { 2796, "tidsmaller", 2, true, false, tidsmaller },
+  { 2797, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2798, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2803, "aggregate_dummy", 0, false, false, aggregate_dummy },
+  { 2804, "int8inc_any", 2, true, false, int8inc_any },
+  { 2805, "int8inc_float8_float8", 3, true, false, int8inc_float8_float8 },
+  { 2806, "float8_regr_accum", 3, true, false, float8_regr_accum },
+  { 2807, "float8_regr_sxx", 1, true, false, float8_regr_sxx },
+  { 2808, "float8_regr_syy", 1, true, false, float8_regr_syy },
+  { 2809, "float8_regr_sxy", 1, true, false, float8_regr_sxy },
+  { 2810, "float8_regr_avgx", 1, true, false, float8_regr_avgx },
+  { 2811, "float8_regr_avgy", 1, true, false, float8_regr_avgy },
+  { 2812, "float8_regr_r2", 1, true, false, float8_regr_r2 },
+  { 2813, "float8_regr_slope", 1, true, false, float8_regr_slope },
+  { 2814, "float8_regr_intercept", 1, true, false, float8_regr_intercept },
+  { 2815, "float8_covar_pop", 1, true, false, float8_covar_pop },
+  { 2816, "float8_covar_samp", 1, true, false, float8_covar_samp },
+  { 2817, "float8_corr", 1, true, false, float8_corr },
+  { 2818, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2819, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2820, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2821, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2822, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2823, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2824, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2825, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2826, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2827, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2828, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2829, "aggregate_dummy", 2, false, false, aggregate_dummy },
+  { 2848, "pg_switch_xlog", 0, true, false, pg_switch_xlog },
+  { 2849, "pg_current_xlog_location", 0, true, false, pg_current_xlog_location },
+  { 2850, "pg_xlogfile_name_offset", 1, true, false, pg_xlogfile_name_offset },
+  { 2851, "pg_xlogfile_name", 1, true, false, pg_xlogfile_name },
+  { 2852, "pg_current_xlog_insert_location", 0, true, false, pg_current_xlog_insert_location },
+  { 2853, "pg_stat_get_backend_waiting", 1, true, false, pg_stat_get_backend_waiting },
+  { 2854, "pg_my_temp_schema", 0, true, false, pg_my_temp_schema },
+  { 2855, "pg_is_other_temp_schema", 1, true, false, pg_is_other_temp_schema },
+  { 2856, "pg_timezone_names", 0, true, true, pg_timezone_names },
+  { 2857, "pg_stat_get_backend_xact_start", 1, true, false, pg_stat_get_backend_xact_start },
+  { 2858, "numeric_avg_accum", 2, true, false, numeric_avg_accum },
+  { 2859, "pg_stat_get_buf_alloc", 0, true, false, pg_stat_get_buf_alloc },
+  { 2878, "pg_stat_get_live_tuples", 1, true, false, pg_stat_get_live_tuples },
+  { 2879, "pg_stat_get_dead_tuples", 1, true, false, pg_stat_get_dead_tuples },
+  { 2880, "pg_advisory_lock_int8", 1, true, false, pg_advisory_lock_int8 },
+  { 2881, "pg_advisory_lock_shared_int8", 1, true, false, pg_advisory_lock_shared_int8 },
+  { 2882, "pg_try_advisory_lock_int8", 1, true, false, pg_try_advisory_lock_int8 },
+  { 2883, "pg_try_advisory_lock_shared_int8", 1, true, false, pg_try_advisory_lock_shared_int8 },
+  { 2884, "pg_advisory_unlock_int8", 1, true, false, pg_advisory_unlock_int8 },
+  { 2885, "pg_advisory_unlock_shared_int8", 1, true, false, pg_advisory_unlock_shared_int8 },
+  { 2886, "pg_advisory_lock_int4", 2, true, false, pg_advisory_lock_int4 },
+  { 2887, "pg_advisory_lock_shared_int4", 2, true, false, pg_advisory_lock_shared_int4 },
+  { 2888, "pg_try_advisory_lock_int4", 2, true, false, pg_try_advisory_lock_int4 },
+  { 2889, "pg_try_advisory_lock_shared_int4", 2, true, false, pg_try_advisory_lock_shared_int4 },
+  { 2890, "pg_advisory_unlock_int4", 2, true, false, pg_advisory_unlock_int4 },
+  { 2891, "pg_advisory_unlock_shared_int4", 2, true, false, pg_advisory_unlock_shared_int4 },
+  { 2892, "pg_advisory_unlock_all", 0, true, false, pg_advisory_unlock_all },
+  { 2893, "xml_in", 1, true, false, xml_in },
+  { 2894, "xml_out", 1, true, false, xml_out },
+  { 2895, "xmlcomment", 1, true, false, xmlcomment },
+  { 2896, "texttoxml", 1, true, false, texttoxml },
+  { 2897, "xmlvalidate", 2, true, false, xmlvalidate },
+  { 2898, "xml_recv", 1, true, false, xml_recv },
+  { 2899, "xml_send", 1, true, false, xml_send },
+  { 2900, "xmlconcat2", 2, false, false, xmlconcat2 },
+  { 2901, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 2902, "varbittypmodin", 1, true, false, varbittypmodin },
+  { 2903, "intervaltypmodin", 1, true, false, intervaltypmodin },
+  { 2904, "intervaltypmodout", 1, true, false, intervaltypmodout },
+  { 2905, "timestamptypmodin", 1, true, false, timestamptypmodin },
+  { 2906, "timestamptypmodout", 1, true, false, timestamptypmodout },
+  { 2907, "timestamptztypmodin", 1, true, false, timestamptztypmodin },
+  { 2908, "timestamptztypmodout", 1, true, false, timestamptztypmodout },
+  { 2909, "timetypmodin", 1, true, false, timetypmodin },
+  { 2910, "timetypmodout", 1, true, false, timetypmodout },
+  { 2911, "timetztypmodin", 1, true, false, timetztypmodin },
+  { 2912, "timetztypmodout", 1, true, false, timetztypmodout },
+  { 2913, "bpchartypmodin", 1, true, false, bpchartypmodin },
+  { 2914, "bpchartypmodout", 1, true, false, bpchartypmodout },
+  { 2915, "varchartypmodin", 1, true, false, varchartypmodin },
+  { 2916, "varchartypmodout", 1, true, false, varchartypmodout },
+  { 2917, "numerictypmodin", 1, true, false, numerictypmodin },
+  { 2918, "numerictypmodout", 1, true, false, numerictypmodout },
+  { 2919, "bittypmodin", 1, true, false, bittypmodin },
+  { 2920, "bittypmodout", 1, true, false, bittypmodout },
+  { 2921, "varbittypmodout", 1, true, false, varbittypmodout },
+  { 2922, "xmltotext", 1, true, false, xmltotext },
+  { 2923, "table_to_xml", 4, true, false, table_to_xml },
+  { 2924, "query_to_xml", 4, true, false, query_to_xml },
+  { 2925, "cursor_to_xml", 5, true, false, cursor_to_xml },
+  { 2926, "table_to_xmlschema", 4, true, false, table_to_xmlschema },
+  { 2927, "query_to_xmlschema", 4, true, false, query_to_xmlschema },
+  { 2928, "cursor_to_xmlschema", 4, true, false, cursor_to_xmlschema },
+  { 2929, "table_to_xml_and_xmlschema", 4, true, false, table_to_xml_and_xmlschema },
+  { 2930, "query_to_xml_and_xmlschema", 4, true, false, query_to_xml_and_xmlschema },
+  { 2931, "xpath", 3, true, false, xpath },
+  { 2933, "schema_to_xml", 4, true, false, schema_to_xml },
+  { 2934, "schema_to_xmlschema", 4, true, false, schema_to_xmlschema },
+  { 2935, "schema_to_xml_and_xmlschema", 4, true, false, schema_to_xml_and_xmlschema },
+  { 2936, "database_to_xml", 3, true, false, database_to_xml },
+  { 2937, "database_to_xmlschema", 3, true, false, database_to_xmlschema },
+  { 2938, "database_to_xml_and_xmlschema", 3, true, false, database_to_xml_and_xmlschema },
+  { 2939, "txid_snapshot_in", 1, true, false, txid_snapshot_in },
+  { 2940, "txid_snapshot_out", 1, true, false, txid_snapshot_out },
+  { 2941, "txid_snapshot_recv", 1, true, false, txid_snapshot_recv },
+  { 2942, "txid_snapshot_send", 1, true, false, txid_snapshot_send },
+  { 2943, "txid_current", 0, true, false, txid_current },
+  { 2944, "txid_current_snapshot", 0, true, false, txid_current_snapshot },
+  { 2945, "txid_snapshot_xmin", 1, true, false, txid_snapshot_xmin },
+  { 2946, "txid_snapshot_xmax", 1, true, false, txid_snapshot_xmax },
+  { 2947, "txid_snapshot_xip", 1, true, true, txid_snapshot_xip },
+  { 2948, "txid_visible_in_snapshot", 2, true, false, txid_visible_in_snapshot },
+  { 2952, "uuid_in", 1, true, false, uuid_in },
+  { 2953, "uuid_out", 1, true, false, uuid_out },
+  { 2954, "uuid_lt", 2, true, false, uuid_lt },
+  { 2955, "uuid_le", 2, true, false, uuid_le },
+  { 2956, "uuid_eq", 2, true, false, uuid_eq },
+  { 2957, "uuid_ge", 2, true, false, uuid_ge },
+  { 2958, "uuid_gt", 2, true, false, uuid_gt },
+  { 2959, "uuid_ne", 2, true, false, uuid_ne },
+  { 2960, "uuid_cmp", 2, true, false, uuid_cmp },
+  { 2961, "uuid_recv", 1, true, false, uuid_recv },
+  { 2962, "uuid_send", 1, true, false, uuid_send },
+  { 2963, "uuid_hash", 1, true, false, uuid_hash },
+  { 2971, "booltext", 1, true, false, booltext },
+  { 2978, "pg_stat_get_function_calls", 1, true, false, pg_stat_get_function_calls },
+  { 2979, "pg_stat_get_function_time", 1, true, false, pg_stat_get_function_time },
+  { 2980, "pg_stat_get_function_self_time", 1, true, false, pg_stat_get_function_self_time },
+  { 2981, "record_eq", 2, true, false, record_eq },
+  { 2982, "record_ne", 2, true, false, record_ne },
+  { 2983, "record_lt", 2, true, false, record_lt },
+  { 2984, "record_gt", 2, true, false, record_gt },
+  { 2985, "record_le", 2, true, false, record_le },
+  { 2986, "record_ge", 2, true, false, record_ge },
+  { 2987, "btrecordcmp", 2, true, false, btrecordcmp },
+  { 3000, "has_foreign_data_wrapper_privilege_name_name", 3, true, false, has_foreign_data_wrapper_privilege_name_name },
+  { 3001, "has_foreign_data_wrapper_privilege_name_id", 3, true, false, has_foreign_data_wrapper_privilege_name_id },
+  { 3002, "has_foreign_data_wrapper_privilege_id_name", 3, true, false, has_foreign_data_wrapper_privilege_id_name },
+  { 3003, "has_foreign_data_wrapper_privilege_id_id", 3, true, false, has_foreign_data_wrapper_privilege_id_id },
+  { 3004, "has_foreign_data_wrapper_privilege_name", 2, true, false, has_foreign_data_wrapper_privilege_name },
+  { 3005, "has_foreign_data_wrapper_privilege_id", 2, true, false, has_foreign_data_wrapper_privilege_id },
+  { 3006, "has_server_privilege_name_name", 3, true, false, has_server_privilege_name_name },
+  { 3007, "has_server_privilege_name_id", 3, true, false, has_server_privilege_name_id },
+  { 3008, "has_server_privilege_id_name", 3, true, false, has_server_privilege_id_name },
+  { 3009, "has_server_privilege_id_id", 3, true, false, has_server_privilege_id_id },
+  { 3010, "has_server_privilege_name", 2, true, false, has_server_privilege_name },
+  { 3011, "has_server_privilege_id", 2, true, false, has_server_privilege_id },
+  { 3012, "has_column_privilege_name_name_name", 4, true, false, has_column_privilege_name_name_name },
+  { 3013, "has_column_privilege_name_name_attnum", 4, true, false, has_column_privilege_name_name_attnum },
+  { 3014, "has_column_privilege_name_id_name", 4, true, false, has_column_privilege_name_id_name },
+  { 3015, "has_column_privilege_name_id_attnum", 4, true, false, has_column_privilege_name_id_attnum },
+  { 3016, "has_column_privilege_id_name_name", 4, true, false, has_column_privilege_id_name_name },
+  { 3017, "has_column_privilege_id_name_attnum", 4, true, false, has_column_privilege_id_name_attnum },
+  { 3018, "has_column_privilege_id_id_name", 4, true, false, has_column_privilege_id_id_name },
+  { 3019, "has_column_privilege_id_id_attnum", 4, true, false, has_column_privilege_id_id_attnum },
+  { 3020, "has_column_privilege_name_name", 3, true, false, has_column_privilege_name_name },
+  { 3021, "has_column_privilege_name_attnum", 3, true, false, has_column_privilege_name_attnum },
+  { 3022, "has_column_privilege_id_name", 3, true, false, has_column_privilege_id_name },
+  { 3023, "has_column_privilege_id_attnum", 3, true, false, has_column_privilege_id_attnum },
+  { 3024, "has_any_column_privilege_name_name", 3, true, false, has_any_column_privilege_name_name },
+  { 3025, "has_any_column_privilege_name_id", 3, true, false, has_any_column_privilege_name_id },
+  { 3026, "has_any_column_privilege_id_name", 3, true, false, has_any_column_privilege_id_name },
+  { 3027, "has_any_column_privilege_id_id", 3, true, false, has_any_column_privilege_id_id },
+  { 3028, "has_any_column_privilege_name", 2, true, false, has_any_column_privilege_name },
+  { 3029, "has_any_column_privilege_id", 2, true, false, has_any_column_privilege_id },
+  { 3100, "window_row_number", 0, false, false, window_row_number },
+  { 3101, "window_rank", 0, false, false, window_rank },
+  { 3102, "window_dense_rank", 0, false, false, window_dense_rank },
+  { 3103, "window_percent_rank", 0, false, false, window_percent_rank },
+  { 3104, "window_cume_dist", 0, false, false, window_cume_dist },
+  { 3105, "window_ntile", 1, true, false, window_ntile },
+  { 3106, "window_lag", 1, true, false, window_lag },
+  { 3107, "window_lag_with_offset", 2, true, false, window_lag_with_offset },
+  { 3108, "window_lag_with_offset_and_default", 3, true, false, window_lag_with_offset_and_default },
+  { 3109, "window_lead", 1, true, false, window_lead },
+  { 3110, "window_lead_with_offset", 2, true, false, window_lead_with_offset },
+  { 3111, "window_lead_with_offset_and_default", 3, true, false, window_lead_with_offset_and_default },
+  { 3112, "window_first_value", 1, true, false, window_first_value },
+  { 3113, "window_last_value", 1, true, false, window_last_value },
+  { 3114, "window_nth_value", 2, true, false, window_nth_value },
+  { 3504, "anyenum_in", 1, true, false, anyenum_in },
+  { 3505, "anyenum_out", 1, true, false, anyenum_out },
+  { 3506, "enum_in", 2, true, false, enum_in },
+  { 3507, "enum_out", 1, true, false, enum_out },
+  { 3508, "enum_eq", 2, true, false, enum_eq },
+  { 3509, "enum_ne", 2, true, false, enum_ne },
+  { 3510, "enum_lt", 2, true, false, enum_lt },
+  { 3511, "enum_gt", 2, true, false, enum_gt },
+  { 3512, "enum_le", 2, true, false, enum_le },
+  { 3513, "enum_ge", 2, true, false, enum_ge },
+  { 3514, "enum_cmp", 2, true, false, enum_cmp },
+  { 3515, "hashenum", 1, true, false, hashenum },
+  { 3524, "enum_smaller", 2, true, false, enum_smaller },
+  { 3525, "enum_larger", 2, true, false, enum_larger },
+  { 3526, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 3527, "aggregate_dummy", 1, false, false, aggregate_dummy },
+  { 3528, "enum_first", 1, false, false, enum_first },
+  { 3529, "enum_last", 1, false, false, enum_last },
+  { 3530, "enum_range_bounds", 2, false, false, enum_range_bounds },
+  { 3531, "enum_range_all", 1, false, false, enum_range_all },
+  { 3532, "enum_recv", 2, true, false, enum_recv },
+  { 3533, "enum_send", 1, true, false, enum_send },
+  { 3610, "tsvectorin", 1, true, false, tsvectorin },
+  { 3611, "tsvectorout", 1, true, false, tsvectorout },
+  { 3612, "tsqueryin", 1, true, false, tsqueryin },
+  { 3613, "tsqueryout", 1, true, false, tsqueryout },
+  { 3616, "tsvector_lt", 2, true, false, tsvector_lt },
+  { 3617, "tsvector_le", 2, true, false, tsvector_le },
+  { 3618, "tsvector_eq", 2, true, false, tsvector_eq },
+  { 3619, "tsvector_ne", 2, true, false, tsvector_ne },
+  { 3620, "tsvector_ge", 2, true, false, tsvector_ge },
+  { 3621, "tsvector_gt", 2, true, false, tsvector_gt },
+  { 3622, "tsvector_cmp", 2, true, false, tsvector_cmp },
+  { 3623, "tsvector_strip", 1, true, false, tsvector_strip },
+  { 3624, "tsvector_setweight", 2, true, false, tsvector_setweight },
+  { 3625, "tsvector_concat", 2, true, false, tsvector_concat },
+  { 3634, "ts_match_vq", 2, true, false, ts_match_vq },
+  { 3635, "ts_match_qv", 2, true, false, ts_match_qv },
+  { 3638, "tsvectorsend", 1, true, false, tsvectorsend },
+  { 3639, "tsvectorrecv", 1, true, false, tsvectorrecv },
+  { 3640, "tsquerysend", 1, true, false, tsquerysend },
+  { 3641, "tsqueryrecv", 1, true, false, tsqueryrecv },
+  { 3646, "gtsvectorin", 1, true, false, gtsvectorin },
+  { 3647, "gtsvectorout", 1, true, false, gtsvectorout },
+  { 3648, "gtsvector_compress", 1, true, false, gtsvector_compress },
+  { 3649, "gtsvector_decompress", 1, true, false, gtsvector_decompress },
+  { 3650, "gtsvector_picksplit", 2, true, false, gtsvector_picksplit },
+  { 3651, "gtsvector_union", 2, true, false, gtsvector_union },
+  { 3652, "gtsvector_same", 3, true, false, gtsvector_same },
+  { 3653, "gtsvector_penalty", 3, true, false, gtsvector_penalty },
+  { 3654, "gtsvector_consistent", 5, true, false, gtsvector_consistent },
+  { 3656, "gin_extract_tsvector", 2, true, false, gin_extract_tsvector },
+  { 3657, "gin_extract_tsquery", 5, true, false, gin_extract_tsquery },
+  { 3658, "gin_tsquery_consistent", 6, true, false, gin_tsquery_consistent },
+  { 3662, "tsquery_lt", 2, true, false, tsquery_lt },
+  { 3663, "tsquery_le", 2, true, false, tsquery_le },
+  { 3664, "tsquery_eq", 2, true, false, tsquery_eq },
+  { 3665, "tsquery_ne", 2, true, false, tsquery_ne },
+  { 3666, "tsquery_ge", 2, true, false, tsquery_ge },
+  { 3667, "tsquery_gt", 2, true, false, tsquery_gt },
+  { 3668, "tsquery_cmp", 2, true, false, tsquery_cmp },
+  { 3669, "tsquery_and", 2, true, false, tsquery_and },
+  { 3670, "tsquery_or", 2, true, false, tsquery_or },
+  { 3671, "tsquery_not", 1, true, false, tsquery_not },
+  { 3672, "tsquery_numnode", 1, true, false, tsquery_numnode },
+  { 3673, "tsquerytree", 1, true, false, tsquerytree },
+  { 3684, "tsquery_rewrite", 3, true, false, tsquery_rewrite },
+  { 3685, "tsquery_rewrite_query", 2, true, false, tsquery_rewrite_query },
+  { 3686, "tsmatchsel", 4, true, false, tsmatchsel },
+  { 3687, "tsmatchjoinsel", 5, true, false, tsmatchjoinsel },
+  { 3688, "ts_typanalyze", 1, true, false, ts_typanalyze },
+  { 3689, "ts_stat1", 1, true, true, ts_stat1 },
+  { 3690, "ts_stat2", 2, true, true, ts_stat2 },
+  { 3691, "tsq_mcontains", 2, true, false, tsq_mcontains },
+  { 3692, "tsq_mcontained", 2, true, false, tsq_mcontained },
+  { 3695, "gtsquery_compress", 1, true, false, gtsquery_compress },
+  { 3696, "gtsquery_decompress", 1, true, false, gtsquery_decompress },
+  { 3697, "gtsquery_picksplit", 2, true, false, gtsquery_picksplit },
+  { 3698, "gtsquery_union", 2, true, false, gtsquery_union },
+  { 3699, "gtsquery_same", 3, true, false, gtsquery_same },
+  { 3700, "gtsquery_penalty", 3, true, false, gtsquery_penalty },
+  { 3701, "gtsquery_consistent", 5, true, false, gtsquery_consistent },
+  { 3703, "ts_rank_wttf", 4, true, false, ts_rank_wttf },
+  { 3704, "ts_rank_wtt", 3, true, false, ts_rank_wtt },
+  { 3705, "ts_rank_ttf", 3, true, false, ts_rank_ttf },
+  { 3706, "ts_rank_tt", 2, true, false, ts_rank_tt },
+  { 3707, "ts_rankcd_wttf", 4, true, false, ts_rankcd_wttf },
+  { 3708, "ts_rankcd_wtt", 3, true, false, ts_rankcd_wtt },
+  { 3709, "ts_rankcd_ttf", 3, true, false, ts_rankcd_ttf },
+  { 3710, "ts_rankcd_tt", 2, true, false, ts_rankcd_tt },
+  { 3711, "tsvector_length", 1, true, false, tsvector_length },
+  { 3713, "ts_token_type_byid", 1, true, true, ts_token_type_byid },
+  { 3714, "ts_token_type_byname", 1, true, true, ts_token_type_byname },
+  { 3715, "ts_parse_byid", 2, true, true, ts_parse_byid },
+  { 3716, "ts_parse_byname", 2, true, true, ts_parse_byname },
+  { 3717, "prsd_start", 2, true, false, prsd_start },
+  { 3718, "prsd_nexttoken", 3, true, false, prsd_nexttoken },
+  { 3719, "prsd_end", 1, true, false, prsd_end },
+  { 3720, "prsd_headline", 3, true, false, prsd_headline },
+  { 3721, "prsd_lextype", 1, true, false, prsd_lextype },
+  { 3723, "ts_lexize", 2, true, false, ts_lexize },
+  { 3724, "gin_cmp_tslexeme", 2, true, false, gin_cmp_tslexeme },
+  { 3725, "dsimple_init", 1, true, false, dsimple_init },
+  { 3726, "dsimple_lexize", 4, true, false, dsimple_lexize },
+  { 3728, "dsynonym_init", 1, true, false, dsynonym_init },
+  { 3729, "dsynonym_lexize", 4, true, false, dsynonym_lexize },
+  { 3731, "dispell_init", 1, true, false, dispell_init },
+  { 3732, "dispell_lexize", 4, true, false, dispell_lexize },
+  { 3736, "regconfigin", 1, true, false, regconfigin },
+  { 3737, "regconfigout", 1, true, false, regconfigout },
+  { 3738, "regconfigrecv", 1, true, false, regconfigrecv },
+  { 3739, "regconfigsend", 1, true, false, regconfigsend },
+  { 3740, "thesaurus_init", 1, true, false, thesaurus_init },
+  { 3741, "thesaurus_lexize", 4, true, false, thesaurus_lexize },
+  { 3743, "ts_headline_byid_opt", 4, true, false, ts_headline_byid_opt },
+  { 3744, "ts_headline_byid", 3, true, false, ts_headline_byid },
+  { 3745, "to_tsvector_byid", 2, true, false, to_tsvector_byid },
+  { 3746, "to_tsquery_byid", 2, true, false, to_tsquery_byid },
+  { 3747, "plainto_tsquery_byid", 2, true, false, plainto_tsquery_byid },
+  { 3749, "to_tsvector", 1, true, false, to_tsvector },
+  { 3750, "to_tsquery", 1, true, false, to_tsquery },
+  { 3751, "plainto_tsquery", 1, true, false, plainto_tsquery },
+  { 3752, "tsvector_update_trigger_byid", 0, false, false, tsvector_update_trigger_byid },
+  { 3753, "tsvector_update_trigger_bycolumn", 0, false, false, tsvector_update_trigger_bycolumn },
+  { 3754, "ts_headline_opt", 3, true, false, ts_headline_opt },
+  { 3755, "ts_headline", 2, true, false, ts_headline },
+  { 3756, "pg_ts_parser_is_visible", 1, true, false, pg_ts_parser_is_visible },
+  { 3757, "pg_ts_dict_is_visible", 1, true, false, pg_ts_dict_is_visible },
+  { 3758, "pg_ts_config_is_visible", 1, true, false, pg_ts_config_is_visible },
+  { 3759, "get_current_ts_config", 0, true, false, get_current_ts_config },
+  { 3760, "ts_match_tt", 2, true, false, ts_match_tt },
+  { 3761, "ts_match_tq", 2, true, false, ts_match_tq },
+  { 3768, "pg_ts_template_is_visible", 1, true, false, pg_ts_template_is_visible },
+  { 3771, "regdictionaryin", 1, true, false, regdictionaryin },
+  { 3772, "regdictionaryout", 1, true, false, regdictionaryout },
+  { 3773, "regdictionaryrecv", 1, true, false, regdictionaryrecv },
+  { 3774, "regdictionarysend", 1, true, false, regdictionarysend },
+  /* dummy entry is easier than getting rid of comma after last real one */
+  /* (not that there has ever been anything wrong with *having* a
+     comma after the last field in an array initializer) */
+  { 0, NULL, 0, false, false, NULL }
+};
+
+/* Note fmgr_nbuiltins excludes the dummy entry */
+const int fmgr_nbuiltins = (sizeof(fmgr_builtins) / sizeof(FmgrBuiltin)) - 1;
diff --git a/src/backend/utils/probes.h b/src/backend/utils/probes.h
new file mode 100644
index 0000000..5353af9
--- /dev/null
+++ b/src/backend/utils/probes.h
@@ -0,0 +1,110 @@
+#define TRACE_POSTGRESQL_TRANSACTION_START(INT1)
+#define TRACE_POSTGRESQL_TRANSACTION_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_TRANSACTION_COMMIT(INT1)
+#define TRACE_POSTGRESQL_TRANSACTION_COMMIT_ENABLED() (0)
+#define TRACE_POSTGRESQL_TRANSACTION_ABORT(INT1)
+#define TRACE_POSTGRESQL_TRANSACTION_ABORT_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_ACQUIRE(INT1, INT2)
+#define TRACE_POSTGRESQL_LWLOCK_ACQUIRE_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_RELEASE(INT1)
+#define TRACE_POSTGRESQL_LWLOCK_RELEASE_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_WAIT_START(INT1, INT2)
+#define TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(INT1, INT2)
+#define TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE(INT1, INT2)
+#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED() (0)
+#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(INT1, INT2)
+#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED() (0)
+#define TRACE_POSTGRESQL_LOCK_WAIT_START(INT1, INT2, INT3, INT4, INT5, INT6)
+#define TRACE_POSTGRESQL_LOCK_WAIT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_LOCK_WAIT_DONE(INT1, INT2, INT3, INT4, INT5, INT6)
+#define TRACE_POSTGRESQL_LOCK_WAIT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_PARSE_START(INT1)
+#define TRACE_POSTGRESQL_QUERY_PARSE_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_PARSE_DONE(INT1)
+#define TRACE_POSTGRESQL_QUERY_PARSE_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_REWRITE_START(INT1)
+#define TRACE_POSTGRESQL_QUERY_REWRITE_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_REWRITE_DONE(INT1)
+#define TRACE_POSTGRESQL_QUERY_REWRITE_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_PLAN_START()
+#define TRACE_POSTGRESQL_QUERY_PLAN_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_PLAN_DONE()
+#define TRACE_POSTGRESQL_QUERY_PLAN_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_EXECUTE_START()
+#define TRACE_POSTGRESQL_QUERY_EXECUTE_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_EXECUTE_DONE()
+#define TRACE_POSTGRESQL_QUERY_EXECUTE_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_START(INT1)
+#define TRACE_POSTGRESQL_QUERY_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_QUERY_DONE(INT1)
+#define TRACE_POSTGRESQL_QUERY_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_STATEMENT_STATUS(INT1)
+#define TRACE_POSTGRESQL_STATEMENT_STATUS_ENABLED() (0)
+#define TRACE_POSTGRESQL_SORT_START(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_SORT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_SORT_DONE(INT1, INT2)
+#define TRACE_POSTGRESQL_SORT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_READ_START(INT1, INT2, INT3, INT4, INT5, INT6, INT7)
+#define TRACE_POSTGRESQL_BUFFER_READ_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_READ_DONE(INT1, INT2, INT3, INT4, INT5, INT6, INT7, INT8)
+#define TRACE_POSTGRESQL_BUFFER_READ_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_FLUSH_START(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_BUFFER_FLUSH_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_FLUSH_DONE(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_BUFFER_FLUSH_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START(INT1)
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START()
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE()
+#define TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_START(INT1, INT2)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN(INT1)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_DONE(INT1, INT2, INT3)
+#define TRACE_POSTGRESQL_BUFFER_SYNC_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_DEADLOCK_FOUND()
+#define TRACE_POSTGRESQL_DEADLOCK_FOUND_ENABLED() (0)
+#define TRACE_POSTGRESQL_CHECKPOINT_START(INT1)
+#define TRACE_POSTGRESQL_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_CHECKPOINT_DONE(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_CLOG_CHECKPOINT_START(INT1)
+#define TRACE_POSTGRESQL_CLOG_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_CLOG_CHECKPOINT_DONE(INT1)
+#define TRACE_POSTGRESQL_CLOG_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_START(INT1)
+#define TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_DONE(INT1)
+#define TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START(INT1)
+#define TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE(INT1)
+#define TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_START()
+#define TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_DONE()
+#define TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_SMGR_MD_READ_START(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_SMGR_MD_READ_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_SMGR_MD_READ_DONE(INT1, INT2, INT3, INT4, INT5, INT6, INT7)
+#define TRACE_POSTGRESQL_SMGR_MD_READ_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_SMGR_MD_WRITE_START(INT1, INT2, INT3, INT4, INT5)
+#define TRACE_POSTGRESQL_SMGR_MD_WRITE_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE(INT1, INT2, INT3, INT4, INT5, INT6, INT7)
+#define TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE_ENABLED() (0)
+#define TRACE_POSTGRESQL_XLOG_INSERT(INT1, INT2)
+#define TRACE_POSTGRESQL_XLOG_INSERT_ENABLED() (0)
+#define TRACE_POSTGRESQL_XLOG_SWITCH()
+#define TRACE_POSTGRESQL_XLOG_SWITCH_ENABLED() (0)
+#define TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_START()
+#define TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_START_ENABLED() (0)
+#define TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_DONE()
+#define TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_DONE_ENABLED() (0)
diff --git a/src/bin/psql/Android.mk b/src/bin/psql/Android.mk
new file mode 100644
index 0000000..04540f7
--- /dev/null
+++ b/src/bin/psql/Android.mk
@@ -0,0 +1,27 @@
+# check out the 'android build cookbook' page
+# for some good definitions
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/Config.mk
+
+LOCAL_MODULE:= psql
+
+LOCAL_ARM_MODE:= arm
+
+LOCAL_REQUIRED_MODULES:= libssl libcrypto libpq libz \
+	libpgport
+LOCAL_SHARED_LIBRARIES:= libssl libcrypto libpq libz
+LOCAL_STATIC_LIBRARIES:= libpgport
+
+LOCAL_LDLIBS := -L$(LOCAL_PATH)/../../../../openssl-android/libs/armeabi -lssl -lcrypto
+
+LOCAL_SRC_FILES:= $(SRC_FILES) 
+
+LOCAL_CFLAGS:= -I$(LOCAL_PATH) \
+	-I$(LOCAL_PATH)/../../interfaces/libpq \
+	-I$(LOCAL_PATH)/../pg_dump \
+	-I$(LOCAL_PATH)/../../include \
+	-I$(LOCAL_PATH)/../../../../openssl-android/include
+
+include $(BUILD_EXECUTABLE)
diff --git a/src/bin/psql/Config.mk b/src/bin/psql/Config.mk
new file mode 100644
index 0000000..069d80c
--- /dev/null
+++ b/src/bin/psql/Config.mk
@@ -0,0 +1,7 @@
+LOCAL_PATH:= $(call my-dir)
+
+SRC_FILES:= command.c common.c help.c input.c \
+	stringutils.c mainloop.c copy.c startup.c \
+	prompt.c variables.c large_obj.c print.c \
+	describe.c psqlscan.c tab-complete.c mbprint.c \
+	dumputils.c keywords.c kwlookup.c
diff --git a/src/bin/psql/dumputils.c b/src/bin/psql/dumputils.c
new file mode 120000
index 0000000..6ff35b7
--- /dev/null
+++ b/src/bin/psql/dumputils.c
@@ -0,0 +1 @@
+../pg_dump/dumputils.c
\ No newline at end of file
diff --git a/src/bin/psql/dumputils.h b/src/bin/psql/dumputils.h
new file mode 120000
index 0000000..4472412
--- /dev/null
+++ b/src/bin/psql/dumputils.h
@@ -0,0 +1 @@
+../pg_dump/dumputils.h
\ No newline at end of file
diff --git a/src/bin/psql/keywords.c b/src/bin/psql/keywords.c
new file mode 120000
index 0000000..70c1933
--- /dev/null
+++ b/src/bin/psql/keywords.c
@@ -0,0 +1 @@
+../pg_dump/keywords.c
\ No newline at end of file
diff --git a/src/bin/psql/kwlookup.c b/src/bin/psql/kwlookup.c
new file mode 120000
index 0000000..fcd2364
--- /dev/null
+++ b/src/bin/psql/kwlookup.c
@@ -0,0 +1 @@
+../../backend/parser/kwlookup.c
\ No newline at end of file
diff --git a/src/bin/psql/libpq-fe.h b/src/bin/psql/libpq-fe.h
new file mode 120000
index 0000000..fc8b646
--- /dev/null
+++ b/src/bin/psql/libpq-fe.h
@@ -0,0 +1 @@
+../../interfaces/libpq/libpq-fe.h
\ No newline at end of file
diff --git a/src/bin/psql/pqexpbuffer.h b/src/bin/psql/pqexpbuffer.h
new file mode 120000
index 0000000..09bf8ba
--- /dev/null
+++ b/src/bin/psql/pqexpbuffer.h
@@ -0,0 +1 @@
+../../interfaces/libpq/pqexpbuffer.h
\ No newline at end of file
diff --git a/src/bin/psql/pqsignal.h b/src/bin/psql/pqsignal.h
new file mode 120000
index 0000000..e9379ef
--- /dev/null
+++ b/src/bin/psql/pqsignal.h
@@ -0,0 +1 @@
+../../include/libpq/pqsignal.h
\ No newline at end of file
diff --git a/src/bin/psql/print.c b/src/bin/psql/print.c
index 8c4ff0c..ef434ed 100644
--- a/src/bin/psql/print.c
+++ b/src/bin/psql/print.c
@@ -2305,31 +2305,32 @@ printQuery(const PGresult *result, const printQueryOpt *opt, FILE *fout, FILE *f
 	printTableCleanup(&cont);
 }
 
-
+// TODO: this will never be fixed in Android
 void
 setDecimalLocale(void)
 {
-	struct lconv *extlconv;
+	//struct lconv *extlconv;
 
-	extlconv = localeconv();
+	//extlconv = localeconv();
 
-	if (*extlconv->decimal_point)
-		decimal_point = pg_strdup(extlconv->decimal_point);
-	else
+//	if (*extlconv->decimal_point)
+//		decimal_point = pg_strdup(extlconv->decimal_point);
+//	else
 		decimal_point = ".";	/* SQL output standard */
-	if (*extlconv->grouping && atoi(extlconv->grouping) > 0)
-		grouping = pg_strdup(extlconv->grouping);
-	else
+//	if (*extlconv->grouping && atoi(extlconv->grouping) > 0)
+//		grouping = pg_strdup(extlconv->grouping);
+//	else
 		grouping = "3";			/* most common */
 
 	/* similar code exists in formatting.c */
-	if (*extlconv->thousands_sep)
-		thousands_sep = pg_strdup(extlconv->thousands_sep);
-	/* Make sure thousands separator doesn't match decimal point symbol. */
-	else if (strcmp(decimal_point, ",") != 0)
-		thousands_sep = ",";
-	else
-		thousands_sep = ".";
+//	if (*extlconv->thousands_sep)
+//		thousands_sep = pg_strdup(extlconv->thousands_sep);
+//	/* Make sure thousands separator doesn't match decimal point symbol. */
+//	else if (strcmp(decimal_point, ",") != 0)
+//		thousands_sep = ",";
+//	else
+//		thousands_sep = ".";
+	thousands_sep = "";
 }
 
 /*
diff --git a/src/bin/psql/print.c.orig b/src/bin/psql/print.c.orig
new file mode 100644
index 0000000..8c4ff0c
--- /dev/null
+++ b/src/bin/psql/print.c.orig
@@ -0,0 +1,2368 @@
+/*
+ * psql - the PostgreSQL interactive terminal
+ *
+ * Copyright (c) 2000-2009, PostgreSQL Global Development Group
+ *
+ * $PostgreSQL: pgsql/src/bin/psql/print.c,v 1.116.2.5 2010/05/09 18:17:52 tgl Exp $
+ */
+#include "postgres_fe.h"
+
+#include <limits.h>
+#include <math.h>
+#include <signal.h>
+#include <unistd.h>
+
+#ifndef WIN32
+#include <sys/ioctl.h>			/* for ioctl() */
+#endif
+
+#ifdef HAVE_TERMIOS_H
+#include <termios.h>
+#endif
+
+#include <locale.h>
+
+#include "catalog/pg_type.h"
+#include "pqsignal.h"
+
+#include "common.h"
+#include "mbprint.h"
+#include "print.h"
+
+/*
+ * We define the cancel_pressed flag in this file, rather than common.c where
+ * it naturally belongs, because this file is also used by non-psql programs
+ * (see the bin/scripts/ directory).  In those programs cancel_pressed will
+ * never become set and will have no effect.
+ *
+ * Note: print.c's general strategy for when to check cancel_pressed is to do
+ * so at completion of each row of output.
+ */
+volatile bool cancel_pressed = false;
+
+static char *decimal_point;
+static char *grouping;
+static char *thousands_sep;
+
+/* Local functions */
+static int	strlen_max_width(unsigned char *str, int *target_width, int encoding);
+static void IsPagerNeeded(const printTableContent *cont, const int extra_lines,
+			  FILE **fout, bool *is_pager);
+
+
+static void *
+pg_local_malloc(size_t size)
+{
+	void	   *tmp;
+
+	tmp = malloc(size);
+	if (!tmp)
+	{
+		fprintf(stderr, _("out of memory\n"));
+		exit(EXIT_FAILURE);
+	}
+	return tmp;
+}
+
+static void *
+pg_local_calloc(int count, size_t size)
+{
+	void	   *tmp;
+
+	tmp = calloc(count, size);
+	if (!tmp)
+	{
+		fprintf(stderr, _("out of memory\n"));
+		exit(EXIT_FAILURE);
+	}
+	return tmp;
+}
+
+static int
+integer_digits(const char *my_str)
+{
+	int			frac_len;
+
+	if (my_str[0] == '-')
+		my_str++;
+
+	frac_len = strchr(my_str, '.') ? strlen(strchr(my_str, '.')) : 0;
+
+	return strlen(my_str) - frac_len;
+}
+
+/* Return additional length required for locale-aware numeric output */
+static int
+additional_numeric_locale_len(const char *my_str)
+{
+	int			int_len = integer_digits(my_str),
+				len = 0;
+	int			groupdigits = atoi(grouping);
+
+	if (int_len > 0)
+		/* Don't count a leading separator */
+		len = (int_len / groupdigits - (int_len % groupdigits == 0)) *
+			strlen(thousands_sep);
+
+	if (strchr(my_str, '.') != NULL)
+		len += strlen(decimal_point) - strlen(".");
+
+	return len;
+}
+
+static int
+strlen_with_numeric_locale(const char *my_str)
+{
+	return strlen(my_str) + additional_numeric_locale_len(my_str);
+}
+
+/* Returns the appropriately formatted string in a new allocated block, caller must free */
+static char *
+format_numeric_locale(const char *my_str)
+{
+	int			i,
+				j,
+				int_len = integer_digits(my_str),
+				leading_digits;
+	int			groupdigits = atoi(grouping);
+	int			new_str_start = 0;
+	char	   *new_str = new_str = pg_local_malloc(
+									 strlen_with_numeric_locale(my_str) + 1);
+
+	leading_digits = (int_len % groupdigits != 0) ?
+		int_len % groupdigits : groupdigits;
+
+	if (my_str[0] == '-')		/* skip over sign, affects grouping
+								 * calculations */
+	{
+		new_str[0] = my_str[0];
+		my_str++;
+		new_str_start = 1;
+	}
+
+	for (i = 0, j = new_str_start;; i++, j++)
+	{
+		/* Hit decimal point? */
+		if (my_str[i] == '.')
+		{
+			strcpy(&new_str[j], decimal_point);
+			j += strlen(decimal_point);
+			/* add fractional part */
+			strcpy(&new_str[j], &my_str[i] + 1);
+			break;
+		}
+
+		/* End of string? */
+		if (my_str[i] == '\0')
+		{
+			new_str[j] = '\0';
+			break;
+		}
+
+		/* Add separator? */
+		if (i != 0 && (i - leading_digits) % groupdigits == 0)
+		{
+			strcpy(&new_str[j], thousands_sep);
+			j += strlen(thousands_sep);
+		}
+
+		new_str[j] = my_str[i];
+	}
+
+	return new_str;
+}
+
+/*
+ * fputnbytes: print exactly N bytes to a file
+ *
+ * Think not to use fprintf with a %.*s format for this.  Some machines
+ * believe %s's precision is measured in characters, others in bytes.
+ */
+static void
+fputnbytes(FILE *f, const char *str, size_t n)
+{
+	while (n-- > 0)
+		fputc(*str++, f);
+}
+
+
+/*************************/
+/* Unaligned text		 */
+/*************************/
+
+
+static void
+print_unaligned_text(const printTableContent *cont, FILE *fout)
+{
+	const char *opt_fieldsep = cont->opt->fieldSep;
+	const char *opt_recordsep = cont->opt->recordSep;
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned int i;
+	const char *const * ptr;
+	bool		need_recordsep = false;
+
+	if (cancel_pressed)
+		return;
+
+	if (!opt_fieldsep)
+		opt_fieldsep = "";
+	if (!opt_recordsep)
+		opt_recordsep = "";
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+			fprintf(fout, "%s%s", cont->title, opt_recordsep);
+
+		/* print headers */
+		if (!opt_tuples_only)
+		{
+			for (ptr = cont->headers; *ptr; ptr++)
+			{
+				if (ptr != cont->headers)
+					fputs(opt_fieldsep, fout);
+				fputs(*ptr, fout);
+			}
+			need_recordsep = true;
+		}
+	}
+	else
+		/* assume continuing printout */
+		need_recordsep = true;
+
+	/* print cells */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		if (need_recordsep)
+		{
+			fputs(opt_recordsep, fout);
+			need_recordsep = false;
+			if (cancel_pressed)
+				break;
+		}
+		fputs(*ptr, fout);
+
+		if ((i + 1) % cont->ncolumns)
+			fputs(opt_fieldsep, fout);
+		else
+			need_recordsep = true;
+	}
+
+	/* print footers */
+	if (cont->opt->stop_table)
+	{
+		if (!opt_tuples_only && cont->footers != NULL && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+			{
+				if (need_recordsep)
+				{
+					fputs(opt_recordsep, fout);
+					need_recordsep = false;
+				}
+				fputs(f->data, fout);
+				need_recordsep = true;
+			}
+		}
+		/* the last record needs to be concluded with a newline */
+		if (need_recordsep)
+			fputc('\n', fout);
+	}
+}
+
+
+static void
+print_unaligned_vertical(const printTableContent *cont, FILE *fout)
+{
+	const char *opt_fieldsep = cont->opt->fieldSep;
+	const char *opt_recordsep = cont->opt->recordSep;
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned int i;
+	const char *const * ptr;
+	bool		need_recordsep = false;
+
+	if (cancel_pressed)
+		return;
+
+	if (!opt_fieldsep)
+		opt_fieldsep = "";
+	if (!opt_recordsep)
+		opt_recordsep = "";
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs(cont->title, fout);
+			need_recordsep = true;
+		}
+	}
+	else
+		/* assume continuing printout */
+		need_recordsep = true;
+
+	/* print records */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		if (need_recordsep)
+		{
+			/* record separator is 2 occurrences of recordsep in this mode */
+			fputs(opt_recordsep, fout);
+			fputs(opt_recordsep, fout);
+			need_recordsep = false;
+			if (cancel_pressed)
+				break;
+		}
+
+		fputs(cont->headers[i % cont->ncolumns], fout);
+		fputs(opt_fieldsep, fout);
+		fputs(*ptr, fout);
+
+		if ((i + 1) % cont->ncolumns)
+			fputs(opt_recordsep, fout);
+		else
+			need_recordsep = true;
+	}
+
+	if (cont->opt->stop_table)
+	{
+		/* print footers */
+		if (!opt_tuples_only && cont->footers != NULL && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			fputs(opt_recordsep, fout);
+			for (f = cont->footers; f; f = f->next)
+			{
+				fputs(opt_recordsep, fout);
+				fputs(f->data, fout);
+			}
+		}
+
+		fputc('\n', fout);
+	}
+}
+
+
+/********************/
+/* Aligned text		*/
+/********************/
+
+
+/* draw "line" */
+static void
+_print_horizontal_line(const unsigned int ncolumns, const unsigned int *widths,
+					   unsigned short border, FILE *fout)
+{
+	unsigned int i,
+				j;
+
+	if (border == 1)
+		fputc('-', fout);
+	else if (border == 2)
+		fputs("+-", fout);
+
+	for (i = 0; i < ncolumns; i++)
+	{
+		for (j = 0; j < widths[i]; j++)
+			fputc('-', fout);
+
+		if (i < ncolumns - 1)
+		{
+			if (border == 0)
+				fputc(' ', fout);
+			else
+				fputs("-+-", fout);
+		}
+	}
+
+	if (border == 2)
+		fputs("-+", fout);
+	else if (border == 1)
+		fputc('-', fout);
+
+	fputc('\n', fout);
+}
+
+
+/*
+ *	Print pretty boxes around cells.
+ */
+static void
+print_aligned_text(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	int			encoding = cont->opt->encoding;
+	unsigned short opt_border = cont->opt->border;
+
+	unsigned int col_count = 0,
+				cell_count = 0;
+
+	unsigned int i,
+				j;
+
+	unsigned int *width_header,
+			   *max_width,
+			   *width_wrap,
+			   *width_average;
+	unsigned int *max_nl_lines, /* value split by newlines */
+			   *curr_nl_line,
+			   *max_bytes;
+	unsigned char **format_buf;
+	unsigned int width_total;
+	unsigned int total_header_width;
+	unsigned int extra_row_output_lines = 0;
+	unsigned int extra_output_lines = 0;
+
+	const char *const * ptr;
+
+	struct lineptr **col_lineptrs;		/* pointers to line pointer per column */
+
+	bool	   *header_done;	/* Have all header lines been output? */
+	int		   *bytes_output;	/* Bytes output for column value */
+	int			output_columns = 0;		/* Width of interactive console */
+	bool		is_pager = false;
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->ncolumns > 0)
+	{
+		col_count = cont->ncolumns;
+		width_header = pg_local_calloc(col_count, sizeof(*width_header));
+		width_average = pg_local_calloc(col_count, sizeof(*width_average));
+		max_width = pg_local_calloc(col_count, sizeof(*max_width));
+		width_wrap = pg_local_calloc(col_count, sizeof(*width_wrap));
+		max_nl_lines = pg_local_calloc(col_count, sizeof(*max_nl_lines));
+		curr_nl_line = pg_local_calloc(col_count, sizeof(*curr_nl_line));
+		col_lineptrs = pg_local_calloc(col_count, sizeof(*col_lineptrs));
+		max_bytes = pg_local_calloc(col_count, sizeof(*max_bytes));
+		format_buf = pg_local_calloc(col_count, sizeof(*format_buf));
+		header_done = pg_local_calloc(col_count, sizeof(*header_done));
+		bytes_output = pg_local_calloc(col_count, sizeof(*bytes_output));
+	}
+	else
+	{
+		width_header = NULL;
+		width_average = NULL;
+		max_width = NULL;
+		width_wrap = NULL;
+		max_nl_lines = NULL;
+		curr_nl_line = NULL;
+		col_lineptrs = NULL;
+		max_bytes = NULL;
+		format_buf = NULL;
+		header_done = NULL;
+		bytes_output = NULL;
+	}
+
+	/* scan all column headers, find maximum width and max max_nl_lines */
+	for (i = 0; i < col_count; i++)
+	{
+		int			width,
+					nl_lines,
+					bytes_required;
+
+		pg_wcssize((unsigned char *) cont->headers[i], strlen(cont->headers[i]),
+				   encoding, &width, &nl_lines, &bytes_required);
+		if (width > max_width[i])
+			max_width[i] = width;
+		if (nl_lines > max_nl_lines[i])
+			max_nl_lines[i] = nl_lines;
+		if (bytes_required > max_bytes[i])
+			max_bytes[i] = bytes_required;
+		if (nl_lines > extra_row_output_lines)
+			extra_row_output_lines = nl_lines;
+
+		width_header[i] = width;
+	}
+	/* Add height of tallest header column */
+	extra_output_lines += extra_row_output_lines;
+	extra_row_output_lines = 0;
+
+	/* scan all cells, find maximum width, compute cell_count */
+	for (i = 0, ptr = cont->cells; *ptr; ptr++, i++, cell_count++)
+	{
+		int			width,
+					nl_lines,
+					bytes_required;
+
+		pg_wcssize((unsigned char *) *ptr, strlen(*ptr), encoding,
+				   &width, &nl_lines, &bytes_required);
+
+		if (width > max_width[i % col_count])
+			max_width[i % col_count] = width;
+		if (nl_lines > max_nl_lines[i % col_count])
+			max_nl_lines[i % col_count] = nl_lines;
+		if (bytes_required > max_bytes[i % col_count])
+			max_bytes[i % col_count] = bytes_required;
+
+		width_average[i % col_count] += width;
+	}
+
+	/* If we have rows, compute average */
+	if (col_count != 0 && cell_count != 0)
+	{
+		int			rows = cell_count / col_count;
+
+		for (i = 0; i < col_count; i++)
+			width_average[i] /= rows;
+	}
+
+	/* adjust the total display width based on border style */
+	if (opt_border == 0)
+		width_total = col_count - 1;
+	else if (opt_border == 1)
+		width_total = col_count * 3 - 1;
+	else
+		width_total = col_count * 3 + 1;
+	total_header_width = width_total;
+
+	for (i = 0; i < col_count; i++)
+	{
+		width_total += max_width[i];
+		total_header_width += width_header[i];
+	}
+
+	/*
+	 * At this point: max_width[] contains the max width of each column,
+	 * max_nl_lines[] contains the max number of lines in each column,
+	 * max_bytes[] contains the maximum storage space for formatting strings,
+	 * width_total contains the giant width sum.  Now we allocate some memory
+	 * for line pointers.
+	 */
+	for (i = 0; i < col_count; i++)
+	{
+		/* Add entry for ptr == NULL array termination */
+		col_lineptrs[i] = pg_local_calloc(max_nl_lines[i] + 1,
+										  sizeof(**col_lineptrs));
+
+		format_buf[i] = pg_local_malloc(max_bytes[i] + 1);
+
+		col_lineptrs[i]->ptr = format_buf[i];
+	}
+
+	/* Default word wrap to the full width, i.e. no word wrap */
+	for (i = 0; i < col_count; i++)
+		width_wrap[i] = max_width[i];
+
+	/*
+	 * Choose target output width: \pset columns, or $COLUMNS, or ioctl
+	 */
+	if (cont->opt->columns > 0)
+		output_columns = cont->opt->columns;
+	else if ((fout == stdout && isatty(fileno(stdout))) || is_pager)
+	{
+		if (cont->opt->env_columns > 0)
+			output_columns = cont->opt->env_columns;
+#ifdef TIOCGWINSZ
+		else
+		{
+			struct winsize screen_size;
+
+			if (ioctl(fileno(stdout), TIOCGWINSZ, &screen_size) != -1)
+				output_columns = screen_size.ws_col;
+		}
+#endif
+	}
+
+	if (cont->opt->format == PRINT_WRAPPED)
+	{
+		/*
+		 * Optional optimized word wrap. Shrink columns with a high max/avg
+		 * ratio.  Slighly bias against wider columns. (Increases chance a
+		 * narrow column will fit in its cell.)  If available columns is
+		 * positive...	and greater than the width of the unshrinkable column
+		 * headers
+		 */
+		if (output_columns > 0 && output_columns >= total_header_width)
+		{
+			/* While there is still excess width... */
+			while (width_total > output_columns)
+			{
+				double		max_ratio = 0;
+				int			worst_col = -1;
+
+				/*
+				 * Find column that has the highest ratio of its maximum width
+				 * compared to its average width.  This tells us which column
+				 * will produce the fewest wrapped values if shortened.
+				 * width_wrap starts as equal to max_width.
+				 */
+				for (i = 0; i < col_count; i++)
+				{
+					if (width_average[i] && width_wrap[i] > width_header[i])
+					{
+						/* Penalize wide columns by 1% of their width */
+						double		ratio;
+
+						ratio = (double) width_wrap[i] / width_average[i] +
+							max_width[i] * 0.01;
+						if (ratio > max_ratio)
+						{
+							max_ratio = ratio;
+							worst_col = i;
+						}
+					}
+				}
+
+				/* Exit loop if we can't squeeze any more. */
+				if (worst_col == -1)
+					break;
+
+				/* Decrease width of target column by one. */
+				width_wrap[worst_col]--;
+				width_total--;
+			}
+		}
+	}
+
+	/* If we wrapped beyond the display width, use the pager */
+	if (!is_pager && fout == stdout && output_columns > 0 &&
+		(output_columns < total_header_width || output_columns < width_total))
+	{
+		fout = PageOutput(INT_MAX, cont->opt->pager);	/* force pager */
+		is_pager = true;
+	}
+
+	/* Check if newlines or our wrapping now need the pager */
+	if (!is_pager)
+	{
+		/* scan all cells, find maximum width, compute cell_count */
+		for (i = 0, ptr = cont->cells; *ptr; ptr++, cell_count++)
+		{
+			int			width,
+						nl_lines,
+						bytes_required;
+
+			pg_wcssize((unsigned char *) *ptr, strlen(*ptr), encoding,
+					   &width, &nl_lines, &bytes_required);
+
+			/*
+			 * A row can have both wrapping and newlines that cause it to
+			 * display across multiple lines.  We check for both cases below.
+			 */
+			if (width > 0 && width_wrap[i])
+			{
+				unsigned int extra_lines;
+
+				extra_lines = (width - 1) / width_wrap[i] + nl_lines;
+				if (extra_lines > extra_row_output_lines)
+					extra_row_output_lines = extra_lines;
+			}
+
+			/* i is the current column number: increment with wrap */
+			if (++i >= col_count)
+			{
+				i = 0;
+				/* At last column of each row, add tallest column height */
+				extra_output_lines += extra_row_output_lines;
+				extra_row_output_lines = 0;
+			}
+		}
+		IsPagerNeeded(cont, extra_output_lines, &fout, &is_pager);
+	}
+
+	/* time to output */
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (cont->title && !opt_tuples_only)
+		{
+			int			width,
+						height;
+
+			pg_wcssize((unsigned char *) cont->title, strlen(cont->title),
+					   encoding, &width, &height, NULL);
+			if (width >= width_total)
+				/* Aligned */
+				fprintf(fout, "%s\n", cont->title);
+			else
+				/* Centered */
+				fprintf(fout, "%-*s%s\n", (width_total - width) / 2, "",
+						cont->title);
+		}
+
+		/* print headers */
+		if (!opt_tuples_only)
+		{
+			int			more_col_wrapping;
+			int			curr_nl_line;
+
+			if (opt_border == 2)
+				_print_horizontal_line(col_count, width_wrap, opt_border, fout);
+
+			for (i = 0; i < col_count; i++)
+				pg_wcsformat((unsigned char *) cont->headers[i],
+							 strlen(cont->headers[i]), encoding,
+							 col_lineptrs[i], max_nl_lines[i]);
+
+			more_col_wrapping = col_count;
+			curr_nl_line = 0;
+			memset(header_done, false, col_count * sizeof(bool));
+			while (more_col_wrapping)
+			{
+				if (opt_border == 2)
+					fprintf(fout, "|%c", curr_nl_line ? '+' : ' ');
+				else if (opt_border == 1)
+					fputc(curr_nl_line ? '+' : ' ', fout);
+
+				for (i = 0; i < cont->ncolumns; i++)
+				{
+					unsigned int nbspace;
+
+					struct lineptr *this_line = col_lineptrs[i] + curr_nl_line;
+
+					if (!header_done[i])
+					{
+						nbspace = width_wrap[i] - this_line->width;
+
+						/* centered */
+						fprintf(fout, "%-*s%s%-*s",
+								nbspace / 2, "", this_line->ptr, (nbspace + 1) / 2, "");
+
+						if (!(this_line + 1)->ptr)
+						{
+							more_col_wrapping--;
+							header_done[i] = 1;
+						}
+					}
+					else
+						fprintf(fout, "%*s", width_wrap[i], "");
+					if (i < col_count - 1)
+					{
+						if (opt_border == 0)
+							fputc(curr_nl_line ? '+' : ' ', fout);
+						else
+							fprintf(fout, " |%c", curr_nl_line ? '+' : ' ');
+					}
+				}
+				curr_nl_line++;
+
+				if (opt_border == 2)
+					fputs(" |", fout);
+				else if (opt_border == 1)
+					fputc(' ', fout);
+				fputc('\n', fout);
+			}
+
+			_print_horizontal_line(col_count, width_wrap, opt_border, fout);
+		}
+	}
+
+	/* print cells, one loop per row */
+	for (i = 0, ptr = cont->cells; *ptr; i += col_count, ptr += col_count)
+	{
+		bool		more_lines;
+
+		if (cancel_pressed)
+			break;
+
+		/*
+		 * Format each cell.
+		 */
+		for (j = 0; j < col_count; j++)
+		{
+			pg_wcsformat((unsigned char *) ptr[j], strlen(ptr[j]), encoding,
+						 col_lineptrs[j], max_nl_lines[j]);
+			curr_nl_line[j] = 0;
+		}
+
+		memset(bytes_output, 0, col_count * sizeof(int));
+
+		/*
+		 * Each time through this loop, one display line is output. It can
+		 * either be a full value or a partial value if embedded newlines
+		 * exist or if 'format=wrapping' mode is enabled.
+		 */
+		do
+		{
+			more_lines = false;
+
+			/* left border */
+			if (opt_border == 2)
+				fputs("| ", fout);
+			else if (opt_border == 1)
+				fputc(' ', fout);
+
+			/* for each column */
+			for (j = 0; j < col_count; j++)
+			{
+				/* We have a valid array element, so index it */
+				struct lineptr *this_line = &col_lineptrs[j][curr_nl_line[j]];
+				int			bytes_to_output;
+				int			chars_to_output = width_wrap[j];
+				bool		finalspaces = (opt_border == 2 || j < col_count - 1);
+
+				if (!this_line->ptr)
+				{
+					/* Past newline lines so just pad for other columns */
+					if (finalspaces)
+						fprintf(fout, "%*s", chars_to_output, "");
+				}
+				else
+				{
+					/* Get strlen() of the characters up to width_wrap */
+					bytes_to_output =
+						strlen_max_width(this_line->ptr + bytes_output[j],
+										 &chars_to_output, encoding);
+
+					/*
+					 * If we exceeded width_wrap, it means the display width
+					 * of a single character was wider than our target width.
+					 * In that case, we have to pretend we are only printing
+					 * the target display width and make the best of it.
+					 */
+					if (chars_to_output > width_wrap[j])
+						chars_to_output = width_wrap[j];
+
+					if (cont->aligns[j] == 'r') /* Right aligned cell */
+					{
+						/* spaces first */
+						fprintf(fout, "%*s", width_wrap[j] - chars_to_output, "");
+						fputnbytes(fout,
+								   (char *) (this_line->ptr + bytes_output[j]),
+								   bytes_to_output);
+					}
+					else	/* Left aligned cell */
+					{
+						/* spaces second */
+						fputnbytes(fout,
+								   (char *) (this_line->ptr + bytes_output[j]),
+								   bytes_to_output);
+						if (finalspaces)
+							fprintf(fout, "%*s", width_wrap[j] - chars_to_output, "");
+					}
+
+					bytes_output[j] += bytes_to_output;
+
+					/* Do we have more text to wrap? */
+					if (*(this_line->ptr + bytes_output[j]) != '\0')
+						more_lines = true;
+					else
+					{
+						/* Advance to next newline line */
+						curr_nl_line[j]++;
+						if (col_lineptrs[j][curr_nl_line[j]].ptr != NULL)
+							more_lines = true;
+						bytes_output[j] = 0;
+					}
+				}
+
+				/* print a divider, if not the last column */
+				if (j < col_count - 1)
+				{
+					if (opt_border == 0)
+						fputc(' ', fout);
+					/* Next value is beyond past newlines? */
+					else if (col_lineptrs[j + 1][curr_nl_line[j + 1]].ptr == NULL)
+						fputs("   ", fout);
+					/* In wrapping of value? */
+					else if (bytes_output[j + 1] != 0)
+						fputs(" ; ", fout);
+					/* After first newline value */
+					else if (curr_nl_line[j + 1] != 0)
+						fputs(" : ", fout);
+					else
+						/* Ordinary line */
+						fputs(" | ", fout);
+				}
+			}
+
+			/* end-of-row border */
+			if (opt_border == 2)
+				fputs(" |", fout);
+			fputc('\n', fout);
+
+		} while (more_lines);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		if (opt_border == 2 && !cancel_pressed)
+			_print_horizontal_line(col_count, width_wrap, opt_border, fout);
+
+		/* print footers */
+		if (cont->footers && !opt_tuples_only && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+				fprintf(fout, "%s\n", f->data);
+		}
+
+		fputc('\n', fout);
+	}
+
+	/* clean up */
+	for (i = 0; i < col_count; i++)
+	{
+		free(col_lineptrs[i]);
+		free(format_buf[i]);
+	}
+	free(width_header);
+	free(width_average);
+	free(max_width);
+	free(width_wrap);
+	free(max_nl_lines);
+	free(curr_nl_line);
+	free(col_lineptrs);
+	free(max_bytes);
+	free(format_buf);
+	free(header_done);
+	free(bytes_output);
+
+	if (is_pager)
+		ClosePager(fout);
+}
+
+
+static void
+print_aligned_vertical(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	int			encoding = cont->opt->encoding;
+	unsigned long record = cont->opt->prior_records + 1;
+	const char *const * ptr;
+	unsigned int i,
+				hwidth = 0,
+				dwidth = 0,
+				hheight = 1,
+				dheight = 1,
+				hformatsize = 0,
+				dformatsize = 0;
+	char	   *divider;
+	struct lineptr *hlineptr,
+			   *dlineptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->cells[0] == NULL && cont->opt->start_table &&
+		cont->opt->stop_table)
+	{
+		fprintf(fout, _("(No rows)\n"));
+		return;
+	}
+
+	/* Find the maximum dimensions for the headers */
+	for (i = 0; i < cont->ncolumns; i++)
+	{
+		int			width,
+					height,
+					fs;
+
+		pg_wcssize((unsigned char *) cont->headers[i], strlen(cont->headers[i]),
+				   encoding, &width, &height, &fs);
+		if (width > hwidth)
+			hwidth = width;
+		if (height > hheight)
+			hheight = height;
+		if (fs > hformatsize)
+			hformatsize = fs;
+	}
+
+	/* find longest data cell */
+	for (i = 0, ptr = cont->cells; *ptr; ptr++, i++)
+	{
+		int			width,
+					height,
+					fs;
+
+		pg_wcssize((unsigned char *) *ptr, strlen(*ptr), encoding,
+				   &width, &height, &fs);
+		if (width > dwidth)
+			dwidth = width;
+		if (height > dheight)
+			dheight = height;
+		if (fs > dformatsize)
+			dformatsize = fs;
+	}
+
+	/*
+	 * We now have all the information we need to setup the formatting
+	 * structures
+	 */
+	dlineptr = pg_local_malloc((sizeof(*dlineptr)) * (dheight + 1));
+	hlineptr = pg_local_malloc((sizeof(*hlineptr)) * (hheight + 1));
+
+	dlineptr->ptr = pg_local_malloc(dformatsize);
+	hlineptr->ptr = pg_local_malloc(hformatsize);
+
+	/* make horizontal border */
+	divider = pg_local_malloc(hwidth + dwidth + 10);
+	divider[0] = '\0';
+	if (opt_border == 2)
+		strcat(divider, "+-");
+	for (i = 0; i < hwidth; i++)
+		strcat(divider, opt_border > 0 ? "-" : " ");
+	if (opt_border > 0)
+		strcat(divider, "-+-");
+	else
+		strcat(divider, " ");
+	for (i = 0; i < dwidth; i++)
+		strcat(divider, opt_border > 0 ? "-" : " ");
+	if (opt_border == 2)
+		strcat(divider, "-+");
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+			fprintf(fout, "%s\n", cont->title);
+	}
+
+	/* print records */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		int			line_count,
+					dcomplete,
+					hcomplete;
+
+		if (i % cont->ncolumns == 0)
+		{
+			if (cancel_pressed)
+				break;
+			if (!opt_tuples_only)
+			{
+				char		record_str[64];
+				size_t		record_str_len;
+
+				if (opt_border == 0)
+					snprintf(record_str, 64, "* Record %lu", record++);
+				else
+					snprintf(record_str, 64, "[ RECORD %lu ]", record++);
+				record_str_len = strlen(record_str);
+
+				if (record_str_len + opt_border > strlen(divider))
+				{
+					/* %.*s OK here because divider is all ASCII */
+					fprintf(fout, "%.*s%s\n", opt_border, divider, record_str);
+				}
+				else
+				{
+					char	   *div_copy = pg_strdup(divider);
+
+					strncpy(div_copy + opt_border, record_str, record_str_len);
+					fprintf(fout, "%s\n", div_copy);
+					free(div_copy);
+				}
+			}
+			else if (i != 0 || !cont->opt->start_table || opt_border == 2)
+				fprintf(fout, "%s\n", divider);
+		}
+
+		/* Format the header */
+		pg_wcsformat((unsigned char *) cont->headers[i % cont->ncolumns],
+					 strlen(cont->headers[i % cont->ncolumns]),
+					 encoding, hlineptr, hheight);
+		/* Format the data */
+		pg_wcsformat((unsigned char *) *ptr, strlen(*ptr), encoding,
+					 dlineptr, dheight);
+
+		line_count = 0;
+		dcomplete = hcomplete = 0;
+		while (!dcomplete || !hcomplete)
+		{
+			if (opt_border == 2)
+				fputs("| ", fout);
+			if (!hcomplete)
+			{
+				fprintf(fout, "%-s%*s", hlineptr[line_count].ptr,
+						hwidth - hlineptr[line_count].width, "");
+
+				if (!hlineptr[line_count + 1].ptr)
+					hcomplete = 1;
+			}
+			else
+				fprintf(fout, "%*s", hwidth, "");
+
+			if (opt_border > 0)
+				fprintf(fout, " %c ", (line_count == 0) ? '|' : ':');
+			else
+				fputs(" ", fout);
+
+			if (!dcomplete)
+			{
+				if (opt_border < 2)
+					fprintf(fout, "%s\n", dlineptr[line_count].ptr);
+				else
+					fprintf(fout, "%-s%*s |\n", dlineptr[line_count].ptr,
+							dwidth - dlineptr[line_count].width, "");
+
+				if (!dlineptr[line_count + 1].ptr)
+					dcomplete = 1;
+			}
+			else
+			{
+				if (opt_border < 2)
+					fputc('\n', fout);
+				else
+					fprintf(fout, "%*s |\n", dwidth, "");
+			}
+			line_count++;
+		}
+	}
+
+	if (cont->opt->stop_table)
+	{
+		if (opt_border == 2 && !cancel_pressed)
+			fprintf(fout, "%s\n", divider);
+
+		/* print footers */
+		if (!opt_tuples_only && cont->footers != NULL && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			if (opt_border < 2)
+				fputc('\n', fout);
+			for (f = cont->footers; f; f = f->next)
+				fprintf(fout, "%s\n", f->data);
+		}
+
+		fputc('\n', fout);
+	}
+
+	free(divider);
+	free(hlineptr->ptr);
+	free(dlineptr->ptr);
+	free(hlineptr);
+	free(dlineptr);
+}
+
+
+/**********************/
+/* HTML printing ******/
+/**********************/
+
+
+void
+html_escaped_print(const char *in, FILE *fout)
+{
+	const char *p;
+	bool		leading_space = true;
+
+	for (p = in; *p; p++)
+	{
+		switch (*p)
+		{
+			case '&':
+				fputs("&amp;", fout);
+				break;
+			case '<':
+				fputs("&lt;", fout);
+				break;
+			case '>':
+				fputs("&gt;", fout);
+				break;
+			case '\n':
+				fputs("<br />\n", fout);
+				break;
+			case '"':
+				fputs("&quot;", fout);
+				break;
+			case ' ':
+				/* protect leading space, for EXPLAIN output */
+				if (leading_space)
+					fputs("&nbsp;", fout);
+				else
+					fputs(" ", fout);
+				break;
+			default:
+				fputc(*p, fout);
+		}
+		if (*p != ' ')
+			leading_space = false;
+	}
+}
+
+
+static void
+print_html_text(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	const char *opt_table_attr = cont->opt->tableAttr;
+	unsigned int i;
+	const char *const * ptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (cont->opt->start_table)
+	{
+		fprintf(fout, "<table border=\"%d\"", opt_border);
+		if (opt_table_attr)
+			fprintf(fout, " %s", opt_table_attr);
+		fputs(">\n", fout);
+
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs("  <caption>", fout);
+			html_escaped_print(cont->title, fout);
+			fputs("</caption>\n", fout);
+		}
+
+		/* print headers */
+		if (!opt_tuples_only)
+		{
+			fputs("  <tr>\n", fout);
+			for (ptr = cont->headers; *ptr; ptr++)
+			{
+				fputs("    <th align=\"center\">", fout);
+				html_escaped_print(*ptr, fout);
+				fputs("</th>\n", fout);
+			}
+			fputs("  </tr>\n", fout);
+		}
+	}
+
+	/* print cells */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		if (i % cont->ncolumns == 0)
+		{
+			if (cancel_pressed)
+				break;
+			fputs("  <tr valign=\"top\">\n", fout);
+		}
+
+		fprintf(fout, "    <td align=\"%s\">", cont->aligns[(i) % cont->ncolumns] == 'r' ? "right" : "left");
+		/* is string only whitespace? */
+		if ((*ptr)[strspn(*ptr, " \t")] == '\0')
+			fputs("&nbsp; ", fout);
+		else
+			html_escaped_print(*ptr, fout);
+
+		fputs("</td>\n", fout);
+
+		if ((i + 1) % cont->ncolumns == 0)
+			fputs("  </tr>\n", fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		fputs("</table>\n", fout);
+
+		/* print footers */
+		if (!opt_tuples_only && cont->footers != NULL && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			fputs("<p>", fout);
+			for (f = cont->footers; f; f = f->next)
+			{
+				html_escaped_print(f->data, fout);
+				fputs("<br />\n", fout);
+			}
+			fputs("</p>", fout);
+		}
+
+		fputc('\n', fout);
+	}
+}
+
+
+static void
+print_html_vertical(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	const char *opt_table_attr = cont->opt->tableAttr;
+	unsigned long record = cont->opt->prior_records + 1;
+	unsigned int i;
+	const char *const * ptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (cont->opt->start_table)
+	{
+		fprintf(fout, "<table border=\"%d\"", opt_border);
+		if (opt_table_attr)
+			fprintf(fout, " %s", opt_table_attr);
+		fputs(">\n", fout);
+
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs("  <caption>", fout);
+			html_escaped_print(cont->title, fout);
+			fputs("</caption>\n", fout);
+		}
+	}
+
+	/* print records */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		if (i % cont->ncolumns == 0)
+		{
+			if (cancel_pressed)
+				break;
+			if (!opt_tuples_only)
+				fprintf(fout,
+						"\n  <tr><td colspan=\"2\" align=\"center\">Record %lu</td></tr>\n",
+						record++);
+			else
+				fputs("\n  <tr><td colspan=\"2\">&nbsp;</td></tr>\n", fout);
+		}
+		fputs("  <tr valign=\"top\">\n"
+			  "    <th>", fout);
+		html_escaped_print(cont->headers[i % cont->ncolumns], fout);
+		fputs("</th>\n", fout);
+
+		fprintf(fout, "    <td align=\"%s\">", cont->aligns[i % cont->ncolumns] == 'r' ? "right" : "left");
+		/* is string only whitespace? */
+		if ((*ptr)[strspn(*ptr, " \t")] == '\0')
+			fputs("&nbsp; ", fout);
+		else
+			html_escaped_print(*ptr, fout);
+
+		fputs("</td>\n  </tr>\n", fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		fputs("</table>\n", fout);
+
+		/* print footers */
+		if (!opt_tuples_only && cont->footers != NULL && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			fputs("<p>", fout);
+			for (f = cont->footers; f; f = f->next)
+			{
+				html_escaped_print(f->data, fout);
+				fputs("<br />\n", fout);
+			}
+			fputs("</p>", fout);
+		}
+
+		fputc('\n', fout);
+	}
+}
+
+
+/*************************/
+/* LaTeX				 */
+/*************************/
+
+
+static void
+latex_escaped_print(const char *in, FILE *fout)
+{
+	const char *p;
+
+	for (p = in; *p; p++)
+		switch (*p)
+		{
+			case '&':
+				fputs("\\&", fout);
+				break;
+			case '%':
+				fputs("\\%", fout);
+				break;
+			case '$':
+				fputs("\\$", fout);
+				break;
+			case '_':
+				fputs("\\_", fout);
+				break;
+			case '{':
+				fputs("\\{", fout);
+				break;
+			case '}':
+				fputs("\\}", fout);
+				break;
+			case '\\':
+				fputs("\\backslash", fout);
+				break;
+			case '\n':
+				fputs("\\\\", fout);
+				break;
+			default:
+				fputc(*p, fout);
+		}
+}
+
+
+static void
+print_latex_text(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	unsigned int i;
+	const char *const * ptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs("\\begin{center}\n", fout);
+			latex_escaped_print(cont->title, fout);
+			fputs("\n\\end{center}\n\n", fout);
+		}
+
+		/* begin environment and set alignments and borders */
+		fputs("\\begin{tabular}{", fout);
+
+		if (opt_border == 2)
+			fputs("| ", fout);
+		for (i = 0; i < cont->ncolumns; i++)
+		{
+			fputc(*(cont->aligns + i), fout);
+			if (opt_border != 0 && i < cont->ncolumns - 1)
+				fputs(" | ", fout);
+		}
+		if (opt_border == 2)
+			fputs(" |", fout);
+
+		fputs("}\n", fout);
+
+		if (!opt_tuples_only && opt_border == 2)
+			fputs("\\hline\n", fout);
+
+		/* print headers */
+		if (!opt_tuples_only)
+		{
+			for (i = 0, ptr = cont->headers; i < cont->ncolumns; i++, ptr++)
+			{
+				if (i != 0)
+					fputs(" & ", fout);
+				fputs("\\textit{", fout);
+				latex_escaped_print(*ptr, fout);
+				fputc('}', fout);
+			}
+			fputs(" \\\\\n", fout);
+			fputs("\\hline\n", fout);
+		}
+	}
+
+	/* print cells */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		latex_escaped_print(*ptr, fout);
+
+		if ((i + 1) % cont->ncolumns == 0)
+		{
+			fputs(" \\\\\n", fout);
+			if (cancel_pressed)
+				break;
+		}
+		else
+			fputs(" & ", fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		if (opt_border == 2)
+			fputs("\\hline\n", fout);
+
+		fputs("\\end{tabular}\n\n\\noindent ", fout);
+
+		/* print footers */
+		if (cont->footers && !opt_tuples_only && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+			{
+				latex_escaped_print(f->data, fout);
+				fputs(" \\\\\n", fout);
+			}
+		}
+
+		fputc('\n', fout);
+	}
+}
+
+
+static void
+print_latex_vertical(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	unsigned long record = cont->opt->prior_records + 1;
+	unsigned int i;
+	const char *const * ptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs("\\begin{center}\n", fout);
+			latex_escaped_print(cont->title, fout);
+			fputs("\n\\end{center}\n\n", fout);
+		}
+
+		/* begin environment and set alignments and borders */
+		fputs("\\begin{tabular}{", fout);
+		if (opt_border == 0)
+			fputs("cl", fout);
+		else if (opt_border == 1)
+			fputs("c|l", fout);
+		else if (opt_border == 2)
+			fputs("|c|l|", fout);
+		fputs("}\n", fout);
+	}
+
+	/* print records */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		/* new record */
+		if (i % cont->ncolumns == 0)
+		{
+			if (cancel_pressed)
+				break;
+			if (!opt_tuples_only)
+			{
+				if (opt_border == 2)
+				{
+					fputs("\\hline\n", fout);
+					fprintf(fout, "\\multicolumn{2}{|c|}{\\textit{Record %lu}} \\\\\n", record++);
+				}
+				else
+					fprintf(fout, "\\multicolumn{2}{c}{\\textit{Record %lu}} \\\\\n", record++);
+			}
+			if (opt_border >= 1)
+				fputs("\\hline\n", fout);
+		}
+
+		latex_escaped_print(cont->headers[i % cont->ncolumns], fout);
+		fputs(" & ", fout);
+		latex_escaped_print(*ptr, fout);
+		fputs(" \\\\\n", fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		if (opt_border == 2)
+			fputs("\\hline\n", fout);
+
+		fputs("\\end{tabular}\n\n\\noindent ", fout);
+
+		/* print footers */
+		if (cont->footers && !opt_tuples_only && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+			{
+				latex_escaped_print(f->data, fout);
+				fputs(" \\\\\n", fout);
+			}
+		}
+
+		fputc('\n', fout);
+	}
+}
+
+
+/*************************/
+/* Troff -ms		 */
+/*************************/
+
+
+static void
+troff_ms_escaped_print(const char *in, FILE *fout)
+{
+	const char *p;
+
+	for (p = in; *p; p++)
+		switch (*p)
+		{
+			case '\\':
+				fputs("\\(rs", fout);
+				break;
+			default:
+				fputc(*p, fout);
+		}
+}
+
+
+static void
+print_troff_ms_text(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	unsigned int i;
+	const char *const * ptr;
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs(".LP\n.DS C\n", fout);
+			troff_ms_escaped_print(cont->title, fout);
+			fputs("\n.DE\n", fout);
+		}
+
+		/* begin environment and set alignments and borders */
+		fputs(".LP\n.TS\n", fout);
+		if (opt_border == 2)
+			fputs("center box;\n", fout);
+		else
+			fputs("center;\n", fout);
+
+		for (i = 0; i < cont->ncolumns; i++)
+		{
+			fputc(*(cont->aligns + i), fout);
+			if (opt_border > 0 && i < cont->ncolumns - 1)
+				fputs(" | ", fout);
+		}
+		fputs(".\n", fout);
+
+		/* print headers */
+		if (!opt_tuples_only)
+		{
+			for (i = 0, ptr = cont->headers; i < cont->ncolumns; i++, ptr++)
+			{
+				if (i != 0)
+					fputc('\t', fout);
+				fputs("\\fI", fout);
+				troff_ms_escaped_print(*ptr, fout);
+				fputs("\\fP", fout);
+			}
+			fputs("\n_\n", fout);
+		}
+	}
+
+	/* print cells */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		troff_ms_escaped_print(*ptr, fout);
+
+		if ((i + 1) % cont->ncolumns == 0)
+		{
+			fputc('\n', fout);
+			if (cancel_pressed)
+				break;
+		}
+		else
+			fputc('\t', fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		fputs(".TE\n.DS L\n", fout);
+
+		/* print footers */
+		if (cont->footers && !opt_tuples_only && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+			{
+				troff_ms_escaped_print(f->data, fout);
+				fputc('\n', fout);
+			}
+		}
+
+		fputs(".DE\n", fout);
+	}
+}
+
+
+static void
+print_troff_ms_vertical(const printTableContent *cont, FILE *fout)
+{
+	bool		opt_tuples_only = cont->opt->tuples_only;
+	unsigned short opt_border = cont->opt->border;
+	unsigned long record = cont->opt->prior_records + 1;
+	unsigned int i;
+	const char *const * ptr;
+	unsigned short current_format = 0;	/* 0=none, 1=header, 2=body */
+
+	if (cancel_pressed)
+		return;
+
+	if (opt_border > 2)
+		opt_border = 2;
+
+	if (cont->opt->start_table)
+	{
+		/* print title */
+		if (!opt_tuples_only && cont->title)
+		{
+			fputs(".LP\n.DS C\n", fout);
+			troff_ms_escaped_print(cont->title, fout);
+			fputs("\n.DE\n", fout);
+		}
+
+		/* begin environment and set alignments and borders */
+		fputs(".LP\n.TS\n", fout);
+		if (opt_border == 2)
+			fputs("center box;\n", fout);
+		else
+			fputs("center;\n", fout);
+
+		/* basic format */
+		if (opt_tuples_only)
+			fputs("c l;\n", fout);
+	}
+	else
+		current_format = 2;		/* assume tuples printed already */
+
+	/* print records */
+	for (i = 0, ptr = cont->cells; *ptr; i++, ptr++)
+	{
+		/* new record */
+		if (i % cont->ncolumns == 0)
+		{
+			if (cancel_pressed)
+				break;
+			if (!opt_tuples_only)
+			{
+				if (current_format != 1)
+				{
+					if (opt_border == 2 && record > 1)
+						fputs("_\n", fout);
+					if (current_format != 0)
+						fputs(".T&\n", fout);
+					fputs("c s.\n", fout);
+					current_format = 1;
+				}
+				fprintf(fout, "\\fIRecord %lu\\fP\n", record++);
+			}
+			if (opt_border >= 1)
+				fputs("_\n", fout);
+		}
+
+		if (!opt_tuples_only)
+		{
+			if (current_format != 2)
+			{
+				if (current_format != 0)
+					fputs(".T&\n", fout);
+				if (opt_border != 1)
+					fputs("c l.\n", fout);
+				else
+					fputs("c | l.\n", fout);
+				current_format = 2;
+			}
+		}
+
+		troff_ms_escaped_print(cont->headers[i % cont->ncolumns], fout);
+		fputc('\t', fout);
+		troff_ms_escaped_print(*ptr, fout);
+
+		fputc('\n', fout);
+	}
+
+	if (cont->opt->stop_table)
+	{
+		fputs(".TE\n.DS L\n", fout);
+
+		/* print footers */
+		if (cont->footers && !opt_tuples_only && !cancel_pressed)
+		{
+			printTableFooter *f;
+
+			for (f = cont->footers; f; f = f->next)
+			{
+				troff_ms_escaped_print(f->data, fout);
+				fputc('\n', fout);
+			}
+		}
+
+		fputs(".DE\n", fout);
+	}
+}
+
+
+/********************************/
+/* Public functions		*/
+/********************************/
+
+
+/*
+ * PageOutput
+ *
+ * Tests if pager is needed and returns appropriate FILE pointer.
+ */
+FILE *
+PageOutput(int lines, unsigned short int pager)
+{
+	/* check whether we need / can / are supposed to use pager */
+	if (pager && isatty(fileno(stdin)) && isatty(fileno(stdout)))
+	{
+		const char *pagerprog;
+		FILE	   *pagerpipe;
+
+#ifdef TIOCGWINSZ
+		int			result;
+		struct winsize screen_size;
+
+		result = ioctl(fileno(stdout), TIOCGWINSZ, &screen_size);
+
+		/* >= accounts for a one-line prompt */
+		if (result == -1 || lines >= screen_size.ws_row || pager > 1)
+		{
+#endif
+			pagerprog = getenv("PAGER");
+			if (!pagerprog)
+				pagerprog = DEFAULT_PAGER;
+#ifndef WIN32
+			pqsignal(SIGPIPE, SIG_IGN);
+#endif
+			pagerpipe = popen(pagerprog, "w");
+			if (pagerpipe)
+				return pagerpipe;
+#ifdef TIOCGWINSZ
+		}
+#endif
+	}
+
+	return stdout;
+}
+
+/*
+ * ClosePager
+ *
+ * Close previously opened pager pipe, if any
+ */
+void
+ClosePager(FILE *pagerpipe)
+{
+	if (pagerpipe && pagerpipe != stdout)
+	{
+		/*
+		 * If printing was canceled midstream, warn about it.
+		 *
+		 * Some pagers like less use Ctrl-C as part of their command set. Even
+		 * so, we abort our processing and warn the user what we did.  If the
+		 * pager quit as a result of the SIGINT, this message won't go
+		 * anywhere ...
+		 */
+		if (cancel_pressed)
+			fprintf(pagerpipe, _("Interrupted\n"));
+
+		pclose(pagerpipe);
+#ifndef WIN32
+		pqsignal(SIGPIPE, SIG_DFL);
+#endif
+	}
+}
+
+/*
+ * Initialise a table contents struct.
+ *		Must be called before any other printTable method is used.
+ *
+ * The title is not duplicated; the caller must ensure that the buffer
+ * is available for the lifetime of the printTableContent struct.
+ *
+ * If you call this, you must call printTableCleanup once you're done with the
+ * table.
+ */
+void
+printTableInit(printTableContent *const content, const printTableOpt *opt,
+			   const char *title, const int ncolumns, const int nrows)
+{
+	content->opt = opt;
+	content->title = title;
+	content->ncolumns = ncolumns;
+	content->nrows = nrows;
+
+	content->headers = pg_local_calloc(ncolumns + 1,
+									   sizeof(*content->headers));
+
+	content->cells = pg_local_calloc(ncolumns * nrows + 1,
+									 sizeof(*content->cells));
+
+	content->cellmustfree = NULL;
+	content->footers = NULL;
+
+	content->aligns = pg_local_calloc(ncolumns + 1,
+									  sizeof(*content->align));
+
+	content->header = content->headers;
+	content->cell = content->cells;
+	content->footer = content->footers;
+	content->align = content->aligns;
+	content->cellsadded = 0;
+}
+
+/*
+ * Add a header to the table.
+ *
+ * Headers are not duplicated; you must ensure that the header string is
+ * available for the lifetime of the printTableContent struct.
+ *
+ * If translate is true, the function will pass the header through gettext.
+ * Otherwise, the header will not be translated.
+ *
+ * align is either 'l' or 'r', and specifies the alignment for cells in this
+ * column.
+ */
+void
+printTableAddHeader(printTableContent *const content, const char *header,
+					const bool translate, const char align)
+{
+#ifndef ENABLE_NLS
+	(void) translate;			/* unused parameter */
+#endif
+
+	if (content->header >= content->headers + content->ncolumns)
+	{
+		fprintf(stderr, _("Cannot add header to table content: "
+						  "column count of %d exceeded.\n"),
+				content->ncolumns);
+		exit(EXIT_FAILURE);
+	}
+
+	*content->header = (char *) mbvalidate((unsigned char *) header,
+										   content->opt->encoding);
+#ifdef ENABLE_NLS
+	if (translate)
+		*content->header = _(*content->header);
+#endif
+	content->header++;
+
+	*content->align = align;
+	content->align++;
+}
+
+/*
+ * Add a cell to the table.
+ *
+ * Cells are not duplicated; you must ensure that the cell string is available
+ * for the lifetime of the printTableContent struct.
+ *
+ * If translate is true, the function will pass the cell through gettext.
+ * Otherwise, the cell will not be translated.
+ *
+ * If mustfree is true, the cell string is freed by printTableCleanup().
+ * Note: Automatic freeing of translatable strings is not supported.
+ */
+void
+printTableAddCell(printTableContent *const content, const char *cell,
+				  const bool translate, const bool mustfree)
+{
+#ifndef ENABLE_NLS
+	(void) translate;			/* unused parameter */
+#endif
+
+	if (content->cellsadded >= content->ncolumns * content->nrows)
+	{
+		fprintf(stderr, _("Cannot add cell to table content: "
+						  "total cell count of %d exceeded.\n"),
+				content->ncolumns * content->nrows);
+		exit(EXIT_FAILURE);
+	}
+
+	*content->cell = (char *) mbvalidate((unsigned char *) cell,
+										 content->opt->encoding);
+
+#ifdef ENABLE_NLS
+	if (translate)
+		*content->cell = _(*content->cell);
+#endif
+
+	if (mustfree)
+	{
+		if (content->cellmustfree == NULL)
+			content->cellmustfree = pg_local_calloc(
+				content->ncolumns * content->nrows + 1, sizeof(bool));
+
+		content->cellmustfree[content->cellsadded] = true;
+	}
+	content->cell++;
+	content->cellsadded++;
+}
+
+/*
+ * Add a footer to the table.
+ *
+ * Footers are added as elements of a singly-linked list, and the content is
+ * strdup'd, so there is no need to keep the original footer string around.
+ *
+ * Footers are never translated by the function.  If you want the footer
+ * translated you must do so yourself, before calling printTableAddFooter.	The
+ * reason this works differently to headers and cells is that footers tend to
+ * be made of up individually translated components, rather than being
+ * translated as a whole.
+ */
+void
+printTableAddFooter(printTableContent *const content, const char *footer)
+{
+	printTableFooter *f;
+
+	f = pg_local_calloc(1, sizeof(*f));
+	f->data = pg_strdup(footer);
+
+	if (content->footers == NULL)
+		content->footers = f;
+	else
+		content->footer->next = f;
+
+	content->footer = f;
+}
+
+/*
+ * Change the content of the last-added footer.
+ *
+ * The current contents of the last-added footer are freed, and replaced by the
+ * content given in *footer.  If there was no previous footer, add a new one.
+ *
+ * The content is strdup'd, so there is no need to keep the original string
+ * around.
+ */
+void
+printTableSetFooter(printTableContent *const content, const char *footer)
+{
+	if (content->footers != NULL)
+	{
+		free(content->footer->data);
+		content->footer->data = pg_strdup(footer);
+	}
+	else
+		printTableAddFooter(content, footer);
+}
+
+/*
+ * Free all memory allocated to this struct.
+ *
+ * Once this has been called, the struct is unusable unless you pass it to
+ * printTableInit() again.
+ */
+void
+printTableCleanup(printTableContent *const content)
+{
+	if (content->cellmustfree)
+	{
+		int i;
+		for (i = 0; i < content->nrows * content->ncolumns; i++)
+		{
+			if (content->cellmustfree[i])
+				free((char *) content->cells[i]);
+		}
+		free(content->cellmustfree);
+		content->cellmustfree = NULL;
+	}
+	free(content->headers);
+	free(content->cells);
+	free(content->aligns);
+
+	content->opt = NULL;
+	content->title = NULL;
+	content->headers = NULL;
+	content->cells = NULL;
+	content->aligns = NULL;
+	content->header = NULL;
+	content->cell = NULL;
+	content->align = NULL;
+
+	if (content->footers)
+	{
+		for (content->footer = content->footers; content->footer;)
+		{
+			printTableFooter *f;
+
+			f = content->footer;
+			content->footer = f->next;
+			free(f->data);
+			free(f);
+		}
+	}
+	content->footers = NULL;
+	content->footer = NULL;
+}
+
+/*
+ * IsPagerNeeded
+ *
+ * Setup pager if required
+ */
+static void
+IsPagerNeeded(const printTableContent *cont, const int extra_lines, FILE **fout,
+			  bool *is_pager)
+{
+	if (*fout == stdout)
+	{
+		int			lines;
+
+		if (cont->opt->expanded)
+			lines = (cont->ncolumns + 1) * cont->nrows;
+		else
+			lines = cont->nrows + 1;
+
+		if (!cont->opt->tuples_only)
+		{
+			printTableFooter *f;
+
+			/*
+			 * FIXME -- this is slightly bogus: it counts the number of
+			 * footers, not the number of lines in them.
+			 */
+			for (f = cont->footers; f; f = f->next)
+				lines++;
+		}
+
+		*fout = PageOutput(lines + extra_lines, cont->opt->pager);
+		*is_pager = (*fout != stdout);
+	}
+	else
+		*is_pager = false;
+}
+
+/*
+ * Use this to print just any table in the supported formats.
+ */
+void
+printTable(const printTableContent *cont, FILE *fout, FILE *flog)
+{
+	bool		is_pager = false;
+
+	if (cancel_pressed)
+		return;
+
+	if (cont->opt->format == PRINT_NOTHING)
+		return;
+
+	/* print_aligned_text() handles the pager itself */
+	if ((cont->opt->format != PRINT_ALIGNED &&
+		 cont->opt->format != PRINT_WRAPPED) ||
+		cont->opt->expanded)
+		IsPagerNeeded(cont, 0, &fout, &is_pager);
+
+	/* print the stuff */
+
+	if (flog)
+		print_aligned_text(cont, flog);
+
+	switch (cont->opt->format)
+	{
+		case PRINT_UNALIGNED:
+			if (cont->opt->expanded)
+				print_unaligned_vertical(cont, fout);
+			else
+				print_unaligned_text(cont, fout);
+			break;
+		case PRINT_ALIGNED:
+		case PRINT_WRAPPED:
+			if (cont->opt->expanded)
+				print_aligned_vertical(cont, fout);
+			else
+				print_aligned_text(cont, fout);
+			break;
+		case PRINT_HTML:
+			if (cont->opt->expanded)
+				print_html_vertical(cont, fout);
+			else
+				print_html_text(cont, fout);
+			break;
+		case PRINT_LATEX:
+			if (cont->opt->expanded)
+				print_latex_vertical(cont, fout);
+			else
+				print_latex_text(cont, fout);
+			break;
+		case PRINT_TROFF_MS:
+			if (cont->opt->expanded)
+				print_troff_ms_vertical(cont, fout);
+			else
+				print_troff_ms_text(cont, fout);
+			break;
+		default:
+			fprintf(stderr, _("invalid output format (internal error): %d"),
+					cont->opt->format);
+			exit(EXIT_FAILURE);
+	}
+
+	if (is_pager)
+		ClosePager(fout);
+}
+
+/*
+ * Use this to print query results
+ *
+ * It calls printTable with all the things set straight.
+ */
+void
+printQuery(const PGresult *result, const printQueryOpt *opt, FILE *fout, FILE *flog)
+{
+	printTableContent cont;
+	int			i,
+				r,
+				c;
+
+	if (cancel_pressed)
+		return;
+
+	printTableInit(&cont, &opt->topt, opt->title,
+				   PQnfields(result), PQntuples(result));
+
+	for (i = 0; i < cont.ncolumns; i++)
+	{
+		char		align;
+		Oid			ftype = PQftype(result, i);
+
+		switch (ftype)
+		{
+			case INT2OID:
+			case INT4OID:
+			case INT8OID:
+			case FLOAT4OID:
+			case FLOAT8OID:
+			case NUMERICOID:
+			case OIDOID:
+			case XIDOID:
+			case CIDOID:
+			case CASHOID:
+				align = 'r';
+				break;
+			default:
+				align = 'l';
+				break;
+		}
+
+		printTableAddHeader(&cont, PQfname(result, i),
+							opt->translate_header, align);
+	}
+
+	/* set cells */
+	for (r = 0; r < cont.nrows; r++)
+	{
+		for (c = 0; c < cont.ncolumns; c++)
+		{
+			char	   *cell;
+			bool		mustfree = false;
+			bool		translate;
+
+			if (PQgetisnull(result, r, c))
+				cell = opt->nullPrint ? opt->nullPrint : "";
+			else
+			{
+				cell = PQgetvalue(result, r, c);
+				if (cont.aligns[c] == 'r' && opt->topt.numericLocale)
+				{
+					cell = format_numeric_locale(cell);
+					mustfree = true;
+				}
+			}
+
+			translate = (opt->translate_columns && opt->translate_columns[c]);
+			printTableAddCell(&cont, cell, translate, mustfree);
+		}
+	}
+
+	/* set footers */
+	if (opt->footers)
+	{
+		char	  **footer;
+
+		for (footer = opt->footers; *footer; footer++)
+			printTableAddFooter(&cont, *footer);
+	}
+	else if (!opt->topt.expanded && opt->default_footer)
+	{
+		unsigned long total_records;
+		char		default_footer[100];
+
+		total_records = opt->topt.prior_records + cont.nrows;
+		snprintf(default_footer, sizeof(default_footer),
+				 ngettext("(%lu row)", "(%lu rows)", total_records),
+				 total_records);
+
+		printTableAddFooter(&cont, default_footer);
+	}
+
+	printTable(&cont, fout, flog);
+	printTableCleanup(&cont);
+}
+
+
+void
+setDecimalLocale(void)
+{
+	struct lconv *extlconv;
+
+	extlconv = localeconv();
+
+	if (*extlconv->decimal_point)
+		decimal_point = pg_strdup(extlconv->decimal_point);
+	else
+		decimal_point = ".";	/* SQL output standard */
+	if (*extlconv->grouping && atoi(extlconv->grouping) > 0)
+		grouping = pg_strdup(extlconv->grouping);
+	else
+		grouping = "3";			/* most common */
+
+	/* similar code exists in formatting.c */
+	if (*extlconv->thousands_sep)
+		thousands_sep = pg_strdup(extlconv->thousands_sep);
+	/* Make sure thousands separator doesn't match decimal point symbol. */
+	else if (strcmp(decimal_point, ",") != 0)
+		thousands_sep = ",";
+	else
+		thousands_sep = ".";
+}
+
+/*
+ * Compute the byte distance to the end of the string or *target_width
+ * display character positions, whichever comes first.	Update *target_width
+ * to be the number of display character positions actually filled.
+ */
+static int
+strlen_max_width(unsigned char *str, int *target_width, int encoding)
+{
+	unsigned char *start = str;
+	unsigned char *end = str + strlen((char *) str);
+	int			curr_width = 0;
+
+	while (str < end)
+	{
+		int			char_width = PQdsplen((char *) str, encoding);
+
+		/*
+		 * If the display width of the new character causes the string to
+		 * exceed its target width, skip it and return.  However, if this is
+		 * the first character of the string (curr_width == 0), we have to
+		 * accept it.
+		 */
+		if (*target_width < curr_width + char_width && curr_width != 0)
+			break;
+
+		curr_width += char_width;
+
+		str += PQmblen((char *) str, encoding);
+	}
+
+	*target_width = curr_width;
+
+	return str - start;
+}
diff --git a/src/bin/psql/psqlscan.c b/src/bin/psql/psqlscan.c
new file mode 100644
index 0000000..8bf2cd7
--- /dev/null
+++ b/src/bin/psql/psqlscan.c
@@ -0,0 +1,7248 @@
+#line 2 "psqlscan.c"
+
+#line 4 "psqlscan.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+static yyconst flex_int16_t yy_nxt[][44] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0
+    },
+
+    {
+       37,   38,   39,   40,   39,   41,   42,   43,   44,   41,
+       45,   46,   47,   44,   44,   48,   49,   50,   51,   52,
+       52,   53,   54,   55,   56,   55,   55,   57,   55,   58,
+       55,   55,   59,   60,   61,   41,   56,   55,   58,   55,
+       55,   60,   41,   55
+
+    },
+
+    {
+       37,   38,   39,   40,   39,   41,   42,   43,   44,   41,
+       45,   46,   47,   44,   44,   48,   49,   50,   51,   52,
+       52,   53,   54,   55,   56,   55,   55,   57,   55,   58,
+       55,   55,   59,   60,   61,   41,   56,   55,   58,   55,
+       55,   60,   41,   55
+    },
+
+    {
+       37,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       63,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62
+
+    },
+
+    {
+       37,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       63,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62
+    },
+
+    {
+       37,   64,   64,   64,   64,   65,   64,   64,   65,   65,
+       64,   64,   64,   66,   65,   64,   65,   64,   67,   64,
+       64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
+       64,   64,   64,   64,   64,   65,   64,   64,   64,   64,
+       64,   64,   65,   64
+
+    },
+
+    {
+       37,   64,   64,   64,   64,   65,   64,   64,   65,   65,
+       64,   64,   64,   66,   65,   64,   65,   64,   67,   64,
+       64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
+       64,   64,   64,   64,   64,   65,   64,   64,   64,   64,
+       64,   64,   65,   64
+    },
+
+    {
+       37,   68,   68,   68,   68,   68,   69,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68
+
+    },
+
+    {
+       37,   68,   68,   68,   68,   68,   69,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68
+    },
+
+    {
+       37,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       71,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70
+
+    },
+
+    {
+       37,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       71,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+       70,   70,   70,   70
+    },
+
+    {
+       37,   72,   72,   73,   72,   72,   72,   72,   72,   72,
+       74,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   75,   72,   72,   72,   72,   72,
+       72,   72,   72,   72
+
+    },
+
+    {
+       37,   72,   72,   73,   72,   72,   72,   72,   72,   72,
+       74,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   75,   72,   72,   72,   72,   72,
+       72,   72,   72,   72
+    },
+
+    {
+       37,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       77,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76
+
+    },
+
+    {
+       37,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       77,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76
+    },
+
+    {
+       37,   78,   78,   79,   78,   78,   78,   80,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78
+
+    },
+
+    {
+       37,   78,   78,   79,   78,   78,   78,   80,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78
+    },
+
+    {
+       37,   68,   68,   68,   68,   68,   81,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68
+
+    },
+
+    {
+       37,   68,   68,   68,   68,   68,   81,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
+       68,   68,   68,   68
+    },
+
+    {
+       37,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       82,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76
+
+    },
+
+    {
+       37,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       82,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76
+    },
+
+    {
+       37,   83,   84,   85,   84,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   84,   83,   83,   83,   83,   83,
+       83,   83,   83,   83
+
+    },
+
+    {
+       37,   83,   84,   85,   84,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   84,   83,   83,   83,   83,   83,
+       83,   83,   83,   83
+    },
+
+    {
+       37,   86,   87,   88,   87,   86,   89,   86,   86,   86,
+       90,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   91,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   92,   93,   86,   86,   86,   86,
+       86,   86,   94,   86
+
+    },
+
+    {
+       37,   86,   87,   88,   87,   86,   89,   86,   86,   86,
+       90,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   91,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   92,   93,   86,   86,   86,   86,
+       86,   86,   94,   86
+    },
+
+    {
+       37,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       96,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   97,   95,   95,   95,   95,   95,
+       95,   95,   95,   95
+
+    },
+
+    {
+       37,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       96,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   97,   95,   95,   95,   95,   95,
+       95,   95,   95,   95
+    },
+
+    {
+       37,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   99,   98,   98,   98,   98,
+       98,   98,   98,   98
+
+    },
+
+    {
+       37,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
+       98,   98,   98,   98,   98,   99,   98,   98,   98,   98,
+       98,   98,   98,   98
+    },
+
+    {
+       37,  100,  101,  102,  101,  100,  103,  100,  100,  100,
+      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
+      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
+      100,  100,  100,  100,  104,  100,  100,  100,  100,  100,
+      100,  100,  100,  100
+
+    },
+
+    {
+       37,  100,  101,  102,  101,  100,  103,  100,  100,  100,
+      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
+      100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
+      100,  100,  100,  100,  104,  100,  100,  100,  100,  100,
+      100,  100,  100,  100
+    },
+
+    {
+       37,  105,  105,  105,  105,  105,  106,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105
+
+    },
+
+    {
+       37,  105,  105,  105,  105,  105,  106,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105,  105,  105,  105,  105,  105,  105,
+      105,  105,  105,  105
+    },
+
+    {
+       37,  107,  108,  109,  108,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107
+
+    },
+
+    {
+       37,  107,  108,  109,  108,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107
+    },
+
+    {
+       37,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  111,  110,  110,  110,  110,  110,
+      110,  110,  110,  110
+
+    },
+
+    {
+       37,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  111,  110,  110,  110,  110,  110,
+      110,  110,  110,  110
+    },
+
+    {
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37
+
+    },
+
+    {
+       37,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38
+    },
+
+    {
+       37,  -39,  112,  112,  112,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39
+
+    },
+
+    {
+       37,  -40,  112,  112,  112,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40
+    },
+
+    {
+       37,  -41,  -41,  -41,  -41,  113,  -41,  -41,  113,  113,
+      -41,  -41,  -41,  113,  113,  -41,  113,  -41,  113,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  113,  -41,  -41,  -41,  -41,
+      -41,  -41,  113,  -41
+
+    },
+
+    {
+       37,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42
+    },
+
+    {
+       37,  -43,  -43,  -43,  -43,  -43,  -43,  114,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  115,
+      115,  -43,  -43,  116,  116,  116,  116,  116,  116,  116,
+      116,  116,  116,  116,  -43,  -43,  116,  116,  116,  116,
+      116,  116,  -43,  116
+
+    },
+
+    {
+       37,  -44,  -44,  -44,  -44,  113,  -44,  -44,  113,  113,
+      -44,  -44,  -44,  113,  113,  -44,  113,  -44,  113,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  113,  -44,  -44,  -44,  -44,
+      -44,  -44,  113,  -44
+    },
+
+    {
+       37,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45
+
+    },
+
+    {
+       37,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46
+    },
+
+    {
+       37,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47
+
+    },
+
+    {
+       37,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48
+    },
+
+    {
+       37,  -49,  -49,  -49,  -49,  113,  -49,  -49,  113,  113,
+      -49,  -49,  -49,  113,  113,  -49,  117,  -49,  113,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  113,  -49,  -49,  -49,  -49,
+      -49,  -49,  113,  -49
+
+    },
+
+    {
+       37,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  118,
+      118,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50
+    },
+
+    {
+       37,  -51,  -51,  -51,  -51,  113,  -51,  -51,  113,  113,
+      -51,  -51,  -51,  119,  113,  -51,  113,  -51,  113,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  113,  -51,  -51,  -51,  -51,
+      -51,  -51,  113,  -51
+
+    },
+
+    {
+       37,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  120,  -52,  121,
+      121,  -52,  -52,  -52,  -52,  -52,  -52,  122,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52
+    },
+
+    {
+       37,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  123,
+      123,  124,  -53,  123,  123,  123,  123,  123,  123,  123,
+      123,  123,  123,  123,  -53,  -53,  123,  123,  123,  123,
+      123,  123,  -53,  -53
+
+    },
+
+    {
+       37,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54
+    },
+
+    {
+       37,  -55,  -55,  -55,  -55,  -55,  -55,  125,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  125,
+      125,  -55,  -55,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -55,  -55,  125,  125,  125,  125,
+      125,  125,  -55,  125
+
+    },
+
+    {
+       37,  -56,  -56,  -56,  -56,  -56,  -56,  125,  -56,  -56,
+      126,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  125,
+      125,  -56,  -56,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -56,  -56,  125,  125,  125,  125,
+      125,  125,  -56,  125
+    },
+
+    {
+       37,  -57,  -57,  -57,  -57,  -57,  -57,  125,  -57,  -57,
+      127,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  125,
+      125,  -57,  -57,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -57,  -57,  125,  125,  125,  125,
+      125,  125,  -57,  125
+
+    },
+
+    {
+       37,  -58,  -58,  -58,  -58,  -58,  -58,  125,  -58,  -58,
+      128,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  125,
+      125,  -58,  -58,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -58,  -58,  125,  125,  125,  125,
+      125,  125,  -58,  125
+    },
+
+    {
+       37,  -59,  -59,  -59,  -59,  -59,  -59,  125,  -59,  129,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  125,
+      125,  -59,  -59,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -59,  -59,  125,  125,  125,  125,
+      125,  125,  -59,  125
+
+    },
+
+    {
+       37,  -60,  -60,  -60,  -60,  -60,  -60,  125,  -60,  -60,
+      130,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  125,
+      125,  -60,  -60,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125,  -60,  -60,  125,  125,  125,  125,
+      125,  125,  -60,  125
+    },
+
+    {
+       37,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  131,  131,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,  -61
+
+    },
+
+    {
+       37,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      -62,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132
+    },
+
+    {
+       37,  -63,  133,  134,  134,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,  -63,  -63,  -63,  135,  -63,  -63,  -63,
+      -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,  -63
+
+    },
+
+    {
+       37,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  -64,  136,  136,  136,  136,  -64,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136
+    },
+
+    {
+       37,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  -65,  136,  136,  136,  136,  -65,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136
+
+    },
+
+    {
+       37,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,  137,  -66,  -66,  -66,  -66,  138,  -66,
+      -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,  -66
+    },
+
+    {
+       37,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,  139,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,  -67
+
+    },
+
+    {
+       37,  140,  140,  140,  140,  140,  -68,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140
+    },
+
+    {
+       37,  -69,  -69,  -69,  -69,  -69,  141,  -69,  -69,  -69,
+      -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,  -69
+
+    },
+
+    {
+       37,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      -70,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142
+    },
+
+    {
+       37,  -71,  143,  144,  144,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,  -71,  -71,  -71,  145,  -71,  -71,  -71,
+      -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,  -71
+
+    },
+
+    {
+       37,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      -72,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146,  -72,  146,  146,  146,  146,  146,
+      146,  146,  146,  146
+    },
+
+    {
+       37,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      -73,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146,  -73,  146,  146,  146,  146,  146,
+      146,  146,  146,  146
+
+    },
+
+    {
+       37,  -74,  147,  148,  148,  -74,  -74,  -74,  -74,  -74,
+      149,  -74,  -74,  -74,  -74,  -74,  150,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74
+    },
+
+    {
+       37,  151,  151,  151,  151,  151,  151,  151,  151,  151,
+      151,  151,  151,  151,  151,  151,  151,  151,  151,  152,
+      151,  151,  151,  151,  151,  151,  151,  151,  151,  151,
+      151,  151,  151,  151,  151,  151,  151,  151,  151,  151,
+      151,  153,  151,  151
+
+    },
+
+    {
+       37,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      -76,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154
+    },
+
+    {
+       37,  -77,  147,  148,  148,  -77,  -77,  -77,  -77,  -77,
+      149,  -77,  -77,  -77,  -77,  -77,  150,  -77,  -77,  -77,
+      -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,
+      -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,  -77,
+      -77,  -77,  -77,  -77
+
+    },
+
+    {
+       37,  155,  155,  155,  155,  155,  155,  -78,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155
+    },
+
+    {
+       37,  155,  155,  155,  155,  155,  155,  -79,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155
+
+    },
+
+    {
+       37,  -80,  -80,  -80,  -80,  -80,  -80,  156,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  157,  157,  157,  157,  157,  157,  157,
+      157,  157,  157,  157,  -80,  -80,  157,  157,  157,  157,
+      157,  157,  -80,  157
+    },
+
+    {
+       37,  -81,  158,  158,  158,  -81,  141,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  159,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  160,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81
+
+    },
+
+    {
+       37,  -82,  161,  162,  162,  -82,  -82,  -82,  -82,  -82,
+      149,  -82,  -82,  -82,  -82,  -82,  163,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  164,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82
+    },
+
+    {
+       37,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83
+
+    },
+
+    {
+       37,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84
+    },
+
+    {
+       37,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85
+
+    },
+
+    {
+       37,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86
+    },
+
+    {
+       37,  -87,  165,  165,  165,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87
+
+    },
+
+    {
+       37,  -88,  165,  165,  165,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,  -88
+    },
+
+    {
+       37,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,  -89
+
+    },
+
+    {
+       37,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90
+    },
+
+    {
+       37,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,
+      -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  166,
+      166,  -91,  -91,  166,  166,  166,  166,  166,  166,  166,
+      166,  166,  166,  166,  -91,  -91,  166,  166,  166,  166,
+      166,  166,  -91,  -91
+
+    },
+
+    {
+       37,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,  -92
+    },
+
+    {
+       37,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93
+
+    },
+
+    {
+       37,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,  -94
+    },
+
+    {
+       37,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,  -95
+
+    },
+
+    {
+       37,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      167,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,  -96
+    },
+
+    {
+       37,  168,  168,  -97,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  169,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  170,  171,  172,  173,
+      174,  175,  168,  168
+
+    },
+
+    {
+       37,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,  -98
+    },
+
+    {
+       37,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,  -99
+
+    },
+
+    {
+       37, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100, -100
+    },
+
+    {
+       37, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101, -101
+
+    },
+
+    {
+       37, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102, -102
+    },
+
+    {
+       37, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103, -103
+
+    },
+
+    {
+       37, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104, -104
+    },
+
+    {
+       37, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105, -105
+
+    },
+
+    {
+       37, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106
+    },
+
+    {
+       37, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107, -107, -107, -107
+
+    },
+
+    {
+       37, -108,  176,  176,  176, -108, -108, -108, -108, -108,
+     -108, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108, -108
+    },
+
+    {
+       37, -109,  176,  176,  176, -109, -109, -109, -109, -109,
+     -109, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109, -109
+
+    },
+
+    {
+       37, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110, -110
+    },
+
+    {
+       37, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111, -111,  177, -111, -111, -111, -111, -111,
+     -111, -111, -111, -111
+
+    },
+
+    {
+       37, -112,  112,  112,  112, -112, -112, -112, -112, -112,
+     -112, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112, -112
+    },
+
+    {
+       37, -113, -113, -113, -113,  113, -113, -113,  113,  113,
+     -113, -113, -113,  113,  113, -113,  113, -113,  113, -113,
+     -113, -113, -113, -113, -113, -113, -113, -113, -113, -113,
+     -113, -113, -113, -113, -113,  113, -113, -113, -113, -113,
+     -113, -113,  113, -113
+
+    },
+
+    {
+       37, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114, -114
+    },
+
+    {
+       37, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115, -115, -115, -115, -115, -115, -115,  115,
+      115, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115, -115
+
+    },
+
+    {
+       37, -116, -116, -116, -116, -116, -116,  114, -116, -116,
+     -116, -116, -116, -116, -116, -116, -116, -116, -116,  178,
+      178, -116, -116,  178,  178,  178,  178,  178,  178,  178,
+      178,  178,  178,  178, -116, -116,  178,  178,  178,  178,
+      178,  178, -116,  178
+    },
+
+    {
+       37,  179,  179, -117, -117,  180,  179,  179,  180,  180,
+      179,  179,  179,  180,  180,  179,  180,  179,  180,  179,
+      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179,  179,  180,  179,  179,  179,  179,
+      179,  179,  180,  179
+
+    },
+
+    {
+       37, -118, -118, -118, -118, -118, -118, -118, -118, -118,
+     -118, -118, -118, -118, -118, -118, -118, -118, -118,  118,
+      118, -118, -118, -118, -118, -118, -118,  122, -118, -118,
+     -118, -118, -118, -118, -118, -118, -118, -118, -118, -118,
+     -118, -118, -118, -118
+    },
+
+    {
+       37, -119, -119, -119, -119,  181, -119, -119,  181,  181,
+     -119, -119, -119,  181,  181, -119,  181, -119,  181, -119,
+     -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
+     -119, -119, -119, -119, -119,  181, -119, -119, -119, -119,
+     -119, -119,  181, -119
+
+    },
+
+    {
+       37, -120, -120, -120, -120, -120, -120, -120, -120, -120,
+     -120, -120, -120, -120, -120, -120, -120, -120, -120,  182,
+      182, -120, -120, -120, -120, -120, -120,  122, -120, -120,
+     -120, -120, -120, -120, -120, -120, -120, -120, -120, -120,
+     -120, -120, -120, -120
+    },
+
+    {
+       37, -121, -121, -121, -121, -121, -121, -121, -121, -121,
+     -121, -121, -121, -121, -121, -121, -121,  120, -121,  121,
+      121, -121, -121, -121, -121, -121, -121,  122, -121, -121,
+     -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
+     -121, -121, -121, -121
+
+    },
+
+    {
+       37, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122, -122,  183, -122,  183, -122, -122,  184,
+      184, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122, -122
+    },
+
+    {
+       37, -123, -123, -123, -123, -123, -123, -123, -123, -123,
+     -123, -123, -123, -123, -123, -123, -123, -123, -123,  123,
+      123, -123, -123,  123,  123,  123,  123,  123,  123,  123,
+      123,  123,  123,  123, -123, -123,  123,  123,  123,  123,
+      123,  123, -123, -123
+
+    },
+
+    {
+       37, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124, -124
+    },
+
+    {
+       37, -125, -125, -125, -125, -125, -125,  125, -125, -125,
+     -125, -125, -125, -125, -125, -125, -125, -125, -125,  125,
+      125, -125, -125,  125,  125,  125,  125,  125,  125,  125,
+      125,  125,  125,  125, -125, -125,  125,  125,  125,  125,
+      125,  125, -125,  125
+
+    },
+
+    {
+       37, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126, -126
+    },
+
+    {
+       37, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127, -127
+
+    },
+
+    {
+       37, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128, -128
+    },
+
+    {
+       37, -129, -129, -129, -129, -129,  185, -129, -129, -129,
+      186, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129, -129
+
+    },
+
+    {
+       37, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130, -130
+    },
+
+    {
+       37, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131, -131
+
+    },
+
+    {
+       37,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+     -132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
+      132,  132,  132,  132
+    },
+
+    {
+       37, -133,  133,  134,  134, -133, -133, -133, -133, -133,
+     -133, -133, -133, -133, -133, -133,  135, -133, -133, -133,
+     -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
+     -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
+     -133, -133, -133, -133
+
+    },
+
+    {
+       37, -134,  187,  187,  187, -134, -134, -134, -134, -134,
+      188, -134, -134, -134, -134, -134,  189, -134, -134, -134,
+     -134, -134, -134, -134, -134, -134, -134, -134, -134, -134,
+     -134, -134, -134, -134, -134, -134, -134, -134, -134, -134,
+     -134, -134, -134, -134
+    },
+
+    {
+       37, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135, -135, -135, -135,  190, -135, -135, -135,
+     -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135, -135
+
+    },
+
+    {
+       37,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136, -136,  136,  136,  136,  136, -136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136
+    },
+
+    {
+       37, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137,  137, -137, -137, -137, -137,  138, -137,
+     -137, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137, -137
+
+    },
+
+    {
+       37, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138, -138
+    },
+
+    {
+       37, -139, -139, -139, -139,  191, -139, -139,  191,  191,
+     -139, -139, -139,  191,  191, -139,  191, -139,  191, -139,
+     -139, -139, -139, -139, -139, -139, -139, -139, -139, -139,
+     -139, -139, -139, -139, -139,  191, -139, -139, -139, -139,
+     -139, -139,  191, -139
+
+    },
+
+    {
+       37,  140,  140,  140,  140,  140, -140,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  140,  140,  140
+    },
+
+    {
+       37, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141, -141
+
+    },
+
+    {
+       37,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+     -142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
+      142,  142,  142,  142
+    },
+
+    {
+       37, -143,  143,  144,  144, -143, -143, -143, -143, -143,
+     -143, -143, -143, -143, -143, -143,  145, -143, -143, -143,
+     -143, -143, -143, -143, -143, -143, -143, -143, -143, -143,
+     -143, -143, -143, -143, -143, -143, -143, -143, -143, -143,
+     -143, -143, -143, -143
+
+    },
+
+    {
+       37, -144,  192,  192,  192, -144, -144, -144, -144, -144,
+      193, -144, -144, -144, -144, -144,  194, -144, -144, -144,
+     -144, -144, -144, -144, -144, -144, -144, -144, -144, -144,
+     -144, -144, -144, -144, -144, -144, -144, -144, -144, -144,
+     -144, -144, -144, -144
+    },
+
+    {
+       37, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145, -145, -145, -145,  195, -145, -145, -145,
+     -145, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145, -145
+
+    },
+
+    {
+       37,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+     -146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146, -146,  146,  146,  146,  146,  146,
+      146,  146,  146,  146
+    },
+
+    {
+       37, -147,  147,  148,  148, -147, -147, -147, -147, -147,
+     -147, -147, -147, -147, -147, -147,  150, -147, -147, -147,
+     -147, -147, -147, -147, -147, -147, -147, -147, -147, -147,
+     -147, -147, -147, -147, -147, -147, -147, -147, -147, -147,
+     -147, -147, -147, -147
+
+    },
+
+    {
+       37, -148,  196,  196,  196, -148, -148, -148, -148, -148,
+      197, -148, -148, -148, -148, -148,  198, -148, -148, -148,
+     -148, -148, -148, -148, -148, -148, -148, -148, -148, -148,
+     -148, -148, -148, -148, -148, -148, -148, -148, -148, -148,
+     -148, -148, -148, -148
+    },
+
+    {
+       37, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149, -149
+
+    },
+
+    {
+       37, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150, -150, -150, -150,  199, -150, -150, -150,
+     -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150, -150
+    },
+
+    {
+       37, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151, -151
+
+    },
+
+    {
+       37, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152, -152, -152, -152, -152, -152, -152,  200,
+     -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152, -152
+    },
+
+    {
+       37, -153, -153, -153, -153, -153, -153, -153, -153, -153,
+     -153, -153, -153, -153, -153, -153, -153, -153, -153,  201,
+      201, -153, -153,  201,  201,  201,  201,  201, -153, -153,
+     -153, -153, -153, -153, -153, -153,  201,  201, -153, -153,
+     -153, -153, -153, -153
+
+    },
+
+    {
+       37,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+     -154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154,  154,  154,  154,  154,  154,  154,
+      154,  154,  154,  154
+    },
+
+    {
+       37,  155,  155,  155,  155,  155,  155, -155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,  155
+
+    },
+
+    {
+       37, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156, -156
+    },
+
+    {
+       37, -157, -157, -157, -157, -157, -157,  156, -157, -157,
+     -157, -157, -157, -157, -157, -157, -157, -157, -157,  202,
+      202, -157, -157,  202,  202,  202,  202,  202,  202,  202,
+      202,  202,  202,  202, -157, -157,  202,  202,  202,  202,
+      202,  202, -157,  202
+
+    },
+
+    {
+       37, -158,  158,  158,  158, -158, -158, -158, -158, -158,
+     -158, -158, -158, -158, -158, -158,  159, -158, -158, -158,
+     -158, -158, -158, -158, -158, -158, -158, -158, -158, -158,
+     -158, -158,  160, -158, -158, -158, -158, -158, -158, -158,
+     -158, -158, -158, -158
+    },
+
+    {
+       37, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159, -159, -159, -159,  203, -159, -159, -159,
+     -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159, -159
+
+    },
+
+    {
+       37, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160, -160, -160, -160, -160,  204, -160, -160,
+     -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160, -160
+    },
+
+    {
+       37, -161,  161,  162,  162, -161, -161, -161, -161, -161,
+     -161, -161, -161, -161, -161, -161,  163, -161, -161, -161,
+     -161, -161, -161, -161, -161, -161, -161, -161, -161, -161,
+     -161, -161,  164, -161, -161, -161, -161, -161, -161, -161,
+     -161, -161, -161, -161
+
+    },
+
+    {
+       37, -162,  205,  205,  205, -162, -162, -162, -162, -162,
+      197, -162, -162, -162, -162, -162,  206, -162, -162, -162,
+     -162, -162, -162, -162, -162, -162, -162, -162, -162, -162,
+     -162, -162,  164, -162, -162, -162, -162, -162, -162, -162,
+     -162, -162, -162, -162
+    },
+
+    {
+       37, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163, -163, -163, -163,  207, -163, -163, -163,
+     -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163, -163
+
+    },
+
+    {
+       37, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164, -164, -164, -164, -164,  208, -164, -164,
+     -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164, -164
+    },
+
+    {
+       37, -165,  165,  165,  165, -165, -165, -165, -165, -165,
+     -165, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165, -165
+
+    },
+
+    {
+       37, -166, -166, -166, -166, -166, -166, -166, -166, -166,
+     -166, -166, -166, -166, -166, -166, -166, -166, -166,  166,
+      166, -166, -166,  166,  166,  166,  166,  166,  166,  166,
+      166,  166,  166,  166, -166, -166,  166,  166,  166,  166,
+      166,  166, -166, -166
+    },
+
+    {
+       37, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167, -167
+
+    },
+
+    {
+       37, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168, -168
+    },
+
+    {
+       37, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169, -169, -169, -169, -169, -169, -169,  209,
+     -169, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169, -169
+
+    },
+
+    {
+       37, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170, -170
+    },
+
+    {
+       37, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171, -171
+
+    },
+
+    {
+       37, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172, -172
+    },
+
+    {
+       37, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+     -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+     -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+     -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+     -173, -173, -173, -173
+
+    },
+
+    {
+       37, -174, -174, -174, -174, -174, -174, -174, -174, -174,
+     -174, -174, -174, -174, -174, -174, -174, -174, -174, -174,
+     -174, -174, -174, -174, -174, -174, -174, -174, -174, -174,
+     -174, -174, -174, -174, -174, -174, -174, -174, -174, -174,
+     -174, -174, -174, -174
+    },
+
+    {
+       37, -175, -175, -175, -175, -175, -175, -175, -175, -175,
+     -175, -175, -175, -175, -175, -175, -175, -175, -175,  210,
+      210, -175, -175,  210,  210,  210,  210,  210, -175, -175,
+     -175, -175, -175, -175, -175, -175,  210,  210, -175, -175,
+     -175, -175, -175, -175
+
+    },
+
+    {
+       37, -176,  176,  176,  176, -176, -176, -176, -176, -176,
+     -176, -176, -176, -176, -176, -176, -176, -176, -176, -176,
+     -176, -176, -176, -176, -176, -176, -176, -176, -176, -176,
+     -176, -176, -176, -176, -176, -176, -176, -176, -176, -176,
+     -176, -176, -176, -176
+    },
+
+    {
+       37, -177, -177, -177, -177, -177, -177, -177, -177, -177,
+     -177, -177, -177, -177, -177, -177, -177, -177, -177, -177,
+     -177, -177, -177, -177, -177, -177, -177, -177, -177, -177,
+     -177, -177, -177, -177, -177, -177, -177, -177, -177, -177,
+     -177, -177, -177, -177
+
+    },
+
+    {
+       37, -178, -178, -178, -178, -178, -178,  114, -178, -178,
+     -178, -178, -178, -178, -178, -178, -178, -178, -178,  178,
+      178, -178, -178,  178,  178,  178,  178,  178,  178,  178,
+      178,  178,  178,  178, -178, -178,  178,  178,  178,  178,
+      178,  178, -178,  178
+    },
+
+    {
+       37,  179,  179, -179, -179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179
+
+    },
+
+    {
+       37,  179,  179, -180, -180,  180,  179,  179,  180,  180,
+      179,  179,  179,  180,  180,  179,  180,  179,  180,  179,
+      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
+      179,  179,  179,  179,  179,  180,  179,  179,  179,  179,
+      179,  179,  180,  179
+    },
+
+    {
+       37, -181, -181, -181, -181,  181, -181, -181,  181,  181,
+     -181, -181, -181,  181,  181, -181,  181, -181,  181, -181,
+     -181, -181, -181, -181, -181, -181, -181, -181, -181, -181,
+     -181, -181, -181, -181, -181,  181, -181, -181, -181, -181,
+     -181, -181,  181, -181
+
+    },
+
+    {
+       37, -182, -182, -182, -182, -182, -182, -182, -182, -182,
+     -182, -182, -182, -182, -182, -182, -182, -182, -182,  182,
+      182, -182, -182, -182, -182, -182, -182,  122, -182, -182,
+     -182, -182, -182, -182, -182, -182, -182, -182, -182, -182,
+     -182, -182, -182, -182
+    },
+
+    {
+       37, -183, -183, -183, -183, -183, -183, -183, -183, -183,
+     -183, -183, -183, -183, -183, -183, -183, -183, -183,  184,
+      184, -183, -183, -183, -183, -183, -183, -183, -183, -183,
+     -183, -183, -183, -183, -183, -183, -183, -183, -183, -183,
+     -183, -183, -183, -183
+
+    },
+
+    {
+       37, -184, -184, -184, -184, -184, -184, -184, -184, -184,
+     -184, -184, -184, -184, -184, -184, -184, -184, -184,  184,
+      184, -184, -184, -184, -184, -184, -184, -184, -184, -184,
+     -184, -184, -184, -184, -184, -184, -184, -184, -184, -184,
+     -184, -184, -184, -184
+    },
+
+    {
+       37, -185, -185, -185, -185, -185, -185, -185, -185, -185,
+     -185, -185, -185, -185, -185, -185, -185, -185, -185, -185,
+     -185, -185, -185, -185, -185, -185, -185, -185, -185, -185,
+     -185, -185, -185, -185, -185, -185, -185, -185, -185, -185,
+     -185, -185, -185, -185
+
+    },
+
+    {
+       37, -186, -186, -186, -186, -186, -186, -186, -186, -186,
+     -186, -186, -186, -186, -186, -186, -186, -186, -186, -186,
+     -186, -186, -186, -186, -186, -186, -186, -186, -186, -186,
+     -186, -186, -186, -186, -186, -186, -186, -186, -186, -186,
+     -186, -186, -186, -186
+    },
+
+    {
+       37, -187,  187,  187,  187, -187, -187, -187, -187, -187,
+      188, -187, -187, -187, -187, -187,  189, -187, -187, -187,
+     -187, -187, -187, -187, -187, -187, -187, -187, -187, -187,
+     -187, -187, -187, -187, -187, -187, -187, -187, -187, -187,
+     -187, -187, -187, -187
+
+    },
+
+    {
+       37, -188, -188, -188, -188, -188, -188, -188, -188, -188,
+     -188, -188, -188, -188, -188, -188, -188, -188, -188, -188,
+     -188, -188, -188, -188, -188, -188, -188, -188, -188, -188,
+     -188, -188, -188, -188, -188, -188, -188, -188, -188, -188,
+     -188, -188, -188, -188
+    },
+
+    {
+       37, -189, -189, -189, -189, -189, -189, -189, -189, -189,
+     -189, -189, -189, -189, -189, -189,  211, -189, -189, -189,
+     -189, -189, -189, -189, -189, -189, -189, -189, -189, -189,
+     -189, -189, -189, -189, -189, -189, -189, -189, -189, -189,
+     -189, -189, -189, -189
+
+    },
+
+    {
+       37,  212,  213,  134,  134,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  214,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212
+    },
+
+    {
+       37, -191, -191, -191, -191,  191, -191, -191,  191,  191,
+     -191, -191, -191,  191,  191, -191,  191, -191,  191, -191,
+     -191, -191, -191, -191, -191, -191, -191, -191, -191, -191,
+     -191, -191, -191, -191, -191,  191, -191, -191, -191, -191,
+     -191, -191,  191, -191
+
+    },
+
+    {
+       37, -192,  192,  192,  192, -192, -192, -192, -192, -192,
+      193, -192, -192, -192, -192, -192,  194, -192, -192, -192,
+     -192, -192, -192, -192, -192, -192, -192, -192, -192, -192,
+     -192, -192, -192, -192, -192, -192, -192, -192, -192, -192,
+     -192, -192, -192, -192
+    },
+
+    {
+       37, -193, -193, -193, -193, -193, -193, -193, -193, -193,
+     -193, -193, -193, -193, -193, -193, -193, -193, -193, -193,
+     -193, -193, -193, -193, -193, -193, -193, -193, -193, -193,
+     -193, -193, -193, -193, -193, -193, -193, -193, -193, -193,
+     -193, -193, -193, -193
+
+    },
+
+    {
+       37, -194, -194, -194, -194, -194, -194, -194, -194, -194,
+     -194, -194, -194, -194, -194, -194,  215, -194, -194, -194,
+     -194, -194, -194, -194, -194, -194, -194, -194, -194, -194,
+     -194, -194, -194, -194, -194, -194, -194, -194, -194, -194,
+     -194, -194, -194, -194
+    },
+
+    {
+       37,  216,  217,  144,  144,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  218,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216
+
+    },
+
+    {
+       37, -196,  196,  196,  196, -196, -196, -196, -196, -196,
+      197, -196, -196, -196, -196, -196,  198, -196, -196, -196,
+     -196, -196, -196, -196, -196, -196, -196, -196, -196, -196,
+     -196, -196, -196, -196, -196, -196, -196, -196, -196, -196,
+     -196, -196, -196, -196
+    },
+
+    {
+       37, -197, -197, -197, -197, -197, -197, -197, -197, -197,
+     -197, -197, -197, -197, -197, -197, -197, -197, -197, -197,
+     -197, -197, -197, -197, -197, -197, -197, -197, -197, -197,
+     -197, -197, -197, -197, -197, -197, -197, -197, -197, -197,
+     -197, -197, -197, -197
+
+    },
+
+    {
+       37, -198, -198, -198, -198, -198, -198, -198, -198, -198,
+     -198, -198, -198, -198, -198, -198,  219, -198, -198, -198,
+     -198, -198, -198, -198, -198, -198, -198, -198, -198, -198,
+     -198, -198, -198, -198, -198, -198, -198, -198, -198, -198,
+     -198, -198, -198, -198
+    },
+
+    {
+       37,  220,  221,  148,  148,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  222,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220
+
+    },
+
+    {
+       37, -200, -200, -200, -200, -200, -200, -200, -200, -200,
+     -200, -200, -200, -200, -200, -200, -200, -200, -200,  223,
+     -200, -200, -200, -200, -200, -200, -200, -200, -200, -200,
+     -200, -200, -200, -200, -200, -200, -200, -200, -200, -200,
+     -200, -200, -200, -200
+    },
+
+    {
+       37, -201, -201, -201, -201, -201, -201, -201, -201, -201,
+     -201, -201, -201, -201, -201, -201, -201, -201, -201,  224,
+      224, -201, -201,  224,  224,  224,  224,  224, -201, -201,
+     -201, -201, -201, -201, -201, -201,  224,  224, -201, -201,
+     -201, -201, -201, -201
+
+    },
+
+    {
+       37, -202, -202, -202, -202, -202, -202,  156, -202, -202,
+     -202, -202, -202, -202, -202, -202, -202, -202, -202,  202,
+      202, -202, -202,  202,  202,  202,  202,  202,  202,  202,
+      202,  202,  202,  202, -202, -202,  202,  202,  202,  202,
+      202,  202, -202,  202
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37, -204, -204, -204, -204, -204, -204, -204, -204, -204,
+     -204, -204, -204, -204, -204, -204, -204, -204, -204, -204,
+     -204, -204, -204, -204, -204, -204, -204, -204, -204, -204,
+     -204,  229, -204, -204, -204, -204, -204, -204, -204, -204,
+     -204, -204, -204, -204
+    },
+
+    {
+       37, -205,  205,  205,  205, -205, -205, -205, -205, -205,
+      197, -205, -205, -205, -205, -205,  206, -205, -205, -205,
+     -205, -205, -205, -205, -205, -205, -205, -205, -205, -205,
+     -205, -205,  164, -205, -205, -205, -205, -205, -205, -205,
+     -205, -205, -205, -205
+
+    },
+
+    {
+       37, -206, -206, -206, -206, -206, -206, -206, -206, -206,
+     -206, -206, -206, -206, -206, -206,  230, -206, -206, -206,
+     -206, -206, -206, -206, -206, -206, -206, -206, -206, -206,
+     -206, -206, -206, -206, -206, -206, -206, -206, -206, -206,
+     -206, -206, -206, -206
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37, -208, -208, -208, -208, -208, -208, -208, -208, -208,
+     -208, -208, -208, -208, -208, -208, -208, -208, -208, -208,
+     -208, -208, -208, -208, -208, -208, -208, -208, -208, -208,
+     -208,  235, -208, -208, -208, -208, -208, -208, -208, -208,
+     -208, -208, -208, -208
+    },
+
+    {
+       37, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209,  236,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209
+
+    },
+
+    {
+       37, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210,  237,
+      237, -210, -210,  237,  237,  237,  237,  237, -210, -210,
+     -210, -210, -210, -210, -210, -210,  237,  237, -210, -210,
+     -210, -210, -210, -210
+    },
+
+    {
+       37,  238,  239,  240,  240,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  241,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238
+
+    },
+
+    {
+       37,  212,  213,  134,  134,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  214,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212
+    },
+
+    {
+       37,  212,  213,  134,  134,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  214,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212
+
+    },
+
+    {
+       37,  212,  213,  134,  134,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  242,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212
+    },
+
+    {
+       37,  243,  244,  245,  245,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  246,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243
+
+    },
+
+    {
+       37,  216,  217,  144,  144,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  218,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216
+    },
+
+    {
+       37,  216,  217,  144,  144,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  218,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216
+
+    },
+
+    {
+       37,  216,  217,  144,  144,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  247,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216
+    },
+
+    {
+       37,  248,  249,  250,  250,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  251,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248
+
+    },
+
+    {
+       37,  220,  221,  148,  148,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  222,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220
+    },
+
+    {
+       37,  220,  221,  148,  148,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  222,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220
+
+    },
+
+    {
+       37,  220,  221,  148,  148,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  252,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220
+    },
+
+    {
+       37, -223, -223, -223, -223, -223, -223, -223, -223, -223,
+     -223, -223, -223, -223, -223, -223, -223, -223, -223, -223,
+     -223, -223, -223, -223, -223, -223, -223, -223, -223, -223,
+     -223, -223, -223, -223, -223, -223, -223, -223, -223, -223,
+     -223, -223, -223, -223
+
+    },
+
+    {
+       37, -224, -224, -224, -224, -224, -224, -224, -224, -224,
+     -224, -224, -224, -224, -224, -224, -224, -224, -224, -224,
+     -224, -224, -224, -224, -224, -224, -224, -224, -224, -224,
+     -224, -224, -224, -224, -224, -224, -224, -224, -224, -224,
+     -224, -224, -224, -224
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  253,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  254,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -229, -229, -229, -229, -229, -229, -229, -229, -229,
+     -229, -229, -229, -229, -229, -229, -229, -229, -229, -229,
+     -229, -229, -229, -229, -229,  255, -229, -229, -229, -229,
+     -229, -229, -229, -229, -229, -229, -229, -229, -229, -229,
+     -229, -229, -229, -229
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  261,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  262,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -235, -235, -235, -235, -235, -235, -235, -235, -235,
+     -235, -235, -235, -235, -235, -235, -235, -235, -235, -235,
+     -235, -235, -235, -235, -235,  263, -235, -235, -235, -235,
+     -235, -235, -235, -235, -235, -235, -235, -235, -235, -235,
+     -235, -235, -235, -235
+
+    },
+
+    {
+       37, -236, -236, -236, -236, -236, -236, -236, -236, -236,
+     -236, -236, -236, -236, -236, -236, -236, -236, -236, -236,
+     -236, -236, -236, -236, -236, -236, -236, -236, -236, -236,
+     -236, -236, -236, -236, -236, -236, -236, -236, -236, -236,
+     -236, -236, -236, -236
+    },
+
+    {
+       37, -237, -237, -237, -237, -237, -237, -237, -237, -237,
+     -237, -237, -237, -237, -237, -237, -237, -237, -237, -237,
+     -237, -237, -237, -237, -237, -237, -237, -237, -237, -237,
+     -237, -237, -237, -237, -237, -237, -237, -237, -237, -237,
+     -237, -237, -237, -237
+
+    },
+
+    {
+       37,  238,  239,  240,  240,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  241,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238
+    },
+
+    {
+       37,  238,  239,  240,  240,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  241,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238
+
+    },
+
+    {
+       37, -240,  187,  187,  187, -240, -240, -240, -240, -240,
+      188, -240, -240, -240, -240, -240,  189, -240, -240, -240,
+     -240, -240, -240, -240, -240, -240, -240, -240, -240, -240,
+     -240, -240, -240, -240, -240, -240, -240, -240, -240, -240,
+     -240, -240, -240, -240
+    },
+
+    {
+       37,  238,  239,  240,  240,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  264,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238
+
+    },
+
+    {
+       37,  212,  213,  134,  134,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  242,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212
+    },
+
+    {
+       37,  243,  244,  245,  245,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  246,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243
+
+    },
+
+    {
+       37,  243,  244,  245,  245,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  246,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243
+    },
+
+    {
+       37, -245,  192,  192,  192, -245, -245, -245, -245, -245,
+      193, -245, -245, -245, -245, -245,  194, -245, -245, -245,
+     -245, -245, -245, -245, -245, -245, -245, -245, -245, -245,
+     -245, -245, -245, -245, -245, -245, -245, -245, -245, -245,
+     -245, -245, -245, -245
+
+    },
+
+    {
+       37,  243,  244,  245,  245,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  265,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243
+    },
+
+    {
+       37,  216,  217,  144,  144,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  247,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+      216,  216,  216,  216
+
+    },
+
+    {
+       37,  248,  249,  250,  250,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  251,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248
+    },
+
+    {
+       37,  248,  249,  250,  250,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  251,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248
+
+    },
+
+    {
+       37, -250,  196,  196,  196, -250, -250, -250, -250, -250,
+      197, -250, -250, -250, -250, -250,  198, -250, -250, -250,
+     -250, -250, -250, -250, -250, -250, -250, -250, -250, -250,
+     -250, -250, -250, -250, -250, -250, -250, -250, -250, -250,
+     -250, -250, -250, -250
+    },
+
+    {
+       37,  248,  249,  250,  250,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  266,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248
+
+    },
+
+    {
+       37,  220,  221,  148,  148,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  252,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  220
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  253,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  267,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -255, -255, -255, -255, -255, -255, -255, -255, -255,
+     -255, -255, -255, -255, -255, -255, -255, -255, -255, -255,
+     -255, -255, -255,  268, -255, -255, -255, -255, -255, -255,
+     -255, -255, -255, -255, -255, -255, -255, -255, -255, -255,
+     -255, -255, -255, -255
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37, -258,  205,  205,  205, -258, -258, -258, -258, -258,
+      197, -258, -258, -258, -258, -258,  206, -258, -258, -258,
+     -258, -258, -258, -258, -258, -258, -258, -258, -258, -258,
+     -258, -258,  164, -258, -258, -258, -258, -258, -258, -258,
+     -258, -258, -258, -258
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  269,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  270,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  261,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  271,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -263, -263, -263, -263, -263, -263, -263, -263, -263,
+     -263, -263, -263, -263, -263, -263, -263, -263, -263, -263,
+     -263, -263, -263,  272, -263, -263, -263, -263, -263, -263,
+     -263, -263, -263, -263, -263, -263, -263, -263, -263, -263,
+     -263, -263, -263, -263
+
+    },
+
+    {
+       37,  238,  239,  240,  240,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  264,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
+      238,  238,  238,  238
+    },
+
+    {
+       37,  243,  244,  245,  245,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  265,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243,  243,  243,  243,  243,  243,  243,
+      243,  243,  243,  243
+
+    },
+
+    {
+       37,  248,  249,  250,  250,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  266,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
+      248,  248,  248,  248
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  273,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37, -268, -268, -268, -268, -268, -268, -268, -268, -268,
+     -268, -268, -268, -268, -268, -268, -268, -268, -268, -268,
+     -268, -268, -268, -268, -268, -268, -268, -268, -268, -268,
+      274, -268, -268, -268, -268, -268, -268, -268, -268, -268,
+     -268, -268, -268, -268
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  269,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  275,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  276,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37, -272, -272, -272, -272, -272, -272, -272, -272, -272,
+     -272, -272, -272, -272, -272, -272, -272, -272, -272, -272,
+     -272, -272, -272, -272, -272, -272, -272, -272, -272, -272,
+      277, -272, -272, -272, -272, -272, -272, -272, -272, -272,
+     -272, -272, -272, -272
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  278,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37, -274, -274, -274, -274, -274, -274, -274, -274, -274,
+     -274, -274, -274, -274, -274, -274, -274, -274, -274, -274,
+     -274, -274, -274, -274, -274, -274, -274,  279, -274, -274,
+     -274, -274, -274, -274, -274, -274, -274, -274, -274, -274,
+     -274, -274, -274, -274
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  280,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  281,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -277, -277, -277, -277, -277, -277, -277, -277, -277,
+     -277, -277, -277, -277, -277, -277, -277, -277, -277, -277,
+     -277, -277, -277, -277, -277, -277, -277,  282, -277, -277,
+     -277, -277, -277, -277, -277, -277, -277, -277, -277, -277,
+     -277, -277, -277, -277
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      283,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -279,  284,  284,  284, -279, -279, -279, -279, -279,
+      285, -279, -279, -279, -279, -279,  286, -279, -279, -279,
+     -279, -279, -279, -279, -279, -279, -279, -279, -279, -279,
+     -279, -279, -279, -279, -279, -279, -279, -279, -279, -279,
+     -279, -279, -279, -279
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  287,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      288,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37, -282,  289,  289,  289, -282, -282, -282, -282, -282,
+      290, -282, -282, -282, -282, -282,  291, -282, -282, -282,
+     -282, -282, -282, -282, -282, -282, -282, -282, -282, -282,
+     -282, -282, -282, -282, -282, -282, -282, -282, -282, -282,
+     -282, -282, -282, -282
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  292,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37, -284,  284,  284,  284, -284, -284, -284, -284, -284,
+      285, -284, -284, -284, -284, -284,  286, -284, -284, -284,
+     -284, -284, -284, -284, -284, -284, -284, -284, -284, -284,
+     -284, -284, -284, -284, -284, -284, -284, -284, -284, -284,
+     -284, -284, -284, -284
+    },
+
+    {
+       37,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+     -285,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293
+
+    },
+
+    {
+       37, -286, -286, -286, -286, -286, -286, -286, -286, -286,
+     -286, -286, -286, -286, -286, -286,  294, -286, -286, -286,
+     -286, -286, -286, -286, -286, -286, -286, -286, -286, -286,
+     -286, -286, -286, -286, -286, -286, -286, -286, -286, -286,
+     -286, -286, -286, -286
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      295,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  296,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -289,  289,  289,  289, -289, -289, -289, -289, -289,
+      290, -289, -289, -289, -289, -289,  291, -289, -289, -289,
+     -289, -289, -289, -289, -289, -289, -289, -289, -289, -289,
+     -289, -289, -289, -289, -289, -289, -289, -289, -289, -289,
+     -289, -289, -289, -289
+
+    },
+
+    {
+       37,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+     -290,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297
+    },
+
+    {
+       37, -291, -291, -291, -291, -291, -291, -291, -291, -291,
+     -291, -291, -291, -291, -291, -291,  298, -291, -291, -291,
+     -291, -291, -291, -291, -291, -291, -291, -291, -291, -291,
+     -291, -291, -291, -291, -291, -291, -291, -291, -291, -291,
+     -291, -291, -291, -291
+
+    },
+
+    {
+       37,  225,  299,  300,  300,  225,  225,  225,  225,  225,
+      301,  225,  225,  225,  225,  225,  302,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -293, -293, -293, -293, -293, -293, -293, -293, -293,
+      303, -293, -293, -293, -293, -293, -293, -293, -293, -293,
+     -293, -293, -293, -293, -293, -293, -293, -293, -293, -293,
+     -293, -293, -293, -293, -293, -293, -293, -293, -293, -293,
+     -293, -293, -293, -293
+
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      306,  304,  304,  304,  304,  304,  307,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  308,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  231,  309,  310,  310,  231,  231,  231,  231,  231,
+      311,  231,  231,  231,  231,  231,  312,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -297, -297, -297, -297, -297, -297, -297, -297, -297,
+      313, -297, -297, -297, -297, -297, -297, -297, -297, -297,
+     -297, -297, -297, -297, -297, -297, -297, -297, -297, -297,
+     -297, -297, -297, -297, -297, -297, -297, -297, -297, -297,
+     -297, -297, -297, -297
+
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      316,  314,  314,  314,  314,  314,  317,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+    },
+
+    {
+       37,  225,  299,  300,  300,  225,  225,  225,  225,  225,
+      301,  225,  225,  225,  225,  225,  302,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37, -300,  300,  300,  300, -300, -300, -300, -300, -300,
+      285, -300, -300, -300, -300, -300,  318, -300, -300, -300,
+     -300, -300, -300, -300, -300, -300, -300, -300, -300, -300,
+     -300, -300,  160, -300, -300, -300, -300, -300, -300, -300,
+     -300, -300, -300, -300
+    },
+
+    {
+       37,  319,  320,  321,  321,  319,  319,  319,  319,  319,
+      225,  319,  319,  319,  319,  319,  322,  319,  319,  319,
+      319,  319,  319,  319,  319,  319,  319,  319,  319,  319,
+      319,  319,  323,  319,  319,  319,  319,  319,  319,  319,
+      319,  319,  319,  319
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  324,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -303, -303, -303, -303, -303, -303, -303, -303, -303,
+     -303, -303, -303, -303, -303, -303, -303, -303, -303, -303,
+     -303, -303, -303, -303, -303, -303, -303, -303, -303, -303,
+     -303, -303, -303, -303, -303, -303, -303, -303, -303, -303,
+     -303, -303, -303, -303
+
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      306,  304,  304,  304,  304,  304,  307,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      306,  304,  304,  304,  304,  304,  307,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+
+    },
+
+    {
+       37,  325,  326,  327,  327,  325,  325,  325,  325,  325,
+      306,  325,  325,  325,  325,  325,  328,  325,  325,  325,
+      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
+      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
+      325,  325,  325,  325
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      306,  304,  304,  304,  304,  304,  329,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+
+    },
+
+    {
+       37,  256,  330,  331,  331,  256,  256,  256,  256,  256,
+      332,  256,  256,  256,  256,  256,  333,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  231,  309,  310,  310,  231,  231,  231,  231,  231,
+      311,  231,  231,  231,  231,  231,  312,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37, -310,  334,  334,  334, -310, -310, -310, -310, -310,
+      335, -310, -310, -310, -310, -310,  336, -310, -310, -310,
+     -310, -310, -310, -310, -310, -310, -310, -310, -310, -310,
+     -310, -310,  164, -310, -310, -310, -310, -310, -310, -310,
+     -310, -310, -310, -310
+    },
+
+    {
+       37,  337,  338,  339,  339,  337,  337,  337,  337,  337,
+      231,  337,  337,  337,  337,  337,  340,  337,  337,  337,
+      337,  337,  337,  337,  337,  337,  337,  337,  337,  337,
+      337,  337,  341,  337,  337,  337,  337,  337,  337,  337,
+      337,  337,  337,  337
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  342,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -313, -313, -313, -313, -313, -313, -313, -313, -313,
+     -313, -313, -313, -313, -313, -313, -313, -313, -313, -313,
+     -313, -313, -313, -313, -313, -313, -313, -313, -313, -313,
+     -313, -313, -313, -313, -313, -313, -313, -313, -313, -313,
+     -313, -313, -313, -313
+
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      316,  314,  314,  314,  314,  314,  317,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      316,  314,  314,  314,  314,  314,  317,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+
+    },
+
+    {
+       37,  343,  344,  345,  345,  343,  343,  343,  343,  343,
+      316,  343,  343,  343,  343,  343,  346,  343,  343,  343,
+      343,  343,  343,  343,  343,  343,  343,  343,  343,  343,
+      343,  343,  343,  343,  343,  343,  343,  343,  343,  343,
+      343,  343,  343,  343
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      316,  314,  314,  314,  314,  314,  347,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+
+    },
+
+    {
+       37, -318, -318, -318, -318, -318, -318, -318, -318, -318,
+     -318, -318, -318, -318, -318, -318,  348, -318, -318, -318,
+     -318, -318, -318, -318, -318, -318, -318, -318, -318, -318,
+     -318, -318, -318, -318, -318, -318, -318, -318, -318, -318,
+     -318, -318, -318, -318
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      349,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      349,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37, -321,  158,  158,  158, -321, -321, -321, -321, -321,
+      303, -321, -321, -321, -321, -321,  159, -321, -321, -321,
+     -321, -321, -321, -321, -321, -321, -321, -321, -321, -321,
+     -321, -321,  160, -321, -321, -321, -321, -321, -321, -321,
+     -321, -321, -321, -321
+
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      349,  225,  225,  225,  225,  225,  253,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      349,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  254,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  353,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      355,  304,  304,  304,  304,  304,  307,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      355,  304,  304,  304,  304,  304,  307,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+    },
+
+    {
+       37, -327,  284,  284,  284, -327, -327, -327, -327, -327,
+      356, -327, -327, -327, -327, -327,  286, -327, -327, -327,
+     -327, -327, -327, -327, -327, -327, -327, -327, -327, -327,
+     -327, -327, -327, -327, -327, -327, -327, -327, -327, -327,
+     -327, -327, -327, -327
+
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      355,  304,  304,  304,  304,  304,  329,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+    },
+
+    {
+       37,  304,  305,  284,  284,  304,  304,  304,  304,  304,
+      306,  304,  304,  304,  304,  304,  329,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304,  304,  304,  304,  304,  304,  304,
+      304,  304,  304,  304
+
+    },
+
+    {
+       37,  256,  330,  331,  331,  256,  256,  256,  256,  256,
+      332,  256,  256,  256,  256,  256,  333,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37, -331,  334,  334,  334, -331, -331, -331, -331, -331,
+      335, -331, -331, -331, -331, -331,  336, -331, -331, -331,
+     -331, -331, -331, -331, -331, -331, -331, -331, -331, -331,
+     -331, -331,  164, -331, -331, -331, -331, -331, -331, -331,
+     -331, -331, -331, -331
+
+    },
+
+    {
+       37,  357,  358,  359,  359,  357,  357,  357,  357,  357,
+      256,  357,  357,  357,  357,  357,  360,  357,  357,  357,
+      357,  357,  357,  357,  357,  357,  357,  357,  357,  357,
+      357,  357,  361,  357,  357,  357,  357,  357,  357,  357,
+      357,  357,  357,  357
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  362,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37, -334,  334,  334,  334, -334, -334, -334, -334, -334,
+      335, -334, -334, -334, -334, -334,  336, -334, -334, -334,
+     -334, -334, -334, -334, -334, -334, -334, -334, -334, -334,
+     -334, -334,  164, -334, -334, -334, -334, -334, -334, -334,
+     -334, -334, -334, -334
+    },
+
+    {
+       37,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+     -335,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297
+
+    },
+
+    {
+       37, -336, -336, -336, -336, -336, -336, -336, -336, -336,
+     -336, -336, -336, -336, -336, -336,  363, -336, -336, -336,
+     -336, -336, -336, -336, -336, -336, -336, -336, -336, -336,
+     -336, -336, -336, -336, -336, -336, -336, -336, -336, -336,
+     -336, -336, -336, -336
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      364,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      364,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -339,  205,  205,  205, -339, -339, -339, -339, -339,
+      365, -339, -339, -339, -339, -339,  206, -339, -339, -339,
+     -339, -339, -339, -339, -339, -339, -339, -339, -339, -339,
+     -339, -339,  164, -339, -339, -339, -339, -339, -339, -339,
+     -339, -339, -339, -339
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      364,  231,  231,  231,  231,  231,  261,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      364,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  262,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  369,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      371,  314,  314,  314,  314,  314,  317,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      371,  314,  314,  314,  314,  314,  317,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+    },
+
+    {
+       37, -345,  289,  289,  289, -345, -345, -345, -345, -345,
+      372, -345, -345, -345, -345, -345,  291, -345, -345, -345,
+     -345, -345, -345, -345, -345, -345, -345, -345, -345, -345,
+     -345, -345, -345, -345, -345, -345, -345, -345, -345, -345,
+     -345, -345, -345, -345
+
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      371,  314,  314,  314,  314,  314,  347,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+    },
+
+    {
+       37,  314,  315,  289,  289,  314,  314,  314,  314,  314,
+      316,  314,  314,  314,  314,  314,  347,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+      314,  314,  314,  314
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  225,  226,  158,  158,  225,  225,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  227,  225,  225,  225,
+      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  228,  225,  225,  225,  225,  225,  225,  225,
+      225,  225,  225,  225
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  374,  375,  376,  376,  374,  374,  374,  374,  374,
+      352,  374,  374,  374,  374,  374,  377,  374,  374,  374,
+      374,  374,  374,  374,  374,  374,  374,  374,  374,  374,
+      374,  374,  378,  374,  374,  374,  374,  374,  374,  374,
+      374,  374,  374,  374
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  379,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  380,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  325,  326,  327,  327,  325,  325,  325,  325,  325,
+      306,  325,  325,  325,  325,  325,  328,  325,  325,  325,
+      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
+      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
+      325,  325,  325,  325
+
+    },
+
+    {
+       37,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+     -356,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
+      293,  293,  293,  293
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      381,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      381,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37, -359,  205,  205,  205, -359, -359, -359, -359, -359,
+      365, -359, -359, -359, -359, -359,  206, -359, -359, -359,
+     -359, -359, -359, -359, -359, -359, -359, -359, -359, -359,
+     -359, -359,  164, -359, -359, -359, -359, -359, -359, -359,
+     -359, -359, -359, -359
+
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      381,  256,  256,  256,  256,  256,  269,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      381,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  270,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  385,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  231,  232,  162,  162,  231,  231,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  233,  231,  231,  231,
+      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  234,  231,  231,  231,  231,  231,  231,  231,
+      231,  231,  231,  231
+    },
+
+    {
+       37, -365, -365, -365, -365, -365, -365, -365, -365, -365,
+     -365, -365, -365, -365, -365, -365, -365, -365, -365, -365,
+     -365, -365, -365, -365, -365, -365, -365, -365, -365, -365,
+     -365, -365, -365, -365, -365, -365, -365, -365, -365, -365,
+     -365, -365, -365, -365
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  389,  390,  391,  391,  389,  389,  389,  389,  389,
+      368,  389,  389,  389,  389,  389,  392,  389,  389,  389,
+      389,  389,  389,  389,  389,  389,  389,  389,  389,  389,
+      389,  389,  393,  389,  389,  389,  389,  389,  389,  389,
+      389,  389,  389,  389
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  394,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  395,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  343,  344,  345,  345,  343,  343,  343,  343,  343,
+      316,  343,  343,  343,  343,  343,  346,  343,  343,  343,
+      343,  343,  343,  343,  343,  343,  343,  343,  343,  343,
+      343,  343,  343,  343,  343,  343,  343,  343,  343,  343,
+      343,  343,  343,  343
+
+    },
+
+    {
+       37,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+     -372,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  379,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      396,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      396,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37, -376,  300,  300,  300, -376, -376, -376, -376, -376,
+      356, -376, -376, -376, -376, -376,  318, -376, -376, -376,
+     -376, -376, -376, -376, -376, -376, -376, -376, -376, -376,
+     -376, -376,  160, -376, -376, -376, -376, -376, -376, -376,
+     -376, -376, -376, -376
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      396,  350,  350,  350,  350,  350,  379,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      396,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  380,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  379,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  397,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  256,  257,  258,  258,  256,  256,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  259,  256,  256,  256,
+      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  260,  256,  256,  256,  256,  256,  256,  256,
+      256,  256,  256,  256
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  398,  399,  400,  400,  398,  398,  398,  398,  398,
+      384,  398,  398,  398,  398,  398,  401,  398,  398,  398,
+      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
+      398,  398,  402,  398,  398,  398,  398,  398,  398,  398,
+      398,  398,  398,  398
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  403,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  404,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  403,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  394,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      405,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      405,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37, -391,  334,  334,  334, -391, -391, -391, -391, -391,
+      406, -391, -391, -391, -391, -391,  336, -391, -391, -391,
+     -391, -391, -391, -391, -391, -391, -391, -391, -391, -391,
+     -391, -391,  164, -391, -391, -391, -391, -391, -391, -391,
+     -391, -391, -391, -391
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      405,  366,  366,  366,  366,  366,  394,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      405,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  395,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  394,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  407,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  374,  375,  376,  376,  374,  374,  374,  374,  374,
+      352,  374,  374,  374,  374,  374,  377,  374,  374,  374,
+      374,  374,  374,  374,  374,  374,  374,  374,  374,  374,
+      374,  374,  378,  374,  374,  374,  374,  374,  374,  374,
+      374,  374,  374,  374
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  408,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      409,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      409,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37, -400,  334,  334,  334, -400, -400, -400, -400, -400,
+      406, -400, -400, -400, -400, -400,  336, -400, -400, -400,
+     -400, -400, -400, -400, -400, -400, -400, -400, -400, -400,
+     -400, -400,  164, -400, -400, -400, -400, -400, -400, -400,
+     -400, -400, -400, -400
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      409,  382,  382,  382,  382,  382,  403,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      409,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  404,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  403,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  410,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  389,  390,  391,  391,  389,  389,  389,  389,  389,
+      368,  389,  389,  389,  389,  389,  392,  389,  389,  389,
+      389,  389,  389,  389,  389,  389,  389,  389,  389,  389,
+      389,  389,  393,  389,  389,  389,  389,  389,  389,  389,
+      389,  389,  389,  389
+
+    },
+
+    {
+       37,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+     -406,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+      297,  297,  297,  297
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  411,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  412,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  398,  399,  400,  400,  398,  398,  398,  398,  398,
+      384,  398,  398,  398,  398,  398,  401,  398,  398,  398,
+      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
+      398,  398,  402,  398,  398,  398,  398,  398,  398,  398,
+      398,  398,  398,  398
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  413,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  414,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      415,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  416,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      417,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  418,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      419,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  420,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+
+    },
+
+    {
+       37,  350,  351,  300,  300,  350,  350,  350,  350,  350,
+      352,  350,  350,  350,  350,  350,  373,  350,  350,  350,
+      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  354,  350,  350,  350,  350,  350,  350,  350,
+      350,  350,  350,  350
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  421,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    {
+       37,  366,  367,  310,  310,  366,  366,  366,  366,  366,
+      368,  366,  366,  366,  366,  366,  388,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  370,  366,  366,  366,  366,  366,  366,  366,
+      366,  366,  366,  366
+    },
+
+    {
+       37,  382,  383,  331,  331,  382,  382,  382,  382,  382,
+      384,  382,  382,  382,  382,  382,  387,  382,  382,  382,
+      382,  382,  382,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  386,  382,  382,  382,  382,  382,  382,  382,
+      382,  382,  382,  382
+
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 98
+#define YY_END_OF_BUFFER 99
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[422] =
+    {   0,
+        0,    0,   12,   12,    0,    0,    0,    0,   11,   11,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   99,   64,    1,    1,
+       56,   40,   64,   55,   19,   49,   50,   55,   55,   55,
+       55,   58,   55,   51,   63,   63,   63,   63,   63,   63,
+       53,   12,    9,    5,    5,    6,    6,   46,   42,   11,
+       16,   28,   28,   22,   33,   27,   22,   37,   37,   39,
+       43,   24,   66,   65,   65,   74,   67,   67,   73,   69,
+       71,   68,   70,   72,   85,   75,   85,   87,   86,   91,
+
+       88,   88,   90,   89,   93,   92,   95,   94,   94,   97,
+       97,    1,   56,   34,   57,   35,    1,   59,    2,   59,
+       58,   61,   54,   48,   63,    8,   20,   18,   47,   15,
+       52,   12,    9,    9,   10,    5,    7,    4,    3,   46,
+       45,   11,   16,   16,   17,   28,   22,   22,   26,   23,
+       29,   30,   29,   27,   37,   36,   38,   43,   43,   43,
+       24,   24,   24,   24,   67,   71,   76,   84,   82,   79,
+       81,   77,   80,   78,   84,   94,   96,   35,    1,    1,
+        2,   59,   62,   60,   41,   21,    9,   14,   10,    9,
+        3,   16,   13,   17,   16,   22,   32,   23,   22,   30,
+
+       31,   38,   43,   43,   24,   24,   24,   24,   82,   83,
+        9,    9,    9,    9,   16,   16,   16,   16,   22,   22,
+       22,   22,   30,   31,   43,   43,   43,   43,   43,   24,
+       24,   24,   24,   24,   24,   82,   83,    9,    9,    9,
+        9,    9,   16,   16,   16,   16,   16,   22,   22,   22,
+       22,   22,   43,   43,   43,   24,   24,   24,   24,   24,
+       24,   24,   24,    9,   16,   22,   43,   43,   24,   24,
+       24,   24,   43,   43,   24,   24,   24,   43,   43,   24,
+       24,   24,   43,   43,   43,   43,   24,   24,   24,   24,
+       24,   43,   43,   43,   24,   24,   24,   24,   43,   43,
+
+       43,   43,   44,   43,   43,   43,   43,   24,   24,   24,
+       24,   24,   25,   24,   24,   24,   24,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   24,
+       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
+       24,   24,   24,   24,   24,   24,   24,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   24,   24,   24,   24,
+       24,   24,   24,   24,   25,   24,   24,   24,   24,   24,
+       24,   24,   43,   43,   43,   43,   43,   43,   43,   43,
+       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
+       24,   24,   24,   24,   24,   43,   43,   24,   24,   24,
+
+       24,   24,   24,   24,   24,   24,   24,   43,   24,   24,
+       24,   43,   24,   24,   43,   24,   24,   43,   24,   24,
+       24
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    2,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    5,    6,    5,    7,    8,    9,   10,   11,
+       12,   13,   14,   15,   16,   17,   18,   19,   19,   19,
+       19,   19,   19,   19,   19,   20,   20,   21,   22,    8,
+        8,    8,    5,    5,   23,   24,   25,   26,   27,   26,
+       28,   28,   28,   28,   28,   28,   28,   29,   28,   30,
+       28,   28,   31,   28,   32,   28,   28,   33,   28,   28,
+       15,   34,   15,    8,   28,   35,   23,   36,   25,   26,
+
+       27,   37,   28,   28,   28,   28,   28,   28,   28,   38,
+       28,   30,   28,   39,   31,   40,   32,   28,   28,   41,
+       28,   28,    1,   42,    1,    5,    1,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43
+    } ;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "psqlscan.l"
+#line 2 "psqlscan.l"
+/*-------------------------------------------------------------------------
+ *
+ * psqlscan.l
+ *	  lexical scanner for psql
+ *
+ * This code is mainly needed to determine where the end of a SQL statement
+ * is: we are looking for semicolons that are not within quotes, comments,
+ * or parentheses.  The most reliable way to handle this is to borrow the
+ * backend's flex lexer rules, lock, stock, and barrel.  The rules below
+ * are (except for a few) the same as the backend's, but their actions are
+ * just ECHO whereas the backend's actions generally do other things.
+ *
+ * XXX The rules in this file must be kept in sync with the backend lexer!!!
+ *
+ * XXX Avoid creating backtracking cases --- see the backend lexer for info.
+ *
+ * The most difficult aspect of this code is that we need to work in multibyte
+ * encodings that are not ASCII-safe.  A "safe" encoding is one in which each
+ * byte of a multibyte character has the high bit set (it's >= 0x80).  Since
+ * all our lexing rules treat all high-bit-set characters alike, we don't
+ * really need to care whether such a byte is part of a sequence or not.
+ * In an "unsafe" encoding, we still expect the first byte of a multibyte
+ * sequence to be >= 0x80, but later bytes might not be.  If we scan such
+ * a sequence as-is, the lexing rules could easily be fooled into matching
+ * such bytes to ordinary ASCII characters.  Our solution for this is to
+ * substitute 0xFF for each non-first byte within the data presented to flex.
+ * The flex rules will then pass the FF's through unmolested.  The emit()
+ * subroutine is responsible for looking back to the original string and
+ * replacing FF's with the corresponding original bytes.
+ *
+ * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * IDENTIFICATION
+ *	  $PostgreSQL: pgsql/src/bin/psql/psqlscan.l,v 1.28.2.1 2010/05/05 22:19:05 tgl Exp $
+ *
+ *-------------------------------------------------------------------------
+ */
+#include "postgres_fe.h"
+
+#include "psqlscan.h"
+
+#include <ctype.h>
+
+#include "common.h"
+#include "settings.h"
+#include "variables.h"
+
+
+/*
+ * We use a stack of flex buffers to handle substitution of psql variables.
+ * Each stacked buffer contains the as-yet-unread text from one psql variable.
+ * When we pop the stack all the way, we resume reading from the outer buffer
+ * identified by scanbufhandle.
+ */
+typedef struct StackElem
+{
+	YY_BUFFER_STATE buf;		/* flex input control structure */
+	char	   *bufstring;		/* data actually being scanned by flex */
+	char	   *origstring;		/* copy of original data, if needed */
+	char	   *varname;		/* name of variable providing data, or NULL */
+	struct StackElem *next;
+} StackElem;
+
+/*
+ * All working state of the lexer must be stored in PsqlScanStateData
+ * between calls.  This allows us to have multiple open lexer operations,
+ * which is needed for nested include files.  The lexer itself is not
+ * recursive, but it must be re-entrant.
+ */
+typedef struct PsqlScanStateData
+{
+	StackElem  *buffer_stack;	/* stack of variable expansion buffers */
+	/*
+	 * These variables always refer to the outer buffer, never to any
+	 * stacked variable-expansion buffer.
+	 */
+	YY_BUFFER_STATE scanbufhandle;
+	char	   *scanbuf;		/* start of outer-level input buffer */
+	const char *scanline;		/* current input line at outer level */
+
+	/* safe_encoding, curline, refline are used by emit() to replace FFs */
+	int			encoding;		/* encoding being used now */
+	bool		safe_encoding;	/* is current encoding "safe"? */
+	const char *curline;		/* actual flex input string for cur buf */
+	const char *refline;		/* original data for cur buffer */
+
+	/*
+	 * All this state lives across successive input lines, until explicitly
+	 * reset by psql_scan_reset.
+	 */
+	int			start_state;	/* saved YY_START */
+	int			paren_depth;	/* depth of nesting in parentheses */
+	int			xcdepth;		/* depth of nesting in slash-star comments */
+	char	   *dolqstart;		/* current $foo$ quote start string */
+} PsqlScanStateData;
+
+static PsqlScanState cur_state;	/* current state while active */
+
+static PQExpBuffer output_buf;	/* current output buffer */
+
+/* these variables do not need to be saved across calls */
+static enum slash_option_type option_type;
+static char *option_quote;
+
+
+/* Return values from yylex() */
+#define LEXRES_EOL			0	/* end of input */
+#define LEXRES_SEMI			1	/* command-terminating semicolon found */
+#define LEXRES_BACKSLASH	2	/* backslash command start */
+#define LEXRES_OK			3	/* OK completion of backslash argument */
+
+
+int	yylex(void);
+
+static void push_new_buffer(const char *newstr, const char *varname);
+static void pop_buffer_stack(PsqlScanState state);
+static bool var_is_current_source(PsqlScanState state, const char *varname);
+static YY_BUFFER_STATE prepare_buffer(const char *txt, int len,
+									  char **txtcopy);
+static void emit(const char *txt, int len);
+
+#define ECHO emit(yytext, yyleng)
+
+#define YY_NO_INPUT 1
+/*
+ * All of the following definitions and rules should exactly match
+ * src/backend/parser/scan.l so far as the flex patterns are concerned.
+ * The rule bodies are just ECHO as opposed to what the backend does,
+ * however.  (But be sure to duplicate code that affects the lexing process,
+ * such as BEGIN().)  Also, psqlscan uses a single <<EOF>> rule whereas
+ * scan.l has a separate one for each exclusive state.
+ */
+/*
+ * OK, here is a short description of lex/flex rules behavior.
+ * The longest pattern which matches an input string is always chosen.
+ * For equal-length patterns, the first occurring in the rules list is chosen.
+ * INITIAL is the starting state, to which all non-conditional rules apply.
+ * Exclusive states change parsing rules while the state is active.  When in
+ * an exclusive state, only those rules defined for that state apply.
+ *
+ * We use exclusive states for quoted strings, extended comments,
+ * and to eliminate parsing troubles for numeric strings.
+ * Exclusive states:
+ *  <xb> bit string literal
+ *  <xc> extended C-style comments
+ *  <xd> delimited identifiers (double-quoted identifiers)
+ *  <xh> hexadecimal numeric string
+ *  <xq> standard quoted strings
+ *  <xe> extended quoted strings (support backslash escape sequences)
+ *  <xdolq> $foo$ quoted strings
+ *  <xui> quoted identifier with Unicode escapes
+ *  <xus> quoted string with Unicode escapes
+ */
+
+
+
+
+
+
+
+
+
+/* Additional exclusive states for psql only: lex backslash commands */
+
+
+
+
+
+
+
+
+/*
+ * In order to make the world safe for Windows and Mac clients as well as
+ * Unix ones, we accept either \n or \r as a newline.  A DOS-style \r\n
+ * sequence will be seen as two successive newlines, but that doesn't cause
+ * any problems.  Comments that start with -- and extend to the next
+ * newline are treated as equivalent to a single whitespace character.
+ *
+ * NOTE a fine point: if there is no newline following --, we will absorb
+ * everything to the end of the input as a comment.  This is correct.  Older
+ * versions of Postgres failed to recognize -- as a comment if the input
+ * did not end with a newline.
+ *
+ * XXX perhaps \f (formfeed) should be treated as a newline as well?
+ */
+/*
+ * SQL requires at least one newline in the whitespace separating
+ * string literals that are to be concatenated.  Silly, but who are we
+ * to argue?  Note that {whitespace_with_newline} should not have * after
+ * it, whereas {whitespace} should generally have a * after it...
+ */
+/*
+ * To ensure that {quotecontinue} can be scanned without having to back up
+ * if the full pattern isn't matched, we include trailing whitespace in
+ * {quotestop}.  This matches all cases where {quotecontinue} fails to match,
+ * except for {quote} followed by whitespace and just one "-" (not two,
+ * which would start a {comment}).  To cover that we have {quotefail}.
+ * The actions for {quotestop} and {quotefail} must throw back characters
+ * beyond the quote proper.
+ */
+/* Bit string
+ * It is tempting to scan the string for only those characters
+ * which are allowed. However, this leads to silently swallowed
+ * characters if illegal characters are included in the string.
+ * For example, if xbinside is [01] then B'ABCD' is interpreted
+ * as a zero-length string, and the ABCD' is lost!
+ * Better to pass the string forward and let the input routines
+ * validate the contents.
+ */
+/* Hexadecimal number */
+/* National character */
+/* Quoted string that allows backslash escapes */
+/* Extended quote
+ * xqdouble implements embedded quote, ''''
+ */
+/* $foo$ style quotes ("dollar quoting")
+ * The quoted string starts with $foo$ where "foo" is an optional string
+ * in the form of an identifier, except that it may not contain "$", 
+ * and extends to the first occurrence of an identical string.  
+ * There is *no* processing of the quoted text.
+ *
+ * {dolqfailed} is an error rule to avoid scanner backup when {dolqdelim}
+ * fails to match its trailing "$".
+ */
+/* Double quote
+ * Allows embedded spaces and other special characters into identifiers.
+ */
+/* Unicode escapes */
+/* error rule to avoid backup */
+/* Quoted identifier with Unicode escapes */
+/* Quoted string with Unicode escapes */
+/* error rule to avoid backup */
+/* C-style comments
+ *
+ * The "extended comment" syntax closely resembles allowable operator syntax.
+ * The tricky part here is to get lex to recognize a string starting with
+ * slash-star as a comment, when interpreting it as an operator would produce
+ * a longer match --- remember lex will prefer a longer match!  Also, if we
+ * have something like plus-slash-star, lex will think this is a 3-character
+ * operator whereas we want to see it as a + operator and a comment start.
+ * The solution is two-fold:
+ * 1. append {op_chars}* to xcstart so that it matches as much text as
+ *    {operator} would. Then the tie-breaker (first matching rule of same
+ *    length) ensures xcstart wins.  We put back the extra stuff with yyless()
+ *    in case it contains a star-slash that should terminate the comment.
+ * 2. In the operator rule, check for slash-star within the operator, and
+ *    if found throw it back with yyless().  This handles the plus-slash-star
+ *    problem.
+ * Dash-dash comments have similar interactions with the operator rule.
+ */
+/*
+ * "self" is the set of chars that should be returned as single-character
+ * tokens.  "op_chars" is the set of chars that can make up "Op" tokens,
+ * which can be one or more characters long (but if a single-char token
+ * appears in the "self" set, it is not to be returned as an Op).  Note
+ * that the sets overlap, but each has some chars that are not in the other.
+ *
+ * If you change either set, adjust the character lists appearing in the
+ * rule for "operator"!
+ */
+/* we no longer allow unary minus in numbers. 
+ * instead we pass it separately to parser. there it gets
+ * coerced via doNegate() -- Leon aug 20 1999
+ *
+ * {realfail1} and {realfail2} are added to prevent the need for scanner
+ * backup when the {real} rule fails to match completely.
+ */
+/*
+ * Dollar quoted strings are totally opaque, and no escaping is done on them.
+ * Other quoted strings must allow some special characters such as single-quote
+ *  and newline.
+ * Embedded single-quotes are implemented both in the SQL standard
+ *  style of two adjacent single quotes "''" and in the Postgres/Java style
+ *  of escaped-quote "\'".
+ * Other embedded escaped characters are matched explicitly and the leading
+ *  backslash is dropped from the string.
+ * Note that xcstart must appear before operator, as explained above!
+ *  Also whitespace (comment) must appear before operator.
+ */
+#line 4351 "psqlscan.c"
+
+#define INITIAL 0
+#define xb 1
+#define xc 2
+#define xd 3
+#define xh 4
+#define xe 5
+#define xq 6
+#define xdolq 7
+#define xui 8
+#define xus 9
+#define xslashcmd 10
+#define xslasharg 11
+#define xslashquote 12
+#define xslashbackquote 13
+#define xslashdefaultarg 14
+#define xslashquotedarg 15
+#define xslashwholeline 16
+#define xslashend 17
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 385 "psqlscan.l"
+
+
+#line 4556 "psqlscan.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 387 "psqlscan.l"
+{
+					/*
+					 * Note that the whitespace rule includes both true
+					 * whitespace and single-line ("--" style) comments.
+					 * We suppress whitespace at the start of the query
+					 * buffer.  We also suppress all single-line comments,
+					 * which is pretty dubious but is the historical
+					 * behavior.
+					 */
+					if (!(output_buf->len == 0 || yytext[0] == '-'))
+						ECHO;
+				}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 400 "psqlscan.l"
+{
+					cur_state->xcdepth = 0;
+					BEGIN(xc);
+					/* Put back any characters past slash-star; see above */
+					yyless(2);
+					ECHO;
+				}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 408 "psqlscan.l"
+{
+					cur_state->xcdepth++;
+					/* Put back any characters past slash-star; see above */
+					yyless(2);
+					ECHO;
+				}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 415 "psqlscan.l"
+{
+					if (cur_state->xcdepth <= 0)
+					{
+						BEGIN(INITIAL);
+					}
+					else
+						cur_state->xcdepth--;
+					ECHO;
+				}
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 425 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 429 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 433 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 437 "psqlscan.l"
+{
+					BEGIN(xb);
+					ECHO;
+				}
+	YY_BREAK
+case 9:
+/* rule 9 can match eol */
+#line 442 "psqlscan.l"
+case 10:
+/* rule 10 can match eol */
+YY_RULE_SETUP
+#line 442 "psqlscan.l"
+{
+					yyless(1);
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 11:
+/* rule 11 can match eol */
+#line 448 "psqlscan.l"
+case 12:
+/* rule 12 can match eol */
+YY_RULE_SETUP
+#line 448 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 13:
+/* rule 13 can match eol */
+#line 452 "psqlscan.l"
+case 14:
+/* rule 14 can match eol */
+YY_RULE_SETUP
+#line 452 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 456 "psqlscan.l"
+{
+					/* Hexadecimal bit type.
+					 * At some point we should simply pass the string
+					 * forward to the parser and label it there.
+					 * In the meantime, place a leading "x" on the string
+					 * to mark it for the input routine as a hex string.
+					 */
+					BEGIN(xh);
+					ECHO;
+				}
+	YY_BREAK
+case 16:
+/* rule 16 can match eol */
+#line 467 "psqlscan.l"
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+#line 467 "psqlscan.l"
+{
+					yyless(1);
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 473 "psqlscan.l"
+{
+					yyless(1);				/* eat only 'n' this time */
+					ECHO;
+				}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 478 "psqlscan.l"
+{
+					if (standard_strings())
+						BEGIN(xq);
+					else
+						BEGIN(xe);
+					ECHO;
+				}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 485 "psqlscan.l"
+{
+					BEGIN(xe);
+					ECHO;
+				}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 489 "psqlscan.l"
+{
+					BEGIN(xus);
+					ECHO;
+				}
+	YY_BREAK
+case 22:
+/* rule 22 can match eol */
+#line 494 "psqlscan.l"
+case 23:
+/* rule 23 can match eol */
+YY_RULE_SETUP
+#line 494 "psqlscan.l"
+{
+					yyless(1);
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 24:
+/* rule 24 can match eol */
+YY_RULE_SETUP
+#line 499 "psqlscan.l"
+{
+					yyless(1);
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+YY_RULE_SETUP
+#line 504 "psqlscan.l"
+{
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 508 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 27:
+/* rule 27 can match eol */
+YY_RULE_SETUP
+#line 511 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+#line 514 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 29:
+/* rule 29 can match eol */
+YY_RULE_SETUP
+#line 517 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 520 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 523 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 32:
+/* rule 32 can match eol */
+YY_RULE_SETUP
+#line 526 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 529 "psqlscan.l"
+{
+					/* This is only needed for \ just before EOF */
+					ECHO;
+				}
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 534 "psqlscan.l"
+{
+					cur_state->dolqstart = pg_strdup(yytext);
+					BEGIN(xdolq);
+					ECHO;
+				}
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 539 "psqlscan.l"
+{
+					/* throw back all but the initial "$" */
+					yyless(1);
+					ECHO;
+				}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 544 "psqlscan.l"
+{
+					if (strcmp(yytext, cur_state->dolqstart) == 0)
+					{
+						free(cur_state->dolqstart);
+						cur_state->dolqstart = NULL;
+						BEGIN(INITIAL);
+					}
+					else
+					{
+						/*
+						 * When we fail to match $...$ to dolqstart, transfer
+						 * the $... part to the output, but put back the final
+						 * $ for rescanning.  Consider $delim$...$junk$delim$
+						 */
+						yyless(yyleng-1);
+					}
+					ECHO;
+				}
+	YY_BREAK
+case 37:
+/* rule 37 can match eol */
+YY_RULE_SETUP
+#line 562 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 565 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 568 "psqlscan.l"
+{
+					/* This is only needed for $ inside the quoted text */
+					ECHO;
+				}
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 573 "psqlscan.l"
+{
+					BEGIN(xd);
+					ECHO;
+				}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 577 "psqlscan.l"
+{
+					BEGIN(xui);
+					ECHO;
+				}
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 581 "psqlscan.l"
+{
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 43:
+/* rule 43 can match eol */
+YY_RULE_SETUP
+#line 585 "psqlscan.l"
+{
+					yyless(1);
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 44:
+/* rule 44 can match eol */
+YY_RULE_SETUP
+#line 590 "psqlscan.l"
+{
+					BEGIN(INITIAL);
+					ECHO;
+				}
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 594 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 46:
+/* rule 46 can match eol */
+YY_RULE_SETUP
+#line 597 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 601 "psqlscan.l"
+{
+					/* throw back all but the initial u/U */
+					yyless(1);
+					ECHO;
+				}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 607 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+/*
+	 * These rules are specific to psql --- they implement parenthesis
+	 * counting and detection of command-ending semicolon.  These must
+	 * appear before the {self} rule so that they take precedence over it.
+	 */
+case 49:
+YY_RULE_SETUP
+#line 617 "psqlscan.l"
+{
+					cur_state->paren_depth++;
+					ECHO;
+				}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 622 "psqlscan.l"
+{
+					if (cur_state->paren_depth > 0)
+						cur_state->paren_depth--;
+					ECHO;
+				}
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 628 "psqlscan.l"
+{
+					ECHO;
+					if (cur_state->paren_depth == 0)
+					{
+						/* Terminate lexing temporarily */
+						return LEXRES_SEMI;
+					}
+				}
+	YY_BREAK
+/*
+	 * psql-specific rules to handle backslash commands and variable
+	 * substitution.  We want these before {self}, also.
+	 */
+case 52:
+YY_RULE_SETUP
+#line 642 "psqlscan.l"
+{
+					/* Force a semicolon or colon into the query buffer */
+					emit(yytext + 1, 1);
+				}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 647 "psqlscan.l"
+{
+					/* Terminate lexing temporarily */
+					return LEXRES_BACKSLASH;
+				}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 652 "psqlscan.l"
+{
+					/* Possible psql variable substitution */
+					const char *varname = yytext + 1;
+					const char *value;
+
+					value = GetVariable(pset.vars, varname);
+
+					if (value)
+					{
+						/* It is a variable, check for recursion */
+						if (var_is_current_source(cur_state, varname))
+						{
+							/* Recursive expansion --- don't go there */
+							psql_error("skipping recursive expansion of variable \"%s\"\n",
+									   varname);
+							/* Instead copy the string as is */
+							ECHO;
+						}
+						else
+						{
+							/* OK, perform substitution */
+							push_new_buffer(value, varname);
+							/* yy_scan_string already made buffer active */
+						}
+					}
+					else
+					{
+						/*
+						 * if the variable doesn't exist we'll copy the
+						 * string as is
+						 */
+						ECHO;
+					}
+				}
+	YY_BREAK
+/*
+	 * Back to backend-compatible rules.
+	 */
+case 55:
+YY_RULE_SETUP
+#line 691 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 695 "psqlscan.l"
+{
+					/*
+					 * Check for embedded slash-star or dash-dash; those
+					 * are comment starts, so operator must stop there.
+					 * Note that slash-star or dash-dash at the first
+					 * character will match a prior rule, not this one.
+					 */
+					int		nchars = yyleng;
+					char   *slashstar = strstr(yytext, "/*");
+					char   *dashdash = strstr(yytext, "--");
+
+					if (slashstar && dashdash)
+					{
+						/* if both appear, take the first one */
+						if (slashstar > dashdash)
+							slashstar = dashdash;
+					}
+					else if (!slashstar)
+						slashstar = dashdash;
+					if (slashstar)
+						nchars = slashstar - yytext;
+
+					/*
+					 * For SQL compatibility, '+' and '-' cannot be the
+					 * last char of a multi-char operator unless the operator
+					 * contains chars that are not in SQL operators.
+					 * The idea is to lex '=-' as two operators, but not
+					 * to forbid operator names like '?-' that could not be
+					 * sequences of SQL operators.
+					 */
+					while (nchars > 1 &&
+						   (yytext[nchars-1] == '+' ||
+							yytext[nchars-1] == '-'))
+					{
+						int		ic;
+
+						for (ic = nchars-2; ic >= 0; ic--)
+						{
+							if (strchr("~!@#^&|`?%", yytext[ic]))
+								break;
+						}
+						if (ic >= 0)
+							break; /* found a char that makes it OK */
+						nchars--; /* else remove the +/-, and check again */
+					}
+
+					if (nchars < yyleng)
+					{
+						/* Strip the unwanted chars from the token */
+						yyless(nchars);
+					}
+					ECHO;
+				}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 749 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 753 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 756 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 759 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 762 "psqlscan.l"
+{
+					/*
+					 * throw back the [Ee], and treat as {decimal}.  Note
+					 * that it is possible the input is actually {integer},
+					 * but since this case will almost certainly lead to a
+					 * syntax error anyway, we don't bother to distinguish.
+					 */
+					yyless(yyleng-1);
+					ECHO;
+				}
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 772 "psqlscan.l"
+{
+					/* throw back the [Ee][+-], and proceed as above */
+					yyless(yyleng-2);
+					ECHO;
+				}
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 779 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 783 "psqlscan.l"
+{
+					ECHO;
+				}
+	YY_BREAK
+/*
+	 * Everything from here down is psql-specific.
+	 */
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(xb):
+case YY_STATE_EOF(xc):
+case YY_STATE_EOF(xd):
+case YY_STATE_EOF(xh):
+case YY_STATE_EOF(xe):
+case YY_STATE_EOF(xq):
+case YY_STATE_EOF(xdolq):
+case YY_STATE_EOF(xui):
+case YY_STATE_EOF(xus):
+case YY_STATE_EOF(xslashcmd):
+case YY_STATE_EOF(xslasharg):
+case YY_STATE_EOF(xslashquote):
+case YY_STATE_EOF(xslashbackquote):
+case YY_STATE_EOF(xslashdefaultarg):
+case YY_STATE_EOF(xslashquotedarg):
+case YY_STATE_EOF(xslashwholeline):
+case YY_STATE_EOF(xslashend):
+#line 792 "psqlscan.l"
+{
+					StackElem  *stackelem = cur_state->buffer_stack;
+
+					if (stackelem == NULL)
+						return LEXRES_EOL; /* end of input reached */
+
+					/*
+					 * We were expanding a variable, so pop the inclusion
+					 * stack and keep lexing
+					 */
+					pop_buffer_stack(cur_state);
+
+					stackelem = cur_state->buffer_stack;
+					if (stackelem != NULL)
+					{
+						yy_switch_to_buffer(stackelem->buf);
+						cur_state->curline = stackelem->bufstring;
+						cur_state->refline = stackelem->origstring ? stackelem->origstring : stackelem->bufstring;
+					}
+					else
+					{
+						yy_switch_to_buffer(cur_state->scanbufhandle);
+						cur_state->curline = cur_state->scanbuf;
+						cur_state->refline = cur_state->scanline;
+					}
+				}
+	YY_BREAK
+/*
+	 * Exclusive lexer states to handle backslash command lexing
+	 */
+
+/* command name ends at whitespace or backslash; eat all else */
+case 65:
+/* rule 65 can match eol */
+YY_RULE_SETUP
+#line 826 "psqlscan.l"
+{
+					yyless(0);
+					return LEXRES_OK;
+				}
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 831 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/* eat any whitespace, then decide what to do at first nonblank */
+case 67:
+/* rule 67 can match eol */
+YY_RULE_SETUP
+#line 838 "psqlscan.l"
+{ }
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 840 "psqlscan.l"
+{
+					/*
+					 * backslash is end of command or next command, do not eat
+					 *
+					 * XXX this means we can't conveniently accept options
+					 * that start with a backslash; therefore, option
+					 * processing that encourages use of backslashes is rather
+					 * broken.
+					 */
+					yyless(0);
+					return LEXRES_OK;
+				}
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 853 "psqlscan.l"
+{
+					*option_quote = '\'';
+					BEGIN(xslashquote);
+				}
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 858 "psqlscan.l"
+{
+					if (option_type == OT_VERBATIM)
+					{
+						/* in verbatim mode, backquote is not special */
+						ECHO;
+						BEGIN(xslashdefaultarg);
+					}
+					else
+					{
+						*option_quote = '`';
+						BEGIN(xslashbackquote);
+					}
+				}
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 872 "psqlscan.l"
+{
+					/* Possible psql variable substitution */
+					if (option_type == OT_VERBATIM)
+						ECHO;
+					else
+					{
+						const char *value;
+
+						value = GetVariable(pset.vars, yytext + 1);
+
+						/*
+						 * The variable value is just emitted without any
+						 * further examination.  This is consistent with the
+						 * pre-8.0 code behavior, if not with the way that
+						 * variables are handled outside backslash commands.
+						 * Note that we needn't guard against recursion here.
+						 */
+						if (value)
+							appendPQExpBufferStr(output_buf, value);
+					}
+
+					*option_quote = ':';
+
+					return LEXRES_OK;
+				}
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 898 "psqlscan.l"
+{
+					ECHO;
+					if (option_type == OT_FILEPIPE)
+					{
+						/* treat like whole-string case */
+						BEGIN(xslashwholeline);
+					}
+					else
+					{
+						/* treat like default case */
+						BEGIN(xslashdefaultarg);
+					}
+				}
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 912 "psqlscan.l"
+{
+					*option_quote = '"';
+					ECHO;
+					BEGIN(xslashquotedarg);
+				}
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+#line 918 "psqlscan.l"
+{
+					ECHO;
+					BEGIN(xslashdefaultarg);
+				}
+	YY_BREAK
+
+
+/*
+	 * single-quoted text: copy literally except for '' and backslash
+	 * sequences
+	 */
+case 75:
+YY_RULE_SETUP
+#line 931 "psqlscan.l"
+{ return LEXRES_OK; }
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 933 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\''); }
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 935 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\n'); }
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 936 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\t'); }
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 937 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\b'); }
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 938 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\r'); }
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+#line 939 "psqlscan.l"
+{ appendPQExpBufferChar(output_buf, '\f'); }
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+#line 941 "psqlscan.l"
+{
+					/* octal case */
+					appendPQExpBufferChar(output_buf,
+										  (char) strtol(yytext + 1, NULL, 8));
+				}
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 947 "psqlscan.l"
+{
+					/* hex case */
+					appendPQExpBufferChar(output_buf,
+										  (char) strtol(yytext + 2, NULL, 16));
+				}
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+#line 953 "psqlscan.l"
+{ emit(yytext + 1, 1); }
+	YY_BREAK
+case 85:
+/* rule 85 can match eol */
+YY_RULE_SETUP
+#line 955 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/*
+	 * backticked text: copy everything until next backquote or end of line.
+	 * Invocation of the command will happen in psql_scan_slash_option.
+	 */
+case 86:
+YY_RULE_SETUP
+#line 965 "psqlscan.l"
+{ return LEXRES_OK; }
+	YY_BREAK
+case 87:
+/* rule 87 can match eol */
+YY_RULE_SETUP
+#line 967 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/*
+	 * Copy everything until unquoted whitespace or end of line.  Quotes
+	 * do not get stripped yet.
+	 */
+case 88:
+/* rule 88 can match eol */
+YY_RULE_SETUP
+#line 977 "psqlscan.l"
+{
+					yyless(0);
+					return LEXRES_OK;
+				}
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 982 "psqlscan.l"
+{
+					/*
+					 * unquoted backslash is end of command or next command,
+					 * do not eat
+					 *
+					 * (this was not the behavior pre-8.0, but it seems
+					 * consistent)
+					 */
+					yyless(0);
+					return LEXRES_OK;
+				}
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 994 "psqlscan.l"
+{
+					*option_quote = '"';
+					ECHO;
+					BEGIN(xslashquotedarg);
+				}
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 1000 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/* double-quoted text within a default-type argument: copy */
+case 92:
+YY_RULE_SETUP
+#line 1007 "psqlscan.l"
+{
+					ECHO;
+					BEGIN(xslashdefaultarg);
+				}
+	YY_BREAK
+case 93:
+/* rule 93 can match eol */
+YY_RULE_SETUP
+#line 1012 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/* copy everything until end of input line */
+/* but suppress leading whitespace */
+case 94:
+/* rule 94 can match eol */
+YY_RULE_SETUP
+#line 1020 "psqlscan.l"
+{
+					if (output_buf->len > 0)
+						ECHO;
+				}
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 1025 "psqlscan.l"
+{ ECHO; }
+	YY_BREAK
+
+
+/* at end of command, eat a double backslash, but not anything else */
+case 96:
+YY_RULE_SETUP
+#line 1032 "psqlscan.l"
+{ return LEXRES_OK; }
+	YY_BREAK
+case 97:
+/* rule 97 can match eol */
+YY_RULE_SETUP
+#line 1034 "psqlscan.l"
+{
+					yyless(0);
+					return LEXRES_OK;
+				}
+	YY_BREAK
+
+case 98:
+YY_RULE_SETUP
+#line 1041 "psqlscan.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 5614 "psqlscan.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 1041 "psqlscan.l"
+
+
+
+/*
+ * Create a lexer working state struct.
+ */
+PsqlScanState
+psql_scan_create(void)
+{
+	PsqlScanState state;
+
+	state = (PsqlScanStateData *) pg_malloc_zero(sizeof(PsqlScanStateData));
+
+	psql_scan_reset(state);
+
+	return state;
+}
+
+/*
+ * Destroy a lexer working state struct, releasing all resources.
+ */
+void
+psql_scan_destroy(PsqlScanState state)
+{
+	psql_scan_finish(state);
+
+	psql_scan_reset(state);
+
+	free(state);
+}
+
+/*
+ * Set up to perform lexing of the given input line.
+ *
+ * The text at *line, extending for line_len bytes, will be scanned by
+ * subsequent calls to the psql_scan routines.  psql_scan_finish should
+ * be called when scanning is complete.  Note that the lexer retains
+ * a pointer to the storage at *line --- this string must not be altered
+ * or freed until after psql_scan_finish is called.
+ */
+void
+psql_scan_setup(PsqlScanState state,
+				const char *line, int line_len)
+{
+	/* Mustn't be scanning already */
+	psql_assert(state->scanbufhandle == NULL);
+	psql_assert(state->buffer_stack == NULL);
+
+	/* Do we need to hack the character set encoding? */
+	state->encoding = pset.encoding;
+	state->safe_encoding = pg_valid_server_encoding_id(state->encoding);
+
+	/* needed for prepare_buffer */
+	cur_state = state;
+
+	/* Set up flex input buffer with appropriate translation and padding */
+	state->scanbufhandle = prepare_buffer(line, line_len,
+										  &state->scanbuf);
+	state->scanline = line;
+
+	/* Set lookaside data in case we have to map unsafe encoding */
+	state->curline = state->scanbuf;
+	state->refline = state->scanline;
+}
+
+/*
+ * Do lexical analysis of SQL command text.
+ *
+ * The text previously passed to psql_scan_setup is scanned, and appended
+ * (possibly with transformation) to query_buf.
+ *
+ * The return value indicates the condition that stopped scanning:
+ *
+ * PSCAN_SEMICOLON: found a command-ending semicolon.  (The semicolon is
+ * transferred to query_buf.)  The command accumulated in query_buf should
+ * be executed, then clear query_buf and call again to scan the remainder
+ * of the line.
+ *
+ * PSCAN_BACKSLASH: found a backslash that starts a psql special command.
+ * Any previous data on the line has been transferred to query_buf.
+ * The caller will typically next call psql_scan_slash_command(),
+ * perhaps psql_scan_slash_option(), and psql_scan_slash_command_end().
+ *
+ * PSCAN_INCOMPLETE: the end of the line was reached, but we have an
+ * incomplete SQL command.  *prompt is set to the appropriate prompt type.
+ *
+ * PSCAN_EOL: the end of the line was reached, and there is no lexical
+ * reason to consider the command incomplete.  The caller may or may not
+ * choose to send it.  *prompt is set to the appropriate prompt type if
+ * the caller chooses to collect more input.
+ *
+ * In the PSCAN_INCOMPLETE and PSCAN_EOL cases, psql_scan_finish() should
+ * be called next, then the cycle may be repeated with a fresh input line.
+ *
+ * In all cases, *prompt is set to an appropriate prompt type code for the
+ * next line-input operation.
+ */
+PsqlScanResult
+psql_scan(PsqlScanState state,
+		  PQExpBuffer query_buf,
+		  promptStatus_t *prompt)
+{
+	PsqlScanResult result;
+	int			lexresult;
+
+	/* Must be scanning already */
+	psql_assert(state->scanbufhandle);
+
+	/* Set up static variables that will be used by yylex */
+	cur_state = state;
+	output_buf = query_buf;
+
+	if (state->buffer_stack != NULL)
+		yy_switch_to_buffer(state->buffer_stack->buf);
+	else
+		yy_switch_to_buffer(state->scanbufhandle);
+
+	BEGIN(state->start_state);
+
+	/* And lex. */
+	lexresult = yylex();
+
+	/* Update static vars back to the state struct */
+	state->start_state = YY_START;
+
+	/*
+	 * Check termination state and return appropriate result info.
+	 */
+	switch (lexresult)
+	{
+		case LEXRES_EOL:		/* end of input */
+			switch (state->start_state)
+			{
+				case INITIAL:
+					if (state->paren_depth > 0)
+					{
+						result = PSCAN_INCOMPLETE;
+						*prompt = PROMPT_PAREN;
+					}
+					else if (query_buf->len > 0)
+					{
+						result = PSCAN_EOL;
+						*prompt = PROMPT_CONTINUE;
+					}
+					else
+					{
+						/* never bother to send an empty buffer */
+						result = PSCAN_INCOMPLETE;
+						*prompt = PROMPT_READY;
+					}
+					break;
+				case xb:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_SINGLEQUOTE;
+					break;
+				case xc:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_COMMENT;
+					break;
+				case xd:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_DOUBLEQUOTE;
+					break;
+				case xh:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_SINGLEQUOTE;
+					break;
+				case xq:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_SINGLEQUOTE;
+					break;
+				case xe:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_SINGLEQUOTE;
+					break;
+				case xdolq:
+					result = PSCAN_INCOMPLETE;
+					*prompt = PROMPT_DOLLARQUOTE;
+					break;
+				default:
+					/* can't get here */
+					fprintf(stderr, "invalid YY_START\n");
+					exit(1);
+			}
+			break;
+		case LEXRES_SEMI:		/* semicolon */
+			result = PSCAN_SEMICOLON;
+			*prompt = PROMPT_READY;
+			break;
+		case LEXRES_BACKSLASH:	/* backslash */
+			result = PSCAN_BACKSLASH;
+			*prompt = PROMPT_READY;
+			break;
+		default:
+			/* can't get here */
+			fprintf(stderr, "invalid yylex result\n");
+			exit(1);
+	}
+
+	return result;
+}
+
+/*
+ * Clean up after scanning a string.  This flushes any unread input and
+ * releases resources (but not the PsqlScanState itself).  Note however
+ * that this does not reset the lexer scan state; that can be done by
+ * psql_scan_reset(), which is an orthogonal operation.
+ *
+ * It is legal to call this when not scanning anything (makes it easier
+ * to deal with error recovery).
+ */
+void
+psql_scan_finish(PsqlScanState state)
+{
+	/* Drop any incomplete variable expansions. */
+	while (state->buffer_stack != NULL)
+		pop_buffer_stack(state);
+
+	/* Done with the outer scan buffer, too */
+	if (state->scanbufhandle)
+		yy_delete_buffer(state->scanbufhandle);
+	state->scanbufhandle = NULL;
+	if (state->scanbuf)
+		free(state->scanbuf);
+	state->scanbuf = NULL;
+}
+
+/*
+ * Reset lexer scanning state to start conditions.  This is appropriate
+ * for executing \r psql commands (or any other time that we discard the
+ * prior contents of query_buf).  It is not, however, necessary to do this
+ * when we execute and clear the buffer after getting a PSCAN_SEMICOLON or
+ * PSCAN_EOL scan result, because the scan state must be INITIAL when those
+ * conditions are returned.
+ *
+ * Note that this is unrelated to flushing unread input; that task is
+ * done by psql_scan_finish().
+ */
+void
+psql_scan_reset(PsqlScanState state)
+{
+	state->start_state = INITIAL;
+	state->paren_depth = 0;
+	state->xcdepth = 0;			/* not really necessary */
+	if (state->dolqstart)
+		free(state->dolqstart);
+	state->dolqstart = NULL;
+}
+
+/*
+ * Return true if lexer is currently in an "inside quotes" state.
+ *
+ * This is pretty grotty but is needed to preserve the old behavior
+ * that mainloop.c drops blank lines not inside quotes without even
+ * echoing them.
+ */
+bool
+psql_scan_in_quote(PsqlScanState state)
+{
+	return state->start_state != INITIAL;
+}
+
+/*
+ * Scan the command name of a psql backslash command.  This should be called
+ * after psql_scan() returns PSCAN_BACKSLASH.  It is assumed that the input
+ * has been consumed through the leading backslash.
+ *
+ * The return value is a malloc'd copy of the command name, as parsed off
+ * from the input.
+ */
+char *
+psql_scan_slash_command(PsqlScanState state)
+{
+	PQExpBufferData mybuf;
+	int			lexresult;
+
+	/* Must be scanning already */
+	psql_assert(state->scanbufhandle);
+
+	/* Build a local buffer that we'll return the data of */
+	initPQExpBuffer(&mybuf);
+
+	/* Set up static variables that will be used by yylex */
+	cur_state = state;
+	output_buf = &mybuf;
+
+	if (state->buffer_stack != NULL)
+		yy_switch_to_buffer(state->buffer_stack->buf);
+	else
+		yy_switch_to_buffer(state->scanbufhandle);
+
+	BEGIN(xslashcmd);
+
+	/* And lex. */
+	lexresult = yylex();
+
+	/* There are no possible errors in this lex state... */
+
+	return mybuf.data;
+}
+
+/*
+ * Parse off the next argument for a backslash command, and return it as a
+ * malloc'd string.  If there are no more arguments, returns NULL.
+ *
+ * type tells what processing, if any, to perform on the option string;
+ * for example, if it's a SQL identifier, we want to downcase any unquoted
+ * letters.
+ *
+ * if quote is not NULL, *quote is set to 0 if no quoting was found, else
+ * the quote symbol.
+ *
+ * if semicolon is true, unquoted trailing semicolon(s) that would otherwise
+ * be taken as part of the option string will be stripped.
+ *
+ * NOTE: the only possible syntax errors for backslash options are unmatched
+ * quotes, which are detected when we run out of input.  Therefore, on a
+ * syntax error we just throw away the string and return NULL; there is no
+ * need to worry about flushing remaining input.
+ */
+char *
+psql_scan_slash_option(PsqlScanState state,
+					   enum slash_option_type type,
+					   char *quote,
+					   bool semicolon)
+{
+	PQExpBufferData mybuf;
+	int			lexresult;
+	char		local_quote;
+	bool		badarg;
+
+	/* Must be scanning already */
+	psql_assert(state->scanbufhandle);
+
+	if (quote == NULL)
+		quote = &local_quote;
+	*quote = 0;
+
+	/* Build a local buffer that we'll return the data of */
+	initPQExpBuffer(&mybuf);
+
+	/* Set up static variables that will be used by yylex */
+	cur_state = state;
+	output_buf = &mybuf;
+	option_type = type;
+	option_quote = quote;
+
+	if (state->buffer_stack != NULL)
+		yy_switch_to_buffer(state->buffer_stack->buf);
+	else
+		yy_switch_to_buffer(state->scanbufhandle);
+
+	if (type == OT_WHOLE_LINE)
+		BEGIN(xslashwholeline);
+	else
+		BEGIN(xslasharg);
+
+	/* And lex. */
+	lexresult = yylex();
+
+	/*
+	 * Check the lex result: we should have gotten back either LEXRES_OK
+	 * or LEXRES_EOL (the latter indicating end of string).  If we were inside
+	 * a quoted string, as indicated by YY_START, EOL is an error.
+	 */
+	psql_assert(lexresult == LEXRES_EOL || lexresult == LEXRES_OK);
+	badarg = false;
+	switch (YY_START)
+	{
+		case xslasharg:
+			/* empty arg, or possibly a psql variable substitution */
+			break;
+		case xslashquote:
+			if (lexresult != LEXRES_OK)
+				badarg = true;		/* hit EOL not ending quote */
+			break;
+		case xslashbackquote:
+			if (lexresult != LEXRES_OK)
+				badarg = true;		/* hit EOL not ending quote */
+			else
+			{
+				/* Perform evaluation of backticked command */
+				char	   *cmd = mybuf.data;
+				FILE	   *fd;
+				bool		error = false;
+				PQExpBufferData output;
+				char		buf[512];
+				size_t		result;
+
+				fd = popen(cmd, PG_BINARY_R);
+				if (!fd)
+				{
+					psql_error("%s: %s\n", cmd, strerror(errno));
+					error = true;
+				}
+
+				initPQExpBuffer(&output);
+
+				if (!error)
+				{
+					do
+					{
+						result = fread(buf, 1, sizeof(buf), fd);
+						if (ferror(fd))
+						{
+							psql_error("%s: %s\n", cmd, strerror(errno));
+							error = true;
+							break;
+						}
+						appendBinaryPQExpBuffer(&output, buf, result);
+					} while (!feof(fd));
+				}
+
+				if (fd && pclose(fd) == -1)
+				{
+					psql_error("%s: %s\n", cmd, strerror(errno));
+					error = true;
+				}
+
+				if (PQExpBufferBroken(&output))
+				{
+					psql_error("%s: out of memory\n", cmd);
+					error = true;
+				}
+
+				/* Now done with cmd, transfer result to mybuf */
+				resetPQExpBuffer(&mybuf);
+
+				if (!error)
+				{
+					/* strip any trailing newline */
+					if (output.len > 0 &&
+						output.data[output.len - 1] == '\n')
+						output.len--;
+					appendBinaryPQExpBuffer(&mybuf, output.data, output.len);
+				}
+
+				termPQExpBuffer(&output);
+			}
+			break;
+		case xslashdefaultarg:
+			/* Strip any trailing semi-colons if requested */
+			if (semicolon)
+			{
+				while (mybuf.len > 0 &&
+					   mybuf.data[mybuf.len - 1] == ';')
+				{
+					mybuf.data[--mybuf.len] = '\0';
+				}
+			}
+
+			/*
+			 * If SQL identifier processing was requested, then we strip out
+			 * excess double quotes and downcase unquoted letters.
+			 * Doubled double-quotes become output double-quotes, per spec.
+			 *
+			 * Note that a string like FOO"BAR"BAZ will be converted to
+			 * fooBARbaz; this is somewhat inconsistent with the SQL spec,
+			 * which would have us parse it as several identifiers.  But
+			 * for psql's purposes, we want a string like "foo"."bar" to
+			 * be treated as one option, so there's little choice.
+			 */
+			if (type == OT_SQLID || type == OT_SQLIDHACK)
+			{
+				bool		inquotes = false;
+				char	   *cp = mybuf.data;
+
+				while (*cp)
+				{
+					if (*cp == '"')
+					{
+						if (inquotes && cp[1] == '"')
+						{
+							/* Keep the first quote, remove the second */
+							cp++;
+						}
+						inquotes = !inquotes;
+						/* Collapse out quote at *cp */
+						memmove(cp, cp + 1, strlen(cp));
+						mybuf.len--;
+						/* do not advance cp */
+					}
+					else
+					{
+						if (!inquotes && type == OT_SQLID)
+							*cp = pg_tolower((unsigned char) *cp);
+						cp += PQmblen(cp, pset.encoding);
+					}
+				}
+			}
+			break;
+		case xslashquotedarg:
+			/* must have hit EOL inside double quotes */
+			badarg = true;
+			break;
+		case xslashwholeline:
+			/* always okay */
+			break;
+		default:
+			/* can't get here */
+			fprintf(stderr, "invalid YY_START\n");
+			exit(1);
+	}
+
+	if (badarg)
+	{
+		psql_error("unterminated quoted string\n");
+		termPQExpBuffer(&mybuf);
+		return NULL;
+	}
+
+	/*
+	 * An unquoted empty argument isn't possible unless we are at end of
+	 * command.  Return NULL instead.
+	 */
+	if (mybuf.len == 0 && *quote == 0)
+	{
+		termPQExpBuffer(&mybuf);
+		return NULL;
+	}
+
+	/* Else return the completed string. */
+	return mybuf.data;
+}
+
+/*
+ * Eat up any unused \\ to complete a backslash command.
+ */
+void
+psql_scan_slash_command_end(PsqlScanState state)
+{
+	int			lexresult;
+
+	/* Must be scanning already */
+	psql_assert(state->scanbufhandle);
+
+	/* Set up static variables that will be used by yylex */
+	cur_state = state;
+	output_buf = NULL;
+
+	if (state->buffer_stack != NULL)
+		yy_switch_to_buffer(state->buffer_stack->buf);
+	else
+		yy_switch_to_buffer(state->scanbufhandle);
+
+	BEGIN(xslashend);
+
+	/* And lex. */
+	lexresult = yylex();
+
+	/* There are no possible errors in this lex state... */
+}
+
+
+/*
+ * Push the given string onto the stack of stuff to scan.
+ *
+ * cur_state must point to the active PsqlScanState.
+ *
+ * NOTE SIDE EFFECT: the new buffer is made the active flex input buffer.
+ */
+static void
+push_new_buffer(const char *newstr, const char *varname)
+{
+	StackElem  *stackelem;
+
+	stackelem = (StackElem *) pg_malloc(sizeof(StackElem));
+
+	/*
+	 * In current usage, the passed varname points at the current flex
+	 * input buffer; we must copy it before calling prepare_buffer()
+	 * because that will change the buffer state.
+	 */
+	stackelem->varname = varname ? pg_strdup(varname) : NULL;
+
+	stackelem->buf = prepare_buffer(newstr, strlen(newstr),
+									&stackelem->bufstring);
+	cur_state->curline = stackelem->bufstring;
+	if (cur_state->safe_encoding)
+	{
+		stackelem->origstring = NULL;
+		cur_state->refline = stackelem->bufstring;
+	}
+	else
+	{
+		stackelem->origstring = pg_strdup(newstr);
+		cur_state->refline = stackelem->origstring;
+	}
+	stackelem->next = cur_state->buffer_stack;
+	cur_state->buffer_stack = stackelem;
+}
+
+/*
+ * Pop the topmost buffer stack item (there must be one!)
+ *
+ * NB: after this, the flex input state is unspecified; caller must
+ * switch to an appropriate buffer to continue lexing.
+ */
+static void
+pop_buffer_stack(PsqlScanState state)
+{
+	StackElem  *stackelem = state->buffer_stack;
+
+	state->buffer_stack = stackelem->next;
+	yy_delete_buffer(stackelem->buf);
+	free(stackelem->bufstring);
+	if (stackelem->origstring)
+		free(stackelem->origstring);
+	if (stackelem->varname)
+		free(stackelem->varname);
+	free(stackelem);
+}
+
+/*
+ * Check if specified variable name is the source for any string
+ * currently being scanned
+ */
+static bool
+var_is_current_source(PsqlScanState state, const char *varname)
+{
+	StackElem  *stackelem;
+
+	for (stackelem = state->buffer_stack;
+		 stackelem != NULL;
+		 stackelem = stackelem->next)
+	{
+		if (stackelem->varname && strcmp(stackelem->varname, varname) == 0)
+			return true;
+	}
+	return false;
+}
+
+/*
+ * Set up a flex input buffer to scan the given data.  We always make a
+ * copy of the data.  If working in an unsafe encoding, the copy has
+ * multibyte sequences replaced by FFs to avoid fooling the lexer rules.
+ *
+ * cur_state must point to the active PsqlScanState.
+ *
+ * NOTE SIDE EFFECT: the new buffer is made the active flex input buffer.
+ */
+static YY_BUFFER_STATE
+prepare_buffer(const char *txt, int len, char **txtcopy)
+{
+	char	   *newtxt;
+
+	/* Flex wants two \0 characters after the actual data */
+	newtxt = pg_malloc(len + 2);
+	*txtcopy = newtxt;
+	newtxt[len] = newtxt[len + 1] = YY_END_OF_BUFFER_CHAR;
+
+	if (cur_state->safe_encoding)
+		memcpy(newtxt, txt, len);
+	else
+	{
+		/* Gotta do it the hard way */
+		int		i = 0;
+
+		while (i < len)
+		{
+			int		thislen = PQmblen(txt + i, cur_state->encoding);
+
+			/* first byte should always be okay... */
+			newtxt[i] = txt[i];
+			i++;
+			while (--thislen > 0 && i < len)
+				newtxt[i++] = (char) 0xFF;
+		}
+	}
+
+	return yy_scan_buffer(newtxt,len + 2);
+}
+
+/*
+ * emit() --- body for ECHO macro
+ *
+ * NB: this must be used for ALL and ONLY the text copied from the flex
+ * input data.  If you pass it something that is not part of the yytext
+ * string, you are making a mistake.  Internally generated text can be
+ * appended directly to output_buf.
+ */
+static void
+emit(const char *txt, int len)
+{
+	if (cur_state->safe_encoding)
+		appendBinaryPQExpBuffer(output_buf, txt, len);
+	else
+	{
+		/* Gotta do it the hard way */
+		const char *reference = cur_state->refline;
+		int		i;
+
+		reference += (txt - cur_state->curline);
+
+		for (i = 0; i < len; i++)
+		{
+			char	ch = txt[i];
+
+			if (ch == (char) 0xFF)
+				ch = reference[i];
+			appendPQExpBufferChar(output_buf, ch);
+		}
+	}
+}
+
diff --git a/src/bin/psql/sql_help.h b/src/bin/psql/sql_help.h
new file mode 100644
index 0000000..7e69a92
--- /dev/null
+++ b/src/bin/psql/sql_help.h
@@ -0,0 +1,593 @@
+/*
+ * *** Do not change this file by hand. It is automatically
+ * *** generated from the DocBook documentation.
+ *
+ * generated by
+ *     /usr/bin/perl create_help.pl ../../../doc/src/sgml/ref sql_help.h
+ *
+ */
+
+#ifndef SQL_HELP_H
+#define SQL_HELP_H
+
+#define N_(x) (x)				/* gettext noop */
+
+struct _helpStruct
+{
+	const char	   *cmd;		/* the command name */
+	const char	   *help;		/* the help associated with it */
+	const char	   *syntax;		/* the syntax associated with it */
+};
+
+
+static const struct _helpStruct QL_HELP[] = {
+    { "ABORT",
+      N_("abort the current transaction"),
+      N_("ABORT [ WORK | TRANSACTION ]") },
+
+    { "ALTER AGGREGATE",
+      N_("change the definition of an aggregate function"),
+      N_("ALTER AGGREGATE name ( type [ , ... ] ) RENAME TO new_name\nALTER AGGREGATE name ( type [ , ... ] ) OWNER TO new_owner\nALTER AGGREGATE name ( type [ , ... ] ) SET SCHEMA new_schema") },
+
+    { "ALTER CONVERSION",
+      N_("change the definition of a conversion"),
+      N_("ALTER CONVERSION name RENAME TO newname\nALTER CONVERSION name OWNER TO newowner") },
+
+    { "ALTER DATABASE",
+      N_("change a database"),
+      N_("ALTER DATABASE name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n\n    CONNECTION LIMIT connlimit\n\nALTER DATABASE name RENAME TO newname\n\nALTER DATABASE name OWNER TO new_owner\n\nALTER DATABASE name SET TABLESPACE new_tablespace\n\nALTER DATABASE name SET configuration_parameter { TO | = } { value | DEFAULT }\nALTER DATABASE name SET configuration_parameter FROM CURRENT\nALTER DATABASE name RESET configuration_parameter\nALTER DATABASE name RESET ALL") },
+
+    { "ALTER DOMAIN",
+      N_("change the definition of a domain"),
+      N_("ALTER DOMAIN name\n    { SET DEFAULT expression | DROP DEFAULT }\nALTER DOMAIN name\n    { SET | DROP } NOT NULL\nALTER DOMAIN name\n    ADD domain_constraint\nALTER DOMAIN name\n    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]\nALTER DOMAIN name\n    OWNER TO new_owner \nALTER DOMAIN name\n    SET SCHEMA new_schema") },
+
+    { "ALTER FOREIGN DATA WRAPPER",
+      N_("change the definition of a foreign-data wrapper"),
+      N_("ALTER FOREIGN DATA WRAPPER name\n    [ VALIDATOR valfunction | NO VALIDATOR ]\n    [ OPTIONS ( [ ADD | SET | DROP ] option ['value'] [, ... ]) ]\nALTER FOREIGN DATA WRAPPER name OWNER TO new_owner") },
+
+    { "ALTER FUNCTION",
+      N_("change the definition of a function"),
+      N_("ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )\n    action [ ... ] [ RESTRICT ]\nALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )\n    RENAME TO new_name\nALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )\n    OWNER TO new_owner\nALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )\n    SET SCHEMA new_schema\n\nwhere action is one of:\n\n    CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT\n    IMMUTABLE | STABLE | VOLATILE\n    [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER\n    COST execution_cost\n    ROWS result_rows\n    SET configuration_parameter { TO | = } { value | DEFAULT }\n    SET configuration_parameter FROM CURRENT\n    RESET configuration_parameter\n    RESET ALL") },
+
+    { "ALTER GROUP",
+      N_("change role name or membership"),
+      N_("ALTER GROUP groupname ADD USER username [, ... ]\nALTER GROUP groupname DROP USER username [, ... ]\n\nALTER GROUP groupname RENAME TO newname") },
+
+    { "ALTER INDEX",
+      N_("change the definition of an index"),
+      N_("ALTER INDEX name RENAME TO new_name\nALTER INDEX name SET TABLESPACE tablespace_name\nALTER INDEX name SET ( storage_parameter = value [, ... ] )\nALTER INDEX name RESET ( storage_parameter [, ... ] )") },
+
+    { "ALTER LANGUAGE",
+      N_("change the definition of a procedural language"),
+      N_("ALTER [ PROCEDURAL ] LANGUAGE name RENAME TO newname\nALTER [ PROCEDURAL ] LANGUAGE name OWNER TO new_owner") },
+
+    { "ALTER OPERATOR",
+      N_("change the definition of an operator"),
+      N_("ALTER OPERATOR name ( { lefttype | NONE } , { righttype | NONE } ) OWNER TO newowner") },
+
+    { "ALTER OPERATOR CLASS",
+      N_("change the definition of an operator class"),
+      N_("ALTER OPERATOR CLASS name USING index_method RENAME TO newname\nALTER OPERATOR CLASS name USING index_method OWNER TO newowner") },
+
+    { "ALTER OPERATOR FAMILY",
+      N_("change the definition of an operator family"),
+      N_("ALTER OPERATOR FAMILY name USING index_method ADD\n  {  OPERATOR strategy_number operator_name ( op_type, op_type )\n   | FUNCTION support_number [ ( op_type [ , op_type ] ) ] funcname ( argument_type [, ...] )\n  } [, ... ]\nALTER OPERATOR FAMILY name USING index_method DROP\n  {  OPERATOR strategy_number ( op_type [ , op_type ] )\n   | FUNCTION support_number ( op_type [ , op_type ] )\n  } [, ... ]\nALTER OPERATOR FAMILY name USING index_method RENAME TO newname\nALTER OPERATOR FAMILY name USING index_method OWNER TO newowner") },
+
+    { "ALTER ROLE",
+      N_("change a database role"),
+      N_("ALTER ROLE name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n    \n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | CREATEUSER | NOCREATEUSER\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'\n    | VALID UNTIL 'timestamp' \n\nALTER ROLE name RENAME TO newname\n\nALTER ROLE name SET configuration_parameter { TO | = } { value | DEFAULT }\nALTER ROLE name SET configuration_parameter FROM CURRENT\nALTER ROLE name RESET configuration_parameter\nALTER ROLE name RESET ALL") },
+
+    { "ALTER SCHEMA",
+      N_("change the definition of a schema"),
+      N_("ALTER SCHEMA name RENAME TO newname\nALTER SCHEMA name OWNER TO newowner") },
+
+    { "ALTER SEQUENCE",
+      N_("change the definition of a sequence generator"),
+      N_("ALTER SEQUENCE name [ INCREMENT [ BY ] increment ]\n    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]\n    [ START [ WITH ] start ]\n    [ RESTART [ [ WITH ] restart ] ]\n    [ CACHE cache ] [ [ NO ] CYCLE ]\n    [ OWNED BY { table.column | NONE } ]\nALTER SEQUENCE name OWNER TO new_owner\nALTER SEQUENCE name RENAME TO new_name\nALTER SEQUENCE name SET SCHEMA new_schema") },
+
+    { "ALTER SERVER",
+      N_("change the definition of a foreign server"),
+      N_("ALTER SERVER servername [ VERSION 'newversion' ]\n    [ OPTIONS ( [ ADD | SET | DROP ] option ['value'] [, ... ] ) ]\nALTER SERVER servername OWNER TO new_owner") },
+
+    { "ALTER TABLE",
+      N_("change the definition of a table"),
+      N_("ALTER TABLE [ ONLY ] name [ * ]\n    action [, ... ]\nALTER TABLE [ ONLY ] name [ * ]\n    RENAME [ COLUMN ] column TO new_column\nALTER TABLE name\n    RENAME TO new_name\nALTER TABLE name\n    SET SCHEMA new_schema\n\nwhere action is one of:\n\n    ADD [ COLUMN ] column type [ column_constraint [ ... ] ]\n    DROP [ COLUMN ] column [ RESTRICT | CASCADE ]\n    ALTER [ COLUMN ] column [ SET DATA ] TYPE type [ USING expression ]\n    ALTER [ COLUMN ] column SET DEFAULT expression\n    ALTER [ COLUMN ] column DROP DEFAULT\n    ALTER [ COLUMN ] column { SET | DROP } NOT NULL\n    ALTER [ COLUMN ] column SET STATISTICS integer\n    ALTER [ COLUMN ] column SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }\n    ADD table_constraint\n    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]\n    DISABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE REPLICA TRIGGER trigger_name\n    ENABLE ALWAYS TRIGGER trigger_name\n    DISABLE RULE rewrite_rule_name\n    ENABLE RULE rewrite_rule_name\n    ENABLE REPLICA RULE rewrite_rule_name\n    ENABLE ALWAYS RULE rewrite_rule_name\n    CLUSTER ON index_name\n    SET WITHOUT CLUSTER\n    SET WITH OIDS\n    SET WITHOUT OIDS\n    SET ( storage_parameter = value [, ... ] )\n    RESET ( storage_parameter [, ... ] )\n    INHERIT parent_table\n    NO INHERIT parent_table\n    OWNER TO new_owner\n    SET TABLESPACE new_tablespace") },
+
+    { "ALTER TABLESPACE",
+      N_("change the definition of a tablespace"),
+      N_("ALTER TABLESPACE name RENAME TO newname\nALTER TABLESPACE name OWNER TO newowner") },
+
+    { "ALTER TEXT SEARCH CONFIGURATION",
+      N_("change the definition of a text search configuration"),
+      N_("ALTER TEXT SEARCH CONFIGURATION name\n    ADD MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]\nALTER TEXT SEARCH CONFIGURATION name\n    ALTER MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]\nALTER TEXT SEARCH CONFIGURATION name\n    ALTER MAPPING REPLACE old_dictionary WITH new_dictionary\nALTER TEXT SEARCH CONFIGURATION name\n    ALTER MAPPING FOR token_type [, ... ] REPLACE old_dictionary WITH new_dictionary\nALTER TEXT SEARCH CONFIGURATION name\n    DROP MAPPING [ IF EXISTS ] FOR token_type [, ... ]\nALTER TEXT SEARCH CONFIGURATION name RENAME TO newname\nALTER TEXT SEARCH CONFIGURATION name OWNER TO newowner") },
+
+    { "ALTER TEXT SEARCH DICTIONARY",
+      N_("change the definition of a text search dictionary"),
+      N_("ALTER TEXT SEARCH DICTIONARY name (\n    option [ = value ] [, ... ]\n)\nALTER TEXT SEARCH DICTIONARY name RENAME TO newname\nALTER TEXT SEARCH DICTIONARY name OWNER TO newowner") },
+
+    { "ALTER TEXT SEARCH PARSER",
+      N_("change the definition of a text search parser"),
+      N_("ALTER TEXT SEARCH PARSER name RENAME TO newname") },
+
+    { "ALTER TEXT SEARCH TEMPLATE",
+      N_("change the definition of a text search template"),
+      N_("ALTER TEXT SEARCH TEMPLATE name RENAME TO newname") },
+
+    { "ALTER TRIGGER",
+      N_("change the definition of a trigger"),
+      N_("ALTER TRIGGER name ON table RENAME TO newname") },
+
+    { "ALTER TYPE",
+      N_("change the definition of a type"),
+      N_("ALTER TYPE name RENAME TO new_name\nALTER TYPE name OWNER TO new_owner \nALTER TYPE name SET SCHEMA new_schema") },
+
+    { "ALTER USER",
+      N_("change a database role"),
+      N_("ALTER USER name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n    \n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | CREATEUSER | NOCREATEUSER\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'\n    | VALID UNTIL 'timestamp' \n\nALTER USER name RENAME TO newname\n\nALTER USER name SET configuration_parameter { TO | = } { value | DEFAULT }\nALTER USER name SET configuration_parameter FROM CURRENT\nALTER USER name RESET configuration_parameter\nALTER USER name RESET ALL") },
+
+    { "ALTER USER MAPPING",
+      N_("change the definition of a user mapping"),
+      N_("ALTER USER MAPPING FOR { username | USER | CURRENT_USER | PUBLIC }\n    SERVER servername\n    OPTIONS ( [ ADD | SET | DROP ] option ['value'] [, ... ] )") },
+
+    { "ALTER VIEW",
+      N_("change the definition of a view"),
+      N_("ALTER VIEW name ALTER [ COLUMN ] column SET DEFAULT expression\nALTER VIEW name ALTER [ COLUMN ] column DROP DEFAULT\nALTER VIEW name OWNER TO new_owner\nALTER VIEW name RENAME TO new_name\nALTER VIEW name SET SCHEMA new_schema") },
+
+    { "ANALYZE",
+      N_("collect statistics about a database"),
+      N_("ANALYZE [ VERBOSE ] [ table [ ( column [, ...] ) ] ]") },
+
+    { "BEGIN",
+      N_("start a transaction block"),
+      N_("BEGIN [ WORK | TRANSACTION ] [ transaction_mode [, ...] ]\n\nwhere transaction_mode is one of:\n\n    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }\n    READ WRITE | READ ONLY") },
+
+    { "CHECKPOINT",
+      N_("force a transaction log checkpoint"),
+      N_("CHECKPOINT") },
+
+    { "CLOSE",
+      N_("close a cursor"),
+      N_("CLOSE { name | ALL }") },
+
+    { "CLUSTER",
+      N_("cluster a table according to an index"),
+      N_("CLUSTER [VERBOSE] tablename [ USING indexname ]\nCLUSTER [VERBOSE]") },
+
+    { "COMMENT",
+      N_("define or change the comment of an object"),
+      N_("COMMENT ON\n{\n  TABLE object_name |\n  COLUMN table_name.column_name |\n  AGGREGATE agg_name (agg_type [, ...] ) |\n  CAST (sourcetype AS targettype) |\n  CONSTRAINT constraint_name ON table_name |\n  CONVERSION object_name |\n  DATABASE object_name |\n  DOMAIN object_name |\n  FUNCTION func_name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) |\n  INDEX object_name |\n  LARGE OBJECT large_object_oid |\n  OPERATOR op (leftoperand_type, rightoperand_type) |\n  OPERATOR CLASS object_name USING index_method |\n  OPERATOR FAMILY object_name USING index_method |\n  [ PROCEDURAL ] LANGUAGE object_name |\n  ROLE object_name |\n  RULE rule_name ON table_name |\n  SCHEMA object_name |\n  SEQUENCE object_name |\n  TABLESPACE object_name |\n  TEXT SEARCH CONFIGURATION object_name |\n  TEXT SEARCH DICTIONARY object_name |\n  TEXT SEARCH PARSER object_name |\n  TEXT SEARCH TEMPLATE object_name |\n  TRIGGER trigger_name ON table_name |\n  TYPE object_name |\n  VIEW object_name\n} IS 'text'") },
+
+    { "COMMIT",
+      N_("commit the current transaction"),
+      N_("COMMIT [ WORK | TRANSACTION ]") },
+
+    { "COMMIT PREPARED",
+      N_("commit a transaction that was earlier prepared for two-phase commit"),
+      N_("COMMIT PREPARED transaction_id") },
+
+    { "COPY",
+      N_("copy data between a file and a table"),
+      N_("COPY tablename [ ( column [, ...] ) ]\n    FROM { 'filename' | STDIN }\n    [ [ WITH ] \n          [ BINARY ]\n          [ OIDS ]\n          [ DELIMITER [ AS ] 'delimiter' ]\n          [ NULL [ AS ] 'null string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote' ] \n                [ ESCAPE [ AS ] 'escape' ]\n                [ FORCE NOT NULL column [, ...] ]\n\nCOPY { tablename [ ( column [, ...] ) ] | ( query ) }\n    TO { 'filename' | STDOUT }\n    [ [ WITH ] \n          [ BINARY ]\n          [ OIDS ]\n          [ DELIMITER [ AS ] 'delimiter' ]\n          [ NULL [ AS ] 'null string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote' ] \n                [ ESCAPE [ AS ] 'escape' ]\n                [ FORCE QUOTE column [, ...] ]") },
+
+    { "CREATE AGGREGATE",
+      N_("define a new aggregate function"),
+      N_("CREATE AGGREGATE name ( input_data_type [ , ... ] ) (\n    SFUNC = sfunc,\n    STYPE = state_data_type\n    [ , FINALFUNC = ffunc ]\n    [ , INITCOND = initial_condition ]\n    [ , SORTOP = sort_operator ]\n)\n\nor the old syntax\n\nCREATE AGGREGATE name (\n    BASETYPE = base_type,\n    SFUNC = sfunc,\n    STYPE = state_data_type\n    [ , FINALFUNC = ffunc ]\n    [ , INITCOND = initial_condition ]\n    [ , SORTOP = sort_operator ]\n)") },
+
+    { "CREATE CAST",
+      N_("define a new cast"),
+      N_("CREATE CAST (sourcetype AS targettype)\n    WITH FUNCTION funcname (argtypes)\n    [ AS ASSIGNMENT | AS IMPLICIT ]\n\nCREATE CAST (sourcetype AS targettype)\n    WITHOUT FUNCTION\n    [ AS ASSIGNMENT | AS IMPLICIT ]\n\nCREATE CAST (sourcetype AS targettype)\n    WITH INOUT\n    [ AS ASSIGNMENT | AS IMPLICIT ]") },
+
+    { "CREATE CONSTRAINT TRIGGER",
+      N_("define a new constraint trigger"),
+      N_("CREATE CONSTRAINT TRIGGER name\n    AFTER event [ OR ... ]\n    ON table_name\n    [ FROM referenced_table_name ]\n    { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }\n    FOR EACH ROW\n    EXECUTE PROCEDURE funcname ( arguments )") },
+
+    { "CREATE CONVERSION",
+      N_("define a new encoding conversion"),
+      N_("CREATE [ DEFAULT ] CONVERSION name\n    FOR source_encoding TO dest_encoding FROM funcname") },
+
+    { "CREATE DATABASE",
+      N_("create a new database"),
+      N_("CREATE DATABASE name\n    [ [ WITH ] [ OWNER [=] dbowner ]\n           [ TEMPLATE [=] template ]\n           [ ENCODING [=] encoding ]\n           [ LC_COLLATE [=] lc_collate ]\n           [ LC_CTYPE [=] lc_ctype ]\n           [ TABLESPACE [=] tablespace ]\n           [ CONNECTION LIMIT [=] connlimit ] ]") },
+
+    { "CREATE DOMAIN",
+      N_("define a new domain"),
+      N_("CREATE DOMAIN name [ AS ] data_type\n    [ DEFAULT expression ]\n    [ constraint [ ... ] ]\n\nwhere constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL | NULL | CHECK (expression) }") },
+
+    { "CREATE FOREIGN DATA WRAPPER",
+      N_("define a new foreign-data wrapper"),
+      N_("CREATE FOREIGN DATA WRAPPER name\n    [ VALIDATOR valfunction | NO VALIDATOR ]\n    [ OPTIONS ( option 'value' [, ... ] ) ]") },
+
+    { "CREATE FUNCTION",
+      N_("define a new function"),
+      N_("CREATE [ OR REPLACE ] FUNCTION\n    name ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } defexpr ] [, ...] ] )\n    [ RETURNS rettype\n      | RETURNS TABLE ( colname coltype [, ...] ) ]\n  { LANGUAGE langname\n    | WINDOW\n    | IMMUTABLE | STABLE | VOLATILE\n    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT\n    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER\n    | COST execution_cost\n    | ROWS result_rows\n    | SET configuration_parameter { TO value | = value | FROM CURRENT }\n    | AS 'definition'\n    | AS 'obj_file', 'link_symbol'\n  } ...\n    [ WITH ( attribute [, ...] ) ]") },
+
+    { "CREATE GROUP",
+      N_("define a new database role"),
+      N_("CREATE GROUP name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n    \n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | CREATEUSER | NOCREATEUSER\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'\n    | VALID UNTIL 'timestamp' \n    | IN ROLE rolename [, ...]\n    | IN GROUP rolename [, ...]\n    | ROLE rolename [, ...]\n    | ADMIN rolename [, ...]\n    | USER rolename [, ...]\n    | SYSID uid") },
+
+    { "CREATE INDEX",
+      N_("define a new index"),
+      N_("CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] name ON table [ USING method ]\n    ( { column | ( expression ) } [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n    [ WITH ( storage_parameter = value [, ... ] ) ]\n    [ TABLESPACE tablespace ]\n    [ WHERE predicate ]") },
+
+    { "CREATE LANGUAGE",
+      N_("define a new procedural language"),
+      N_("CREATE [ PROCEDURAL ] LANGUAGE name\nCREATE [ TRUSTED ] [ PROCEDURAL ] LANGUAGE name\n    HANDLER call_handler [ VALIDATOR valfunction ]") },
+
+    { "CREATE OPERATOR",
+      N_("define a new operator"),
+      N_("CREATE OPERATOR name (\n    PROCEDURE = funcname\n    [, LEFTARG = lefttype ] [, RIGHTARG = righttype ]\n    [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]\n    [, RESTRICT = res_proc ] [, JOIN = join_proc ]\n    [, HASHES ] [, MERGES ]\n)") },
+
+    { "CREATE OPERATOR CLASS",
+      N_("define a new operator class"),
+      N_("CREATE OPERATOR CLASS name [ DEFAULT ] FOR TYPE data_type\n  USING index_method [ FAMILY family_name ] AS\n  {  OPERATOR strategy_number operator_name [ ( op_type, op_type ) ]\n   | FUNCTION support_number [ ( op_type [ , op_type ] ) ] funcname ( argument_type [, ...] )\n   | STORAGE storage_type\n  } [, ... ]") },
+
+    { "CREATE OPERATOR FAMILY",
+      N_("define a new operator family"),
+      N_("CREATE OPERATOR FAMILY name USING index_method") },
+
+    { "CREATE ROLE",
+      N_("define a new database role"),
+      N_("CREATE ROLE name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n    \n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | CREATEUSER | NOCREATEUSER\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'\n    | VALID UNTIL 'timestamp' \n    | IN ROLE rolename [, ...]\n    | IN GROUP rolename [, ...]\n    | ROLE rolename [, ...]\n    | ADMIN rolename [, ...]\n    | USER rolename [, ...]\n    | SYSID uid") },
+
+    { "CREATE RULE",
+      N_("define a new rewrite rule"),
+      N_("CREATE [ OR REPLACE ] RULE name AS ON event\n    TO table [ WHERE condition ]\n    DO [ ALSO | INSTEAD ] { NOTHING | command | ( command ; command ... ) }") },
+
+    { "CREATE SCHEMA",
+      N_("define a new schema"),
+      N_("CREATE SCHEMA schemaname [ AUTHORIZATION username ] [ schema_element [ ... ] ]\nCREATE SCHEMA AUTHORIZATION username [ schema_element [ ... ] ]") },
+
+    { "CREATE SEQUENCE",
+      N_("define a new sequence generator"),
+      N_("CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]\n    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]\n    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]\n    [ OWNED BY { table.column | NONE } ]") },
+
+    { "CREATE SERVER",
+      N_("define a new foreign server"),
+      N_("CREATE SERVER servername [ TYPE 'servertype' ] [ VERSION 'serverversion' ]\n    FOREIGN DATA WRAPPER fdwname\n    [ OPTIONS ( option 'value' [, ... ] ) ]") },
+
+    { "CREATE TABLE",
+      N_("define a new table"),
+      N_("CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name ( [\n  { column_name data_type [ DEFAULT default_expr ] [ column_constraint [ ... ] ]\n    | table_constraint\n    | LIKE parent_table [ { INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES } ] ... }\n    [, ... ]\n] )\n[ INHERITS ( parent_table [, ... ] ) ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace ]\n\nwhere column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL | \n  NULL | \n  UNIQUE index_parameters |\n  PRIMARY KEY index_parameters |\n  CHECK ( expression ) |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n    [ ON DELETE action ] [ ON UPDATE action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ UNIQUE ( column_name [, ... ] ) index_parameters |\n  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n  CHECK ( expression ) |\n  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nindex_parameters in UNIQUE and PRIMARY KEY constraints are:\n\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ USING INDEX TABLESPACE tablespace ]") },
+
+    { "CREATE TABLE AS",
+      N_("define a new table from the results of a query"),
+      N_("CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name\n    [ (column_name [, ...] ) ]\n    [ WITH ( storage_parameter [= value] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n    [ TABLESPACE tablespace ]\n    AS query\n    [ WITH [ NO ] DATA ]") },
+
+    { "CREATE TABLESPACE",
+      N_("define a new tablespace"),
+      N_("CREATE TABLESPACE tablespacename [ OWNER username ] LOCATION 'directory'") },
+
+    { "CREATE TEXT SEARCH CONFIGURATION",
+      N_("define a new text search configuration"),
+      N_("CREATE TEXT SEARCH CONFIGURATION name (\n    PARSER = parser_name |\n    COPY = source_config\n)") },
+
+    { "CREATE TEXT SEARCH DICTIONARY",
+      N_("define a new text search dictionary"),
+      N_("CREATE TEXT SEARCH DICTIONARY name (\n    TEMPLATE = template\n    [, option = value [, ... ]]\n)") },
+
+    { "CREATE TEXT SEARCH PARSER",
+      N_("define a new text search parser"),
+      N_("CREATE TEXT SEARCH PARSER name (\n    START = start_function ,\n    GETTOKEN = gettoken_function ,\n    END = end_function ,\n    LEXTYPES = lextypes_function\n    [, HEADLINE = headline_function ]\n)") },
+
+    { "CREATE TEXT SEARCH TEMPLATE",
+      N_("define a new text search template"),
+      N_("CREATE TEXT SEARCH TEMPLATE name (\n    [ INIT = init_function , ]\n    LEXIZE = lexize_function\n)") },
+
+    { "CREATE TRIGGER",
+      N_("define a new trigger"),
+      N_("CREATE TRIGGER name { BEFORE | AFTER } { event [ OR ... ] }\n    ON table [ FOR [ EACH ] { ROW | STATEMENT } ]\n    EXECUTE PROCEDURE funcname ( arguments )") },
+
+    { "CREATE TYPE",
+      N_("define a new data type"),
+      N_("CREATE TYPE name AS\n    ( attribute_name data_type [, ... ] )\n\nCREATE TYPE name AS ENUM\n    ( 'label' [, ... ] )\n\nCREATE TYPE name (\n    INPUT = input_function,\n    OUTPUT = output_function\n    [ , RECEIVE = receive_function ]\n    [ , SEND = send_function ]\n    [ , TYPMOD_IN = type_modifier_input_function ]\n    [ , TYPMOD_OUT = type_modifier_output_function ]\n    [ , ANALYZE = analyze_function ]\n    [ , INTERNALLENGTH = { internallength | VARIABLE } ]\n    [ , PASSEDBYVALUE ]\n    [ , ALIGNMENT = alignment ]\n    [ , STORAGE = storage ]\n    [ , LIKE = like_type ]\n    [ , CATEGORY = category ]\n    [ , PREFERRED = preferred ]\n    [ , DEFAULT = default ]\n    [ , ELEMENT = element ]\n    [ , DELIMITER = delimiter ]\n)\n\nCREATE TYPE name") },
+
+    { "CREATE USER",
+      N_("define a new database role"),
+      N_("CREATE USER name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n    \n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | CREATEUSER | NOCREATEUSER\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'\n    | VALID UNTIL 'timestamp' \n    | IN ROLE rolename [, ...]\n    | IN GROUP rolename [, ...]\n    | ROLE rolename [, ...]\n    | ADMIN rolename [, ...]\n    | USER rolename [, ...]\n    | SYSID uid") },
+
+    { "CREATE USER MAPPING",
+      N_("define a new mapping of a user to a foreign server"),
+      N_("CREATE USER MAPPING FOR { username | USER | CURRENT_USER | PUBLIC }\n    SERVER servername\n    [ OPTIONS ( option 'value' [ , ... ] ) ]") },
+
+    { "CREATE VIEW",
+      N_("define a new view"),
+      N_("CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW name [ ( column_name [, ...] ) ]\n    AS query") },
+
+    { "DEALLOCATE",
+      N_("deallocate a prepared statement"),
+      N_("DEALLOCATE [ PREPARE ] { name | ALL }") },
+
+    { "DECLARE",
+      N_("define a cursor"),
+      N_("DECLARE name [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]\n    CURSOR [ { WITH | WITHOUT } HOLD ] FOR query") },
+
+    { "DELETE",
+      N_("delete rows of a table"),
+      N_("DELETE FROM [ ONLY ] table [ * ] [ [ AS ] alias ]\n    [ USING usinglist ]\n    [ WHERE condition | WHERE CURRENT OF cursor_name ]\n    [ RETURNING * | output_expression [ [ AS ] output_name ] [, ...] ]") },
+
+    { "DISCARD",
+      N_("discard session state"),
+      N_("DISCARD { ALL | PLANS | TEMPORARY | TEMP }") },
+
+    { "DROP AGGREGATE",
+      N_("remove an aggregate function"),
+      N_("DROP AGGREGATE [ IF EXISTS ] name ( type [ , ... ] ) [ CASCADE | RESTRICT ]") },
+
+    { "DROP CAST",
+      N_("remove a cast"),
+      N_("DROP CAST [ IF EXISTS ] (sourcetype AS targettype) [ CASCADE | RESTRICT ]") },
+
+    { "DROP CONVERSION",
+      N_("remove a conversion"),
+      N_("DROP CONVERSION [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP DATABASE",
+      N_("remove a database"),
+      N_("DROP DATABASE [ IF EXISTS ] name") },
+
+    { "DROP DOMAIN",
+      N_("remove a domain"),
+      N_("DROP DOMAIN [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP FOREIGN DATA WRAPPER",
+      N_("remove a foreign-data wrapper"),
+      N_("DROP FOREIGN DATA WRAPPER [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP FUNCTION",
+      N_("remove a function"),
+      N_("DROP FUNCTION [ IF EXISTS ] name ( [ [ argmode ] [ argname ] argtype [, ...] ] )\n    [ CASCADE | RESTRICT ]") },
+
+    { "DROP GROUP",
+      N_("remove a database role"),
+      N_("DROP GROUP [ IF EXISTS ] name [, ...]") },
+
+    { "DROP INDEX",
+      N_("remove an index"),
+      N_("DROP INDEX [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP LANGUAGE",
+      N_("remove a procedural language"),
+      N_("DROP [ PROCEDURAL ] LANGUAGE [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP OPERATOR",
+      N_("remove an operator"),
+      N_("DROP OPERATOR [ IF EXISTS ] name ( { lefttype | NONE } , { righttype | NONE } ) [ CASCADE | RESTRICT ]") },
+
+    { "DROP OPERATOR CLASS",
+      N_("remove an operator class"),
+      N_("DROP OPERATOR CLASS [ IF EXISTS ] name USING index_method [ CASCADE | RESTRICT ]") },
+
+    { "DROP OPERATOR FAMILY",
+      N_("remove an operator family"),
+      N_("DROP OPERATOR FAMILY [ IF EXISTS ] name USING index_method [ CASCADE | RESTRICT ]") },
+
+    { "DROP OWNED",
+      N_("remove database objects owned by a database role"),
+      N_("DROP OWNED BY name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP ROLE",
+      N_("remove a database role"),
+      N_("DROP ROLE [ IF EXISTS ] name [, ...]") },
+
+    { "DROP RULE",
+      N_("remove a rewrite rule"),
+      N_("DROP RULE [ IF EXISTS ] name ON relation [ CASCADE | RESTRICT ]") },
+
+    { "DROP SCHEMA",
+      N_("remove a schema"),
+      N_("DROP SCHEMA [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP SEQUENCE",
+      N_("remove a sequence"),
+      N_("DROP SEQUENCE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP SERVER",
+      N_("remove a foreign server descriptor"),
+      N_("DROP SERVER [ IF EXISTS ] servername [ CASCADE | RESTRICT ]") },
+
+    { "DROP TABLE",
+      N_("remove a table"),
+      N_("DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP TABLESPACE",
+      N_("remove a tablespace"),
+      N_("DROP TABLESPACE [ IF EXISTS ] tablespacename") },
+
+    { "DROP TEXT SEARCH CONFIGURATION",
+      N_("remove a text search configuration"),
+      N_("DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP TEXT SEARCH DICTIONARY",
+      N_("remove a text search dictionary"),
+      N_("DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP TEXT SEARCH PARSER",
+      N_("remove a text search parser"),
+      N_("DROP TEXT SEARCH PARSER [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP TEXT SEARCH TEMPLATE",
+      N_("remove a text search template"),
+      N_("DROP TEXT SEARCH TEMPLATE [ IF EXISTS ] name [ CASCADE | RESTRICT ]") },
+
+    { "DROP TRIGGER",
+      N_("remove a trigger"),
+      N_("DROP TRIGGER [ IF EXISTS ] name ON table [ CASCADE | RESTRICT ]") },
+
+    { "DROP TYPE",
+      N_("remove a data type"),
+      N_("DROP TYPE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "DROP USER",
+      N_("remove a database role"),
+      N_("DROP USER [ IF EXISTS ] name [, ...]") },
+
+    { "DROP USER MAPPING",
+      N_("remove a user mapping for a foreign server"),
+      N_("DROP USER MAPPING [ IF EXISTS ] FOR { username | USER | CURRENT_USER | PUBLIC } SERVER servername") },
+
+    { "DROP VIEW",
+      N_("remove a view"),
+      N_("DROP VIEW [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]") },
+
+    { "END",
+      N_("commit the current transaction"),
+      N_("END [ WORK | TRANSACTION ]") },
+
+    { "EXECUTE",
+      N_("execute a prepared statement"),
+      N_("EXECUTE name [ ( parameter [, ...] ) ]") },
+
+    { "EXPLAIN",
+      N_("show the execution plan of a statement"),
+      N_("EXPLAIN [ ANALYZE ] [ VERBOSE ] statement") },
+
+    { "FETCH",
+      N_("retrieve rows from a query using a cursor"),
+      N_("FETCH [ direction { FROM | IN } ] cursorname\n\nwhere direction can be empty or one of:\n\n    NEXT\n    PRIOR\n    FIRST\n    LAST\n    ABSOLUTE count\n    RELATIVE count\n    count\n    ALL\n    FORWARD\n    FORWARD count\n    FORWARD ALL\n    BACKWARD\n    BACKWARD count\n    BACKWARD ALL") },
+
+    { "GRANT",
+      N_("define access privileges"),
+      N_("GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }\n    [,...] | ALL [ PRIVILEGES ] }\n    ON [ TABLE ] tablename [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { { SELECT | INSERT | UPDATE | REFERENCES } ( column [, ...] )\n    [,...] | ALL [ PRIVILEGES ] ( column [, ...] ) }\n    ON [ TABLE ] tablename [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { { USAGE | SELECT | UPDATE }\n    [,...] | ALL [ PRIVILEGES ] }\n    ON SEQUENCE sequencename [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }\n    ON DATABASE dbname [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN DATA WRAPPER fdwname [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN SERVER servername [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { EXECUTE | ALL [ PRIVILEGES ] }\n    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON LANGUAGE langname [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }\n    ON SCHEMA schemaname [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT { CREATE | ALL [ PRIVILEGES ] }\n    ON TABLESPACE tablespacename [, ...]\n    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]\n\nGRANT role [, ...] TO rolename [, ...] [ WITH ADMIN OPTION ]") },
+
+    { "INSERT",
+      N_("create new rows in a table"),
+      N_("INSERT INTO table [ ( column [, ...] ) ]\n    { DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) [, ...] | query }\n    [ RETURNING * | output_expression [ [ AS ] output_name ] [, ...] ]") },
+
+    { "LISTEN",
+      N_("listen for a notification"),
+      N_("LISTEN name") },
+
+    { "LOAD",
+      N_("load a shared library file"),
+      N_("LOAD 'filename'") },
+
+    { "LOCK",
+      N_("lock a table"),
+      N_("LOCK [ TABLE ] [ ONLY ] name [ * ] [, ...] [ IN lockmode MODE ] [ NOWAIT ]\n\nwhere lockmode is one of:\n\n    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE\n    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE") },
+
+    { "MOVE",
+      N_("position a cursor"),
+      N_("MOVE [ direction { FROM | IN } ] cursorname") },
+
+    { "NOTIFY",
+      N_("generate a notification"),
+      N_("NOTIFY name") },
+
+    { "PREPARE",
+      N_("prepare a statement for execution"),
+      N_("PREPARE name [ ( datatype [, ...] ) ] AS statement") },
+
+    { "PREPARE TRANSACTION",
+      N_("prepare the current transaction for two-phase commit"),
+      N_("PREPARE TRANSACTION transaction_id") },
+
+    { "REASSIGN OWNED",
+      N_("change the ownership of database objects owned by a database role"),
+      N_("REASSIGN OWNED BY old_role [, ...] TO new_role") },
+
+    { "REINDEX",
+      N_("rebuild indexes"),
+      N_("REINDEX { INDEX | TABLE | DATABASE | SYSTEM } name [ FORCE ]") },
+
+    { "RELEASE SAVEPOINT",
+      N_("destroy a previously defined savepoint"),
+      N_("RELEASE [ SAVEPOINT ] savepoint_name") },
+
+    { "RESET",
+      N_("restore the value of a run-time parameter to the default value"),
+      N_("RESET configuration_parameter\nRESET ALL") },
+
+    { "REVOKE",
+      N_("remove access privileges"),
+      N_("REVOKE [ GRANT OPTION FOR ]\n    { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }\n    [,...] | ALL [ PRIVILEGES ] }\n    ON [ TABLE ] tablename [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { SELECT | INSERT | UPDATE | REFERENCES } ( column [, ...] )\n    [,...] | ALL [ PRIVILEGES ] ( column [, ...] ) }\n    ON [ TABLE ] tablename [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { USAGE | SELECT | UPDATE }\n    [,...] | ALL [ PRIVILEGES ] }\n    ON SEQUENCE sequencename [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }\n    ON DATABASE dbname [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN DATA WRAPPER fdwname [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN SERVER servername [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { EXECUTE | ALL [ PRIVILEGES ] }\n    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON LANGUAGE langname [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }\n    ON SCHEMA schemaname [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { CREATE | ALL [ PRIVILEGES ] }\n    ON TABLESPACE tablespacename [, ...]\n    FROM { [ GROUP ] rolename | PUBLIC } [, ...]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ ADMIN OPTION FOR ]\n    role [, ...] FROM rolename [, ...]\n    [ CASCADE | RESTRICT ]") },
+
+    { "ROLLBACK",
+      N_("abort the current transaction"),
+      N_("ROLLBACK [ WORK | TRANSACTION ]") },
+
+    { "ROLLBACK PREPARED",
+      N_("cancel a transaction that was earlier prepared for two-phase commit"),
+      N_("ROLLBACK PREPARED transaction_id") },
+
+    { "ROLLBACK TO SAVEPOINT",
+      N_("roll back to a savepoint"),
+      N_("ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] savepoint_name") },
+
+    { "SAVEPOINT",
+      N_("define a new savepoint within the current transaction"),
+      N_("SAVEPOINT savepoint_name") },
+
+    { "SELECT",
+      N_("retrieve rows from a table or view"),
+      N_("[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    * | expression [ [ AS ] output_name ] [, ...]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY expression [, ...] ]\n    [ HAVING condition [, ...] ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]\n\nwhere from_item can be one of:\n\n    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]\n    with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]\n    function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n    from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]\n\nand with_query is:\n\n    with_query_name [ ( column_name [, ...] ) ] AS ( select )\n\nTABLE { [ ONLY ] table_name [ * ] | with_query_name }") },
+
+    { "SELECT INTO",
+      N_("define a new table from the results of a query"),
+      N_("[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    * | expression [ [ AS ] output_name ] [, ...]\n    INTO [ TEMPORARY | TEMP ] [ TABLE ] new_table\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY expression [, ...] ]\n    [ HAVING condition [, ...] ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]") },
+
+    { "SET",
+      N_("change a run-time parameter"),
+      N_("SET [ SESSION | LOCAL ] configuration_parameter { TO | = } { value | 'value' | DEFAULT }\nSET [ SESSION | LOCAL ] TIME ZONE { timezone | LOCAL | DEFAULT }") },
+
+    { "SET CONSTRAINTS",
+      N_("set constraint checking modes for the current transaction"),
+      N_("SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }") },
+
+    { "SET ROLE",
+      N_("set the current user identifier of the current session"),
+      N_("SET [ SESSION | LOCAL ] ROLE rolename\nSET [ SESSION | LOCAL ] ROLE NONE\nRESET ROLE") },
+
+    { "SET SESSION AUTHORIZATION",
+      N_("set the session user identifier and the current user identifier of the current session"),
+      N_("SET [ SESSION | LOCAL ] SESSION AUTHORIZATION username\nSET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT\nRESET SESSION AUTHORIZATION") },
+
+    { "SET TRANSACTION",
+      N_("set the characteristics of the current transaction"),
+      N_("SET TRANSACTION transaction_mode [, ...]\nSET SESSION CHARACTERISTICS AS TRANSACTION transaction_mode [, ...]\n\nwhere transaction_mode is one of:\n\n    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }\n    READ WRITE | READ ONLY") },
+
+    { "SHOW",
+      N_("show the value of a run-time parameter"),
+      N_("SHOW name\nSHOW ALL") },
+
+    { "START TRANSACTION",
+      N_("start a transaction block"),
+      N_("START TRANSACTION [ transaction_mode [, ...] ]\n\nwhere transaction_mode is one of:\n\n    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }\n    READ WRITE | READ ONLY") },
+
+    { "TABLE",
+      N_("retrieve rows from a table or view"),
+      N_("[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    * | expression [ [ AS ] output_name ] [, ...]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY expression [, ...] ]\n    [ HAVING condition [, ...] ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]\n\nwhere from_item can be one of:\n\n    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]\n    with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]\n    function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n    from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]\n\nand with_query is:\n\n    with_query_name [ ( column_name [, ...] ) ] AS ( select )\n\nTABLE { [ ONLY ] table_name [ * ] | with_query_name }") },
+
+    { "TRUNCATE",
+      N_("empty a table or set of tables"),
+      N_("TRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ]\n    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]") },
+
+    { "UNLISTEN",
+      N_("stop listening for a notification"),
+      N_("UNLISTEN { name | * }") },
+
+    { "UPDATE",
+      N_("update rows of a table"),
+      N_("UPDATE [ ONLY ] table [ * ] [ [ AS ] alias ]\n    SET { column = { expression | DEFAULT } |\n          ( column [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]\n    [ FROM fromlist ]\n    [ WHERE condition | WHERE CURRENT OF cursor_name ]\n    [ RETURNING * | output_expression [ [ AS ] output_name ] [, ...] ]") },
+
+    { "VACUUM",
+      N_("garbage-collect and optionally analyze a database"),
+      N_("VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table ]\nVACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ table [ (column [, ...] ) ] ]") },
+
+    { "VALUES",
+      N_("compute a set of rows"),
+      N_("VALUES ( expression [, ...] ) [, ...]\n    [ ORDER BY sort_expression [ ASC | DESC | USING operator ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]") },
+
+    { "WITH",
+      N_("retrieve rows from a table or view"),
+      N_("[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    * | expression [ [ AS ] output_name ] [, ...]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY expression [, ...] ]\n    [ HAVING condition [, ...] ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]\n\nwhere from_item can be one of:\n\n    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]\n    with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]\n    function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n    from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]\n\nand with_query is:\n\n    with_query_name [ ( column_name [, ...] ) ] AS ( select )\n\nTABLE { [ ONLY ] table_name [ * ] | with_query_name }") },
+
+
+    { NULL, NULL, NULL }    /* End of list marker */
+};
+
+
+#define QL_HELP_COUNT	140		/* number of help items */
+#define QL_MAX_CMD_LEN	32		/* largest strlen(cmd) */
+
+
+#endif /* SQL_HELP_H */
diff --git a/src/include/c.h b/src/include/c.h
index 3640125..484c2fa 100644
--- a/src/include/c.h
+++ b/src/include/c.h
@@ -850,6 +850,10 @@ extern int	fdatasync(int fildes);
 #define NON_EXEC_STATIC static
 #endif
 
+#ifndef DWORD
+#define DWORD int
+#endif
+
 /* /port compatibility functions */
 #include "port.h"
 
diff --git a/src/include/parser/gram.h b/src/include/parser/gram.h
new file mode 120000
index 0000000..fa46404
--- /dev/null
+++ b/src/include/parser/gram.h
@@ -0,0 +1 @@
+../../../src/backend/parser/gram.h
\ No newline at end of file
diff --git a/src/include/pg_config.h b/src/include/pg_config.h
new file mode 100644
index 0000000..09c59d8
--- /dev/null
+++ b/src/include/pg_config.h
@@ -0,0 +1,807 @@
+/* src/include/pg_config.h.  Generated from pg_config.h.in by configure.  */
+/* src/include/pg_config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to the type of arg 1 of 'accept' */
+#define ACCEPT_TYPE_ARG1 int
+
+/* Define to the type of arg 2 of 'accept' */
+#define ACCEPT_TYPE_ARG2 struct sockaddr *
+
+/* Define to the type of arg 3 of 'accept' */
+#define ACCEPT_TYPE_ARG3 socklen_t
+
+/* Define to the return type of 'accept' */
+#define ACCEPT_TYPE_RETURN int
+
+/* The normal alignment of `double', in bytes. */
+#define ALIGNOF_DOUBLE 8
+
+/* The normal alignment of `int', in bytes. */
+#define ALIGNOF_INT 4
+
+/* The normal alignment of `long', in bytes. */
+#define ALIGNOF_LONG 8
+
+/* The normal alignment of `long long int', in bytes. */
+/* #undef ALIGNOF_LONG_LONG_INT */
+
+/* The normal alignment of `short', in bytes. */
+#define ALIGNOF_SHORT 2
+
+/* Size of a disk block --- this also limits the size of a tuple. You can set
+   it bigger if you need bigger tuples (although TOAST should reduce the need
+   to have large tuples, since fields can be spread across multiple tuples).
+   BLCKSZ must be a power of 2. The maximum possible value of BLCKSZ is
+   currently 2^15 (32768). This is determined by the 15-bit widths of the
+   lp_off and lp_len fields in ItemIdData (see include/storage/itemid.h).
+   Changing BLCKSZ requires an initdb. */
+#define BLCKSZ 8192
+
+/* Define to the default TCP port number on which the server listens and to
+   which clients will try to connect. This can be overridden at run-time, but
+   it's convenient if your clients have the right default compiled in.
+   (--with-pgport=PORTNUM) */
+#define DEF_PGPORT 5432
+
+/* Define to the default TCP port number as a string constant. */
+#define DEF_PGPORT_STR "5432"
+
+/* Define to 1 to enable DTrace support. (--enable-dtrace) */
+/* #undef ENABLE_DTRACE */
+
+/* Define to build with GSSAPI support. (--with-gssapi) */
+/* #undef ENABLE_GSS */
+
+/* Define to 1 if you want National Language Support. (--enable-nls) */
+/* #undef ENABLE_NLS */
+
+/* Define to 1 to build client libraries as thread-safe code.
+   (--enable-thread-safety) */
+/* #undef ENABLE_THREAD_SAFETY */
+
+/* float4 values are passed by value if 'true', by reference if 'false' */
+#define FLOAT4PASSBYVAL true
+
+/* float8, int8, and related values are passed by value if 'true', by
+   reference if 'false' */
+#define FLOAT8PASSBYVAL true
+
+/* Define to 1 if getpwuid_r() takes a 5th argument. */
+/* #undef GETPWUID_R_5ARG */
+
+/* Define to 1 if gettimeofday() takes only 1 argument. */
+/* #undef GETTIMEOFDAY_1ARG */
+
+#ifdef GETTIMEOFDAY_1ARG
+# define gettimeofday(a,b) gettimeofday(a)
+#endif
+
+/* Define to 1 if you have the `atexit' function. */
+#define HAVE_ATEXIT 1
+
+/* Define to 1 if you have the `cbrt' function. */
+#define HAVE_CBRT 1
+
+/* Define to 1 if you have the `class' function. */
+/* #undef HAVE_CLASS */
+
+/* Define to 1 if you have the `crypt' function. */
+#define HAVE_CRYPT 1
+
+/* Define to 1 if you have the <crypt.h> header file. */
+#define HAVE_CRYPT_H 1
+
+/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you
+   don't. */
+#define HAVE_DECL_FDATASYNC 1
+
+/* Define to 1 if you have the declaration of `F_FULLFSYNC', and to 0 if you
+   don't. */
+#define HAVE_DECL_F_FULLFSYNC 0
+
+/* Define to 1 if you have the declaration of `posix_fadvise', and to 0 if you
+   don't. */
+#define HAVE_DECL_POSIX_FADVISE 1
+
+/* Define to 1 if you have the declaration of `snprintf', and to 0 if you
+   don't. */
+#define HAVE_DECL_SNPRINTF 1
+
+/* Define to 1 if you have the declaration of `strlcat', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRLCAT 0
+
+/* Define to 1 if you have the declaration of `strlcpy', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRLCPY 0
+
+/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST 1
+
+/* Define to 1 if you have the declaration of `vsnprintf', and to 0 if you
+   don't. */
+#define HAVE_DECL_VSNPRINTF 1
+
+/* Define to 1 if you have the <dld.h> header file. */
+/* #undef HAVE_DLD_H */
+
+/* Define to 1 if you have the `dlopen' function. */
+#define HAVE_DLOPEN 1
+
+/* Define to 1 if you have the <editline/history.h> header file. */
+/* #undef HAVE_EDITLINE_HISTORY_H */
+
+/* Define to 1 if you have the <editline/readline.h> header file. */
+/* #undef HAVE_EDITLINE_READLINE_H */
+
+/* Define to 1 if you have the `ERR_set_mark' function. */
+#define HAVE_ERR_SET_MARK 1
+
+/* Define to 1 if you have the `fcvt' function. */
+#define HAVE_FCVT 1
+
+/* Define to 1 if you have the `fdatasync' function. */
+#define HAVE_FDATASYNC 1
+
+/* Define to 1 if you have the `fpclass' function. */
+/* #undef HAVE_FPCLASS */
+
+/* Define to 1 if you have the `fp_class' function. */
+/* #undef HAVE_FP_CLASS */
+
+/* Define to 1 if you have the `fp_class_d' function. */
+/* #undef HAVE_FP_CLASS_D */
+
+/* Define to 1 if you have the <fp_class.h> header file. */
+/* #undef HAVE_FP_CLASS_H */
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if your compiler understands __func__. */
+#define HAVE_FUNCNAME__FUNC 1
+
+/* Define to 1 if your compiler understands __FUNCTION__. */
+/* #undef HAVE_FUNCNAME__FUNCTION */
+
+/* Define to 1 if you have __sync_lock_test_and_set(int *) and friends. */
+#define HAVE_GCC_INT_ATOMICS 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `gethostbyname_r' function. */
+/* #undef HAVE_GETHOSTBYNAME_R */
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long' function. */
+#define HAVE_GETOPT_LONG 1
+
+/* Define to 1 if you have the `getpeereid' function. */
+/* #undef HAVE_GETPEEREID */
+
+/* Define to 1 if you have the `getpeerucred' function. */
+/* #undef HAVE_GETPEERUCRED */
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+/* #undef HAVE_GETPWUID_R */
+
+/* Define to 1 if you have the `getrlimit' function. */
+#define HAVE_GETRLIMIT 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+/* #undef HAVE_GETTIMEOFDAY */
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_H */
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_H */
+
+/* Define to 1 if you have the <history.h> header file. */
+/* #undef HAVE_HISTORY_H */
+
+/* Define to 1 if you have the <ieeefp.h> header file. */
+/* #undef HAVE_IEEEFP_H */
+
+/* Define to 1 if you have the `inet_aton' function. */
+#define HAVE_INET_ATON 1
+
+/* Define to 1 if the system has the type `int64'. */
+/* #undef HAVE_INT64 */
+
+/* Define to 1 if the system has the type `int8'. */
+/* #undef HAVE_INT8 */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the global variable 'int opterr'. */
+#define HAVE_INT_OPTERR 1
+
+/* Define to 1 if you have the global variable 'int optreset'. */
+/* #undef HAVE_INT_OPTRESET */
+
+/* Define to 1 if you have the global variable 'int timezone'. */
+#define HAVE_INT_TIMEZONE 
+
+/* Define to 1 if you have support for IPv6. */
+#define HAVE_IPV6 1
+
+/* Define to 1 if you have isinf(). */
+#define HAVE_ISINF 1
+
+/* Define to 1 if you have the <kernel/image.h> header file. */
+/* #undef HAVE_KERNEL_IMAGE_H */
+
+/* Define to 1 if you have the <kernel/OS.h> header file. */
+/* #undef HAVE_KERNEL_OS_H */
+
+/* Define to 1 if `e_data' is member of `krb5_error'. */
+/* #undef HAVE_KRB5_ERROR_E_DATA */
+
+/* Define to 1 if `text.data' is member of `krb5_error'. */
+/* #undef HAVE_KRB5_ERROR_TEXT_DATA */
+
+/* Define to 1 if you have krb5_free_unparsed_name */
+/* #undef HAVE_KRB5_FREE_UNPARSED_NAME */
+
+/* Define to 1 if `client' is member of `krb5_ticket'. */
+/* #undef HAVE_KRB5_TICKET_CLIENT */
+
+/* Define to 1 if `enc_part2' is member of `krb5_ticket'. */
+/* #undef HAVE_KRB5_TICKET_ENC_PART2 */
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+/* #undef HAVE_LANGINFO_H */
+
+/* Define to 1 if you have the <ldap.h> header file. */
+/* #undef HAVE_LDAP_H */
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#define HAVE_LIBCRYPTO 1
+
+/* Define to 1 if you have the `eay32' library (-leay32). */
+/* #undef HAVE_LIBEAY32 */
+
+/* Define to 1 if you have the `ldap' library (-lldap). */
+/* #undef HAVE_LIBLDAP */
+
+/* Define to 1 if you have the `ldap_r' library (-lldap_r). */
+/* #undef HAVE_LIBLDAP_R */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define HAVE_LIBM 1
+
+/* Define to 1 if you have the `pam' library (-lpam). */
+/* #undef HAVE_LIBPAM */
+
+/* Define if you have a function readline library */
+/* #undef HAVE_LIBREADLINE */
+
+/* Define to 1 if you have the `ssl' library (-lssl). */
+#define HAVE_LIBSSL 1
+
+/* Define to 1 if you have the `ssleay32' library (-lssleay32). */
+/* #undef HAVE_LIBSSLEAY32 */
+
+/* Define to 1 if you have the `wldap32' library (-lwldap32). */
+/* #undef HAVE_LIBWLDAP32 */
+
+/* Define to 1 if you have the `xml2' library (-lxml2). */
+/* #undef HAVE_LIBXML2 */
+
+/* Define to 1 if you have the `xslt' library (-lxslt). */
+/* #undef HAVE_LIBXSLT */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define HAVE_LIBZ 1
+
+/* Define to 1 if constants of type 'long long int' should have the suffix LL.
+   */
+/* #undef HAVE_LL_CONSTANTS */
+
+/* Define to 1 if `long int' works and is 64 bits. */
+#define HAVE_LONG_INT_64 1
+
+/* Define to 1 if `long long int' works and is 64 bits. */
+/* #undef HAVE_LONG_LONG_INT_64 */
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#define HAVE_NETINET_TCP_H 1
+
+/* Define to 1 if you have the `on_exit' function. */
+/* #undef HAVE_ON_EXIT */
+
+/* Define to 1 if you have the <ossp/uuid.h> header file. */
+/* #undef HAVE_OSSP_UUID_H */
+
+/* Define to 1 if you have the <pam/pam_appl.h> header file. */
+/* #undef HAVE_PAM_PAM_APPL_H */
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `posix_fadvise' function. */
+#define HAVE_POSIX_FADVISE 1
+
+/* Define to 1 if you have the POSIX signal interface. */
+#define HAVE_POSIX_SIGNALS 
+
+/* Define to 1 if you have the `pstat' function. */
+/* #undef HAVE_PSTAT */
+
+/* Define to 1 if the PS_STRINGS thing exists. */
+/* #undef HAVE_PS_STRINGS */
+
+/* Define if you have POSIX threads libraries and header files. */
+/* #undef HAVE_PTHREAD */
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the `random' function. */
+#define HAVE_RANDOM 1
+
+/* Define to 1 if you have the <readline.h> header file. */
+/* #undef HAVE_READLINE_H */
+
+/* Define to 1 if you have the <readline/history.h> header file. */
+/* #undef HAVE_READLINE_HISTORY_H */
+
+/* Define to 1 if you have the <readline/readline.h> header file. */
+/* #undef HAVE_READLINE_READLINE_H */
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `replace_history_entry' function. */
+/* #undef HAVE_REPLACE_HISTORY_ENTRY */
+
+/* Define to 1 if you have the `rint' function. */
+#define HAVE_RINT 1
+
+/* Define to 1 if you have the global variable
+   'rl_completion_append_character'. */
+/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */
+
+/* Define to 1 if you have the `rl_completion_matches' function. */
+/* #undef HAVE_RL_COMPLETION_MATCHES */
+
+/* Define to 1 if you have the `rl_filename_completion_function' function. */
+/* #undef HAVE_RL_FILENAME_COMPLETION_FUNCTION */
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define to 1 if you have the `setproctitle' function. */
+/* #undef HAVE_SETPROCTITLE */
+
+/* Define to 1 if you have the `setsid' function. */
+#define HAVE_SETSID 1
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#define HAVE_SIGPROCMASK 1
+
+/* Define to 1 if you have sigsetjmp(). */
+#define HAVE_SIGSETJMP 1
+
+/* Define to 1 if the system has the type `sig_atomic_t'. */
+#define HAVE_SIG_ATOMIC_T 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have spinlocks. */
+#define HAVE_SPINLOCKS 1
+
+/* Define to 1 if you have the `srandom' function. */
+#define HAVE_SRANDOM 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+/* #undef HAVE_STRERROR_R */
+
+/* Define to 1 if cpp supports the ANSI # stringizing operator. */
+#define HAVE_STRINGIZE 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the `strtol' function. */
+#define HAVE_STRTOL 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtoq' function. */
+/* #undef HAVE_STRTOQ */
+
+/* Define to 1 if you have the `strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* Define to 1 if you have the `strtoull' function. */
+#define HAVE_STRTOULL 1
+
+/* Define to 1 if you have the `strtouq' function. */
+/* #undef HAVE_STRTOUQ */
+
+/* Define to 1 if the system has the type `struct addrinfo'. */
+#define HAVE_STRUCT_ADDRINFO 1
+
+/* Define to 1 if the system has the type `struct cmsgcred'. */
+/* #undef HAVE_STRUCT_CMSGCRED */
+
+/* Define to 1 if the system has the type `struct fcred'. */
+/* #undef HAVE_STRUCT_FCRED */
+
+/* Define to 1 if the system has the type `struct option'. */
+#define HAVE_STRUCT_OPTION 1
+
+/* Define to 1 if `sa_len' is member of `struct sockaddr'. */
+/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if `ss_family' is member of `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
+
+/* Define to 1 if `ss_len' is member of `struct sockaddr_storage'. */
+/* #undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */
+
+/* Define to 1 if `__ss_family' is member of `struct sockaddr_storage'. */
+/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
+
+/* Define to 1 if `__ss_len' is member of `struct sockaddr_storage'. */
+/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_LEN */
+
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define HAVE_STRUCT_SOCKADDR_UN 1
+
+/* Define to 1 if the system has the type `struct sockcred'. */
+/* #undef HAVE_STRUCT_SOCKCRED */
+
+/* Define to 1 if `tm_zone' is member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_ZONE 1
+
+/* Define to 1 if you have the <SupportDefs.h> header file. */
+/* #undef HAVE_SUPPORTDEFS_H */
+
+/* Define to 1 if you have the `symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the syslog interface. */
+#define HAVE_SYSLOG 1
+
+/* Define to 1 if you have the <sys/ipc.h> header file. */
+#define HAVE_SYS_IPC_H 1
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#define HAVE_SYS_POLL_H 1
+
+/* Define to 1 if you have the <sys/pstat.h> header file. */
+/* #undef HAVE_SYS_PSTAT_H */
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/sem.h> header file. */
+#define HAVE_SYS_SEM_H 1
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#define HAVE_SYS_SHM_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/tas.h> header file. */
+/* #undef HAVE_SYS_TAS_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <termios.h> header file. */
+#define HAVE_TERMIOS_H 1
+
+/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use
+   `HAVE_STRUCT_TM_TM_ZONE' instead. */
+#define HAVE_TM_ZONE 1
+
+/* Define to 1 if you have the `towlower' function. */
+#define HAVE_TOWLOWER 1
+
+/* Define to 1 if you have the external array `tzname'. */
+#define HAVE_TZNAME 1
+
+/* Define to 1 if you have the <ucred.h> header file. */
+/* #undef HAVE_UCRED_H */
+
+/* Define to 1 if the system has the type `uint64'. */
+/* #undef HAVE_UINT64 */
+
+/* Define to 1 if the system has the type `uint8'. */
+/* #undef HAVE_UINT8 */
+
+/* Define to 1 if the system has the type `union semun'. */
+/* #undef HAVE_UNION_SEMUN */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have unix sockets. */
+#define HAVE_UNIX_SOCKETS 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if you have the `utime' function. */
+#define HAVE_UTIME 1
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if you have the <uuid.h> header file. */
+/* #undef HAVE_UUID_H */
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define HAVE_WAITPID 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the `wcstombs' function. */
+#define HAVE_WCSTOMBS 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if you have the <winldap.h> header file. */
+/* #undef HAVE_WINLDAP_H */
+
+/* Define to the appropriate snprintf format for 64-bit ints. */
+#define INT64_FORMAT "%ld"
+
+/* Define to build with Kerberos 5 support. (--with-krb5) */
+/* #undef KRB5 */
+
+/* Define as the maximum alignment requirement of any C data type. */
+#define MAXIMUM_ALIGNOF 8
+
+/* Define bytes to use libc memset(). */
+#define MEMSET_LOOP_LIMIT 1024
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "pgsql-bugs@postgresql.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "PostgreSQL"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "PostgreSQL 8.4.17"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "postgresql"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "8.4.17"
+
+/* Define to the name of the default PostgreSQL service principal in Kerberos.
+   (--with-krb-srvnam=NAME) */
+#define PG_KRB_SRVNAM "postgres"
+
+/* PostgreSQL major version as a string */
+#define PG_MAJORVERSION "8.4"
+
+/* PostgreSQL version as a string */
+#define PG_VERSION "8.4.17"
+
+/* PostgreSQL version as a number */
+#define PG_VERSION_NUM 80417
+
+/* A string containing the version number, platform, and C compiler */
+#define PG_VERSION_STR "PostgreSQL 8.4.17 on x86_64-unknown-linux-gnu, compiled by GCC gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3, 64-bit"
+
+/* Define to 1 to allow profiling output to be saved separately for each
+   process. */
+/* #undef PROFILE_PID_DIR */
+
+/* Define to the necessary symbol if this constant uses a non-standard name on
+   your system. */
+/* #undef PTHREAD_CREATE_JOINABLE */
+
+/* RELSEG_SIZE is the maximum number of blocks allowed in one disk file. Thus,
+   the maximum size of a single file is RELSEG_SIZE * BLCKSZ; relations bigger
+   than that are divided into multiple files. RELSEG_SIZE * BLCKSZ must be
+   less than your OS' limit on file size. This is often 2 GB or 4GB in a
+   32-bit operating system, unless you have large file support enabled. By
+   default, we make the limit 1 GB to avoid any possible integer-overflow
+   problems within the OS. A limit smaller than necessary only means we divide
+   a large relation into more chunks than necessary, so it seems best to err
+   in the direction of a small limit. A power-of-2 value is recommended to
+   save a few cycles in md.c, but is not absolutely required. Changing
+   RELSEG_SIZE requires an initdb. */
+#define RELSEG_SIZE 131072
+
+/* The size of `off_t', as computed by sizeof. */
+#define SIZEOF_OFF_T 8
+
+/* The size of `size_t', as computed by sizeof. */
+#define SIZEOF_SIZE_T 8
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 8
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r() returns a int. */
+/* #undef STRERROR_R_INT */
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Define to the appropriate snprintf format for unsigned 64-bit ints. */
+#define UINT64_FORMAT "%lu"
+
+/* Define to 1 to build with assertion checks. (--enable-cassert) */
+/* #undef USE_ASSERT_CHECKING */
+
+/* Define to 1 to build with Bonjour support. (--with-bonjour) */
+/* #undef USE_BONJOUR */
+
+/* Define to 1 if you want float4 values to be passed by value.
+   (--enable-float4-byval) */
+#define USE_FLOAT4_BYVAL 1
+
+/* Define to 1 if you want float8, int8, etc values to be passed by value.
+   (--enable-float8-byval) */
+#define USE_FLOAT8_BYVAL 1
+
+/* Define to 1 if you want 64-bit integer timestamp and interval support.
+   (--enable-integer-datetimes) */
+#define USE_INTEGER_DATETIMES 1
+
+/* Define to 1 to build with LDAP support. (--with-ldap) */
+/* #undef USE_LDAP */
+
+/* Define to 1 to build with XML support. (--with-libxml) */
+/* #undef USE_LIBXML */
+
+/* Define to 1 to use XSLT support when building contrib/xml2.
+   (--with-libxslt) */
+/* #undef USE_LIBXSLT */
+
+/* Define to select named POSIX semaphores. */
+/* #undef USE_NAMED_POSIX_SEMAPHORES */
+
+/* Define to 1 to build with PAM support. (--with-pam) */
+/* #undef USE_PAM */
+
+/* Use replacement snprintf() functions. */
+/* #undef USE_REPL_SNPRINTF */
+
+/* Define to build with (Open)SSL support. (--with-openssl) */
+#define USE_SSL 1
+#define OPENSSL_NO_ENGINE
+
+/* Define to select SysV-style semaphores. */
+#define USE_SYSV_SEMAPHORES 1
+
+/* Define to select SysV-style shared memory. */
+#define USE_SYSV_SHARED_MEMORY 1
+
+/* Define to select unnamed POSIX semaphores. */
+/* #undef USE_UNNAMED_POSIX_SEMAPHORES */
+
+/* Define to select Win32-style semaphores. */
+/* #undef USE_WIN32_SEMAPHORES */
+
+/* Define to select Win32-style shared memory. */
+/* #undef USE_WIN32_SHARED_MEMORY */
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* #undef WORDS_BIGENDIAN */
+
+/* Size of a WAL file block. This need have no particular relation to BLCKSZ.
+   XLOG_BLCKSZ must be a power of 2, and if your system supports O_DIRECT I/O,
+   XLOG_BLCKSZ must be a multiple of the alignment requirement for direct-I/O
+   buffers, else direct I/O may fail. Changing XLOG_BLCKSZ requires an initdb.
+   */
+#define XLOG_BLCKSZ 8192
+
+/* XLOG_SEG_SIZE is the size of a single WAL file. This must be a power of 2
+   and larger than XLOG_BLCKSZ (preferably, a great deal larger than
+   XLOG_BLCKSZ). Changing XLOG_SEG_SIZE requires an initdb. */
+#define XLOG_SEG_SIZE (16 * 1024 * 1024)
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to empty if the C compiler does not understand signed types. */
+/* #undef signed */
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+/* #undef volatile */
diff --git a/src/include/pg_config_manual.h b/src/include/pg_config_manual.h
index 3a93328..a627512 100644
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -146,7 +146,7 @@
  * here's where to twiddle it.  You can also override this at runtime
  * with the postmaster's -k switch.
  */
-#define DEFAULT_PGSOCKET_DIR  "/tmp"
+#define DEFAULT_PGSOCKET_DIR  "/var/run/postgresql"
 
 /*
  * The random() function is expected to yield values between 0 and
diff --git a/src/include/pg_config_os.h b/src/include/pg_config_os.h
new file mode 120000
index 0000000..eacada2
--- /dev/null
+++ b/src/include/pg_config_os.h
@@ -0,0 +1 @@
+../.././src/include/port/linux.h
\ No newline at end of file
diff --git a/src/include/stamp-h b/src/include/stamp-h
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/src/include/stamp-h
@@ -0,0 +1 @@
+
diff --git a/src/include/utils/fmgroids.h b/src/include/utils/fmgroids.h
new file mode 120000
index 0000000..8bfb9e2
--- /dev/null
+++ b/src/include/utils/fmgroids.h
@@ -0,0 +1 @@
+../../../src/backend/utils/fmgroids.h
\ No newline at end of file
diff --git a/src/include/utils/probes.h b/src/include/utils/probes.h
new file mode 120000
index 0000000..1aef642
--- /dev/null
+++ b/src/include/utils/probes.h
@@ -0,0 +1 @@
+../../../src/backend/utils/probes.h
\ No newline at end of file
diff --git a/src/interfaces/ecpg/include/stamp-h b/src/interfaces/ecpg/include/stamp-h
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/src/interfaces/ecpg/include/stamp-h
@@ -0,0 +1 @@
+
diff --git a/src/interfaces/libpq/Android.mk b/src/interfaces/libpq/Android.mk
new file mode 100644
index 0000000..e6ec856
--- /dev/null
+++ b/src/interfaces/libpq/Android.mk
@@ -0,0 +1,36 @@
+# check out the 'android build cookbook' page
+# for some good definitions
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/Config.mk
+
+LOCAL_MODULE:= libpq
+# only heavily used modules should only prelinked
+LOCAL_PRELINK_MODULE:= false
+
+LOCAL_ARM_MODE:= arm
+
+LOCAL_REQUIRED_MODULES:= libpgport libssl libcrypto
+
+LOCAL_SHARED_LIBRARIES+= libssl libcrypto
+LOCAL_STATIC_LIBRARIES+= libpgport
+
+LOCAL_LDLIBS := -L$(LOCAL_PATH)/../../../../openssl-android/libs/armeabi -lssl -lcrypto
+
+LOCAL_SRC_FILES:= $(SRC_FILES)
+
+LOCAL_CFLAGS:= -I$(LOCAL_PATH)/../../include \
+	-I$(LOCAL_PATH)/../../port \
+	-DFRONTEND -DSO_MAJOR_VERSION=5 -DUNSAFE_STAT_OK
+
+# need to add openssl/ssl.h openssl/crypto.h because
+# they are not 'installed' into the out/ directory
+
+# git clone https://github.com/scottt/openssl-android.git ../../../../openssl-android
+LOCAL_CFLAGS+= -I$(LOCAL_PATH)/../../../../openssl-android/include
+
+# TODO: figure out rpath (maybe it's already added?)
+LOCAL_LDFLAGS:= -Wl,--version-script=$(LOCAL_PATH)/exports.list
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/src/interfaces/libpq/Config.mk b/src/interfaces/libpq/Config.mk
new file mode 100644
index 0000000..17f401c
--- /dev/null
+++ b/src/interfaces/libpq/Config.mk
@@ -0,0 +1,13 @@
+LOCAL_PATH:= $(call my-dir)
+
+SRC_FILES:= fe-auth.c fe-connect.c fe-exec.c fe-misc.c \
+	fe-print.c fe-lobj.c fe-protocol2.c fe-protocol3.c \
+	pqexpbuffer.c pqsignal.c fe-secure.c libpq-events.c \
+	md5.c ip.c wchar.c encnames.c noblock.c \
+	pgstrcasecmp.c thread.c strlcpy.c
+
+#SRC_FILES:= assert.c elog.c fe-auth.c fe-connect.c fe-exec.c fe-misc.c \
+#	fe-print.c fe-lobj.c fe-protocol2.c fe-protocol3.c \
+#	globals.c guc.c guc-file.c ipc.c pqexpbuffer.c pqsignal.c fe-secure.c libpq-events.c \
+#	localtime.c mcxt.c md5.c ip.c wchar.c encnames.c noblock.c \
+#	pgstrcasecmp.c pgtz.c proc.c ps_status.c stringinfo.c strftime.c thread.c
diff --git a/src/interfaces/libpq/encnames.c b/src/interfaces/libpq/encnames.c
new file mode 120000
index 0000000..9f2ae52
--- /dev/null
+++ b/src/interfaces/libpq/encnames.c
@@ -0,0 +1 @@
+../../backend/utils/mb/encnames.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/exports.list b/src/interfaces/libpq/exports.list
new file mode 100644
index 0000000..915bcd7
--- /dev/null
+++ b/src/interfaces/libpq/exports.list
@@ -0,0 +1,155 @@
+{ global:
+PQconnectdb;
+PQsetdbLogin;
+PQconndefaults;
+PQfinish;
+PQreset;
+PQrequestCancel;
+PQdb;
+PQuser;
+PQpass;
+PQhost;
+PQport;
+PQtty;
+PQoptions;
+PQstatus;
+PQerrorMessage;
+PQsocket;
+PQbackendPID;
+PQtrace;
+PQuntrace;
+PQsetNoticeProcessor;
+PQexec;
+PQnotifies;
+PQsendQuery;
+PQgetResult;
+PQisBusy;
+PQconsumeInput;
+PQgetline;
+PQputline;
+PQgetlineAsync;
+PQputnbytes;
+PQendcopy;
+PQfn;
+PQresultStatus;
+PQntuples;
+PQnfields;
+PQbinaryTuples;
+PQfname;
+PQfnumber;
+PQftype;
+PQfsize;
+PQfmod;
+PQcmdStatus;
+PQoidStatus;
+PQcmdTuples;
+PQgetvalue;
+PQgetlength;
+PQgetisnull;
+PQclear;
+PQmakeEmptyPGresult;
+PQprint;
+PQdisplayTuples;
+PQprintTuples;
+lo_open;
+lo_close;
+lo_read;
+lo_write;
+lo_lseek;
+lo_creat;
+lo_tell;
+lo_unlink;
+lo_import;
+lo_export;
+pgresStatus;
+PQmblen;
+PQresultErrorMessage;
+PQresStatus;
+termPQExpBuffer;
+appendPQExpBufferChar;
+initPQExpBuffer;
+resetPQExpBuffer;
+PQoidValue;
+PQclientEncoding;
+PQenv2encoding;
+appendBinaryPQExpBuffer;
+appendPQExpBufferStr;
+destroyPQExpBuffer;
+createPQExpBuffer;
+PQconninfoFree;
+PQconnectPoll;
+PQconnectStart;
+PQflush;
+PQisnonblocking;
+PQresetPoll;
+PQresetStart;
+PQsetClientEncoding;
+PQsetnonblocking;
+PQfreeNotify;
+PQescapeString;
+PQescapeBytea;
+printfPQExpBuffer;
+appendPQExpBuffer;
+pg_encoding_to_char;
+pg_utf_mblen;
+PQunescapeBytea;
+PQfreemem;
+PQtransactionStatus;
+PQparameterStatus;
+PQprotocolVersion;
+PQsetErrorVerbosity;
+PQsetNoticeReceiver;
+PQexecParams;
+PQsendQueryParams;
+PQputCopyData;
+PQputCopyEnd;
+PQgetCopyData;
+PQresultErrorField;
+PQftable;
+PQftablecol;
+PQfformat;
+PQexecPrepared;
+PQsendQueryPrepared;
+PQdsplen;
+PQserverVersion;
+PQgetssl;
+pg_char_to_encoding;
+pg_valid_server_encoding;
+pqsignal;
+PQprepare;
+PQsendPrepare;
+PQgetCancel;
+PQfreeCancel;
+PQcancel;
+lo_create;
+PQinitSSL;
+PQregisterThreadLock;
+PQescapeStringConn;
+PQescapeByteaConn;
+PQencryptPassword;
+PQisthreadsafe;
+enlargePQExpBuffer;
+PQnparams;
+PQparamtype;
+PQdescribePrepared;
+PQdescribePortal;
+PQsendDescribePrepared;
+PQsendDescribePortal;
+lo_truncate;
+PQconnectionUsedPassword;
+pg_valid_server_encoding_id;
+PQconnectionNeedsPassword;
+lo_import_with_oid;
+PQcopyResult;
+PQsetResultAttrs;
+PQsetvalue;
+PQresultAlloc;
+PQregisterEventProc;
+PQinstanceData;
+PQsetInstanceData;
+PQresultInstanceData;
+PQresultSetInstanceData;
+PQfireResultCreateEvents;
+PQconninfoParse;
+PQinitOpenSSL;
+ local: *; };
diff --git a/src/interfaces/libpq/ip.c b/src/interfaces/libpq/ip.c
new file mode 120000
index 0000000..150a88d
--- /dev/null
+++ b/src/interfaces/libpq/ip.c
@@ -0,0 +1 @@
+../../backend/libpq/ip.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/md5.c b/src/interfaces/libpq/md5.c
new file mode 120000
index 0000000..978dde3
--- /dev/null
+++ b/src/interfaces/libpq/md5.c
@@ -0,0 +1 @@
+../../backend/libpq/md5.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/noblock.c b/src/interfaces/libpq/noblock.c
new file mode 120000
index 0000000..2f8f39e
--- /dev/null
+++ b/src/interfaces/libpq/noblock.c
@@ -0,0 +1 @@
+../../port/noblock.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/pgstrcasecmp.c b/src/interfaces/libpq/pgstrcasecmp.c
new file mode 120000
index 0000000..123216d
--- /dev/null
+++ b/src/interfaces/libpq/pgstrcasecmp.c
@@ -0,0 +1 @@
+../../port/pgstrcasecmp.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/strlcpy.c b/src/interfaces/libpq/strlcpy.c
new file mode 120000
index 0000000..8d6f07e
--- /dev/null
+++ b/src/interfaces/libpq/strlcpy.c
@@ -0,0 +1 @@
+../../port/strlcpy.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/thread.c b/src/interfaces/libpq/thread.c
new file mode 120000
index 0000000..3ff94a8
--- /dev/null
+++ b/src/interfaces/libpq/thread.c
@@ -0,0 +1 @@
+../../port/thread.c
\ No newline at end of file
diff --git a/src/interfaces/libpq/wchar.c b/src/interfaces/libpq/wchar.c
new file mode 120000
index 0000000..f418c4c
--- /dev/null
+++ b/src/interfaces/libpq/wchar.c
@@ -0,0 +1 @@
+../../backend/utils/mb/wchar.c
\ No newline at end of file
diff --git a/src/port/Android.mk b/src/port/Android.mk
new file mode 100644
index 0000000..e2fe8e4
--- /dev/null
+++ b/src/port/Android.mk
@@ -0,0 +1,20 @@
+# check out the 'android build cookbook' page
+# for some good definitions
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/Config.mk
+
+LOCAL_MODULE:= libpgport
+
+#LOCAL_REQUIRED_MODULES:= libssl libcrypto
+#LOCAL_SHARED_LIBRARIES+= libssl libcrypto
+
+LOCAL_ARM_MODE:= arm
+
+LOCAL_SRC_FILES:= $(SRC_FILES)
+
+LOCAL_CFLAGS:= -I$(LOCAL_PATH) \
+	-I$(LOCAL_PATH)/../include \
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/src/port/Config.mk b/src/port/Config.mk
new file mode 100644
index 0000000..7937260
--- /dev/null
+++ b/src/port/Config.mk
@@ -0,0 +1,17 @@
+LOCAL_PATH:= $(call my-dir)
+
+#SRC_FILES:= chklocale.c copydir.c
+
+SRC_FILES:= chklocale.c \
+	dirmod.c exec.c \
+	noblock.c path.c pgsleep.c pgstrcasecmp.c \
+	qsort.c qsort_arg.c \
+	sprompt.c \
+	strlcat.c strlcpy.c thread.c
+
+# 
+
+## unnecessary files, mainly for win32
+# inet_aton.c getopt.c getopt_long.c gethostname.c crypt.c dirent.c getaddrinfo.c getrusage.c gettimeofday.c 
+# pipe.c random.c srandom.c strerror.c strtol.c 
+# unsetenv.c rand.c snprintf.c strtoul.c strdup.c fseeko.c isinf.c kill.c memcmp.c open.c  rint.c       
diff --git a/src/port/crypt.c b/src/port/crypt.c
index 920ab93..8ddcc2c 100644
--- a/src/port/crypt.c
+++ b/src/port/crypt.c
@@ -87,7 +87,9 @@ static int	des_cipher(const char *in, char *out, long salt, int num_iter);
  * define "B64" to be the declaration for a 64 bit integer.
  * XXX this feature is currently unused, see "endian" comment below.
  */
+#if 0
 #define B64 __int64
+#endif
 
 /*
  * define "LARGEDATA" to get faster permutations, by using about 72 kilobytes
@@ -105,7 +107,9 @@ static int	des_cipher(const char *in, char *out, long salt, int num_iter);
  * Define the "int32_t" type for integral type with a width of at least
  * 32 bits.
  */
+#if 0
 typedef int int32_t;
+#endif
 
 /* ==================================== */
 
diff --git a/src/port/exec.c b/src/port/exec.c
index 52484fa..225d478 100644
--- a/src/port/exec.c
+++ b/src/port/exec.c
@@ -190,10 +190,11 @@ find_my_exec(const char *argv0, char *retpath)
 				test_path[MAXPGPATH];
 	char	   *path;
 
+// TODO: replace with Android's E()
 	if (!getcwd(cwd, MAXPGPATH))
 	{
-		log_error(_("could not identify current directory: %s"),
-				  strerror(errno));
+//		log_error(_("could not identify current directory: %s"),
+//				  strerror(errno));
 		return -1;
 	}
 
@@ -210,8 +211,8 @@ find_my_exec(const char *argv0, char *retpath)
 
 		if (validate_exec(retpath) == 0)
 			return resolve_symlinks(retpath);
-
-		log_error(_("invalid binary \"%s\""), retpath);
+//TODO: replace with Android's E()
+//		log_error(_("invalid binary \"%s\""), retpath);
 		return -1;
 	}
 
@@ -260,14 +261,16 @@ find_my_exec(const char *argv0, char *retpath)
 				case -1:		/* wasn't even a candidate, keep looking */
 					break;
 				case -2:		/* found but disqualified */
-					log_error(_("could not read binary \"%s\""),
-							  retpath);
+// TODO: replace with Android's E()
+//					log_error(_("could not read binary \"%s\""),
+//							  retpath);
 					break;
 			}
 		} while (*endp);
 	}
 
-	log_error(_("could not find a \"%s\" to execute"), argv0);
+// TODO: replace with Android's E()
+//	log_error(_("could not find a \"%s\" to execute"), argv0);
 	return -1;
 }
 
@@ -306,8 +309,9 @@ resolve_symlinks(char *path)
 	 */
 	if (!getcwd(orig_wd, MAXPGPATH))
 	{
-		log_error(_("could not identify current directory: %s"),
-				  strerror(errno));
+// TODO: replace with Android's E()
+//		log_error(_("could not identify current directory: %s"),
+//				  strerror(errno));
 		return -1;
 	}
 
@@ -322,7 +326,8 @@ resolve_symlinks(char *path)
 			*lsep = '\0';
 			if (chdir(path) == -1)
 			{
-				log_error(_("could not change directory to \"%s\""), path);
+// TODO: replace with Android's E()
+//				log_error(_("could not change directory to \"%s\""), path);
 				return -1;
 			}
 			fname = lsep + 1;
@@ -337,7 +342,8 @@ resolve_symlinks(char *path)
 		rllen = readlink(fname, link_buf, sizeof(link_buf));
 		if (rllen < 0 || rllen >= sizeof(link_buf))
 		{
-			log_error(_("could not read symbolic link \"%s\""), fname);
+// TODO: replace with Android's E()
+//			log_error(_("could not read symbolic link \"%s\""), fname);
 			return -1;
 		}
 		link_buf[rllen] = '\0';
@@ -349,8 +355,9 @@ resolve_symlinks(char *path)
 
 	if (!getcwd(path, MAXPGPATH))
 	{
-		log_error(_("could not identify current directory: %s"),
-				  strerror(errno));
+// TODO: replace with Android's E()
+//		log_error(_("could not identify current directory: %s"),
+//				  strerror(errno));
 		return -1;
 	}
 	join_path_components(path, path, link_buf);
@@ -358,7 +365,8 @@ resolve_symlinks(char *path)
 
 	if (chdir(orig_wd) == -1)
 	{
-		log_error(_("could not change directory to \"%s\""), orig_wd);
+// TODO: replace with Android's E()
+//		log_error(_("could not change directory to \"%s\""), orig_wd);
 		return -1;
 	}
 #endif   /* HAVE_READLINK */
@@ -592,8 +600,10 @@ pclose_check(FILE *stream)
 		perror("pclose failed");
 	}
 	else if (WIFEXITED(exitstatus))
-		log_error(_("child process exited with exit code %d"),
-				  WEXITSTATUS(exitstatus));
+// TODO: replace with Android's E()
+		printf("");
+//		log_error(_("child process exited with exit code %d"),
+//				  WEXITSTATUS(exitstatus));
 	else if (WIFSIGNALED(exitstatus))
 #if defined(WIN32)
 		log_error(_("child process was terminated by exception 0x%X"),
@@ -605,15 +615,18 @@ pclose_check(FILE *stream)
 		snprintf(str, sizeof(str), "%d: %s", WTERMSIG(exitstatus),
 				 WTERMSIG(exitstatus) < NSIG ?
 				 sys_siglist[WTERMSIG(exitstatus)] : "(unknown)");
-		log_error(_("child process was terminated by signal %s"), str);
+// TODO: replace with Android's E()
+//		log_error(_("child process was terminated by signal %s"), str);
 	}
 #else
 		log_error(_("child process was terminated by signal %d"),
 				  WTERMSIG(exitstatus));
 #endif
 	else
-		log_error(_("child process exited with unrecognized status %d"),
-				  exitstatus);
+// TODO: replace with Android's E()
+		printf("");
+//		log_error(_("child process exited with unrecognized status %d"),
+//				  exitstatus);
 
 	return -1;
 }
diff --git a/src/port/exec.c.orig b/src/port/exec.c.orig
new file mode 100644
index 0000000..52484fa
--- /dev/null
+++ b/src/port/exec.c.orig
@@ -0,0 +1,870 @@
+/*-------------------------------------------------------------------------
+ *
+ * exec.c
+ *		Functions for finding and validating executable files
+ *
+ *
+ * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ *
+ * IDENTIFICATION
+ *	  $PostgreSQL: pgsql/src/port/exec.c,v 1.63.2.1 2009/11/14 15:39:45 mha Exp $
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef FRONTEND
+#include "postgres.h"
+#else
+#include "postgres_fe.h"
+#endif
+
+#include <grp.h>
+#include <pwd.h>
+#include <signal.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#ifndef S_IRUSR					/* XXX [TRH] should be in a header */
+#define S_IRUSR		 S_IREAD
+#define S_IWUSR		 S_IWRITE
+#define S_IXUSR		 S_IEXEC
+#define S_IRGRP		 ((S_IRUSR)>>3)
+#define S_IWGRP		 ((S_IWUSR)>>3)
+#define S_IXGRP		 ((S_IXUSR)>>3)
+#define S_IROTH		 ((S_IRUSR)>>6)
+#define S_IWOTH		 ((S_IWUSR)>>6)
+#define S_IXOTH		 ((S_IXUSR)>>6)
+#endif
+
+#ifndef FRONTEND
+/* We use only 3-parameter elog calls in this file, for simplicity */
+/* NOTE: caller must provide gettext call around str! */
+#define log_error(str, param)	elog(LOG, str, param)
+#else
+#define log_error(str, param)	(fprintf(stderr, str, param), fputc('\n', stderr))
+#endif
+
+#ifdef WIN32_ONLY_COMPILER
+#define getcwd(cwd,len)  GetCurrentDirectory(len, cwd)
+#endif
+
+static int	validate_exec(const char *path);
+static int	resolve_symlinks(char *path);
+static char *pipe_read_line(char *cmd, char *line, int maxsize);
+
+#ifdef WIN32
+static BOOL GetUserSid(PSID *ppSidUser, HANDLE hToken);
+#endif
+
+/*
+ * validate_exec -- validate "path" as an executable file
+ *
+ * returns 0 if the file is found and no error is encountered.
+ *		  -1 if the regular file "path" does not exist or cannot be executed.
+ *		  -2 if the file is otherwise valid but cannot be read.
+ */
+static int
+validate_exec(const char *path)
+{
+	struct stat buf;
+
+#ifndef WIN32
+	uid_t		euid;
+	struct group *gp;
+	struct passwd *pwp;
+	int			i;
+	int			in_grp = 0;
+#else
+	char		path_exe[MAXPGPATH + sizeof(".exe") - 1];
+#endif
+	int			is_r;
+	int			is_x;
+
+#ifdef WIN32
+	/* Win32 requires a .exe suffix for stat() */
+	if (strlen(path) >= strlen(".exe") &&
+		pg_strcasecmp(path + strlen(path) - strlen(".exe"), ".exe") != 0)
+	{
+		strcpy(path_exe, path);
+		strcat(path_exe, ".exe");
+		path = path_exe;
+	}
+#endif
+
+	/*
+	 * Ensure that the file exists and is a regular file.
+	 *
+	 * XXX if you have a broken system where stat() looks at the symlink
+	 * instead of the underlying file, you lose.
+	 */
+	if (stat(path, &buf) < 0)
+		return -1;
+
+	if (!S_ISREG(buf.st_mode))
+		return -1;
+
+	/*
+	 * Ensure that we are using an authorized executable.
+	 */
+
+	/*
+	 * Ensure that the file is both executable and readable (required for
+	 * dynamic loading).
+	 */
+#ifdef WIN32
+	is_r = buf.st_mode & S_IRUSR;
+	is_x = buf.st_mode & S_IXUSR;
+	return is_x ? (is_r ? 0 : -2) : -1;
+#else
+	euid = geteuid();
+
+	/* If owned by us, just check owner bits */
+	if (euid == buf.st_uid)
+	{
+		is_r = buf.st_mode & S_IRUSR;
+		is_x = buf.st_mode & S_IXUSR;
+		return is_x ? (is_r ? 0 : -2) : -1;
+	}
+
+	/* OK, check group bits */
+
+	pwp = getpwuid(euid);		/* not thread-safe */
+	if (pwp)
+	{
+		if (pwp->pw_gid == buf.st_gid)	/* my primary group? */
+			++in_grp;
+		else if (pwp->pw_name &&
+				 (gp = getgrgid(buf.st_gid)) != NULL && /* not thread-safe */
+				 gp->gr_mem != NULL)
+		{						/* try list of member groups */
+			for (i = 0; gp->gr_mem[i]; ++i)
+			{
+				if (!strcmp(gp->gr_mem[i], pwp->pw_name))
+				{
+					++in_grp;
+					break;
+				}
+			}
+		}
+		if (in_grp)
+		{
+			is_r = buf.st_mode & S_IRGRP;
+			is_x = buf.st_mode & S_IXGRP;
+			return is_x ? (is_r ? 0 : -2) : -1;
+		}
+	}
+
+	/* Check "other" bits */
+	is_r = buf.st_mode & S_IROTH;
+	is_x = buf.st_mode & S_IXOTH;
+	return is_x ? (is_r ? 0 : -2) : -1;
+#endif
+}
+
+
+/*
+ * find_my_exec -- find an absolute path to a valid executable
+ *
+ *	argv0 is the name passed on the command line
+ *	retpath is the output area (must be of size MAXPGPATH)
+ *	Returns 0 if OK, -1 if error.
+ *
+ * The reason we have to work so hard to find an absolute path is that
+ * on some platforms we can't do dynamic loading unless we know the
+ * executable's location.  Also, we need a full path not a relative
+ * path because we will later change working directory.  Finally, we want
+ * a true path not a symlink location, so that we can locate other files
+ * that are part of our installation relative to the executable.
+ *
+ * This function is not thread-safe because it calls validate_exec(),
+ * which calls getgrgid().	This function should be used only in
+ * non-threaded binaries, not in library routines.
+ */
+int
+find_my_exec(const char *argv0, char *retpath)
+{
+	char		cwd[MAXPGPATH],
+				test_path[MAXPGPATH];
+	char	   *path;
+
+	if (!getcwd(cwd, MAXPGPATH))
+	{
+		log_error(_("could not identify current directory: %s"),
+				  strerror(errno));
+		return -1;
+	}
+
+	/*
+	 * If argv0 contains a separator, then PATH wasn't used.
+	 */
+	if (first_dir_separator(argv0) != NULL)
+	{
+		if (is_absolute_path(argv0))
+			StrNCpy(retpath, argv0, MAXPGPATH);
+		else
+			join_path_components(retpath, cwd, argv0);
+		canonicalize_path(retpath);
+
+		if (validate_exec(retpath) == 0)
+			return resolve_symlinks(retpath);
+
+		log_error(_("invalid binary \"%s\""), retpath);
+		return -1;
+	}
+
+#ifdef WIN32
+	/* Win32 checks the current directory first for names without slashes */
+	join_path_components(retpath, cwd, argv0);
+	if (validate_exec(retpath) == 0)
+		return resolve_symlinks(retpath);
+#endif
+
+	/*
+	 * Since no explicit path was supplied, the user must have been relying on
+	 * PATH.  We'll search the same PATH.
+	 */
+	if ((path = getenv("PATH")) && *path)
+	{
+		char	   *startp = NULL,
+				   *endp = NULL;
+
+		do
+		{
+			if (!startp)
+				startp = path;
+			else
+				startp = endp + 1;
+
+			endp = first_path_separator(startp);
+			if (!endp)
+				endp = startp + strlen(startp); /* point to end */
+
+			StrNCpy(test_path, startp, Min(endp - startp + 1, MAXPGPATH));
+
+			if (is_absolute_path(test_path))
+				join_path_components(retpath, test_path, argv0);
+			else
+			{
+				join_path_components(retpath, cwd, test_path);
+				join_path_components(retpath, retpath, argv0);
+			}
+			canonicalize_path(retpath);
+
+			switch (validate_exec(retpath))
+			{
+				case 0: /* found ok */
+					return resolve_symlinks(retpath);
+				case -1:		/* wasn't even a candidate, keep looking */
+					break;
+				case -2:		/* found but disqualified */
+					log_error(_("could not read binary \"%s\""),
+							  retpath);
+					break;
+			}
+		} while (*endp);
+	}
+
+	log_error(_("could not find a \"%s\" to execute"), argv0);
+	return -1;
+}
+
+
+/*
+ * resolve_symlinks - resolve symlinks to the underlying file
+ *
+ * Replace "path" by the absolute path to the referenced file.
+ *
+ * Returns 0 if OK, -1 if error.
+ *
+ * Note: we are not particularly tense about producing nice error messages
+ * because we are not really expecting error here; we just determined that
+ * the symlink does point to a valid executable.
+ */
+static int
+resolve_symlinks(char *path)
+{
+#ifdef HAVE_READLINK
+	struct stat buf;
+	char		orig_wd[MAXPGPATH],
+				link_buf[MAXPGPATH];
+	char	   *fname;
+
+	/*
+	 * To resolve a symlink properly, we have to chdir into its directory and
+	 * then chdir to where the symlink points; otherwise we may fail to
+	 * resolve relative links correctly (consider cases involving mount
+	 * points, for example).  After following the final symlink, we use
+	 * getcwd() to figure out where the heck we're at.
+	 *
+	 * One might think we could skip all this if path doesn't point to a
+	 * symlink to start with, but that's wrong.  We also want to get rid of
+	 * any directory symlinks that are present in the given path. We expect
+	 * getcwd() to give us an accurate, symlink-free path.
+	 */
+	if (!getcwd(orig_wd, MAXPGPATH))
+	{
+		log_error(_("could not identify current directory: %s"),
+				  strerror(errno));
+		return -1;
+	}
+
+	for (;;)
+	{
+		char	   *lsep;
+		int			rllen;
+
+		lsep = last_dir_separator(path);
+		if (lsep)
+		{
+			*lsep = '\0';
+			if (chdir(path) == -1)
+			{
+				log_error(_("could not change directory to \"%s\""), path);
+				return -1;
+			}
+			fname = lsep + 1;
+		}
+		else
+			fname = path;
+
+		if (lstat(fname, &buf) < 0 ||
+			!S_ISLNK(buf.st_mode))
+			break;
+
+		rllen = readlink(fname, link_buf, sizeof(link_buf));
+		if (rllen < 0 || rllen >= sizeof(link_buf))
+		{
+			log_error(_("could not read symbolic link \"%s\""), fname);
+			return -1;
+		}
+		link_buf[rllen] = '\0';
+		strcpy(path, link_buf);
+	}
+
+	/* must copy final component out of 'path' temporarily */
+	strcpy(link_buf, fname);
+
+	if (!getcwd(path, MAXPGPATH))
+	{
+		log_error(_("could not identify current directory: %s"),
+				  strerror(errno));
+		return -1;
+	}
+	join_path_components(path, path, link_buf);
+	canonicalize_path(path);
+
+	if (chdir(orig_wd) == -1)
+	{
+		log_error(_("could not change directory to \"%s\""), orig_wd);
+		return -1;
+	}
+#endif   /* HAVE_READLINK */
+
+	return 0;
+}
+
+
+/*
+ * Find another program in our binary's directory,
+ * then make sure it is the proper version.
+ */
+int
+find_other_exec(const char *argv0, const char *target,
+				const char *versionstr, char *retpath)
+{
+	char		cmd[MAXPGPATH];
+	char		line[100];
+
+	if (find_my_exec(argv0, retpath) < 0)
+		return -1;
+
+	/* Trim off program name and keep just directory */
+	*last_dir_separator(retpath) = '\0';
+	canonicalize_path(retpath);
+
+	/* Now append the other program's name */
+	snprintf(retpath + strlen(retpath), MAXPGPATH - strlen(retpath),
+			 "/%s%s", target, EXE);
+
+	if (validate_exec(retpath) != 0)
+		return -1;
+
+	snprintf(cmd, sizeof(cmd), "\"%s\" -V", retpath);
+
+	if (!pipe_read_line(cmd, line, sizeof(line)))
+		return -1;
+
+	if (strcmp(line, versionstr) != 0)
+		return -2;
+
+	return 0;
+}
+
+
+/*
+ * The runtime library's popen() on win32 does not work when being
+ * called from a service when running on windows <= 2000, because
+ * there is no stdin/stdout/stderr.
+ *
+ * Executing a command in a pipe and reading the first line from it
+ * is all we need.
+ */
+static char *
+pipe_read_line(char *cmd, char *line, int maxsize)
+{
+#ifndef WIN32
+	FILE	   *pgver;
+
+	/* flush output buffers in case popen does not... */
+	fflush(stdout);
+	fflush(stderr);
+
+	errno = 0;
+	if ((pgver = popen(cmd, "r")) == NULL)
+	{
+		perror("popen failure");
+		return NULL;
+	}
+
+	errno = 0;
+	if (fgets(line, maxsize, pgver) == NULL)
+	{
+		if (feof(pgver))
+			fprintf(stderr, "no data was returned by command \"%s\"\n", cmd);
+		else
+			perror("fgets failure");
+		pclose(pgver);			/* no error checking */
+		return NULL;
+	}
+
+	if (pclose_check(pgver))
+		return NULL;
+
+	return line;
+#else							/* WIN32 */
+
+	SECURITY_ATTRIBUTES sattr;
+	HANDLE		childstdoutrd,
+				childstdoutwr,
+				childstdoutrddup;
+	PROCESS_INFORMATION pi;
+	STARTUPINFO si;
+	char	   *retval = NULL;
+
+	sattr.nLength = sizeof(SECURITY_ATTRIBUTES);
+	sattr.bInheritHandle = TRUE;
+	sattr.lpSecurityDescriptor = NULL;
+
+	if (!CreatePipe(&childstdoutrd, &childstdoutwr, &sattr, 0))
+		return NULL;
+
+	if (!DuplicateHandle(GetCurrentProcess(),
+						 childstdoutrd,
+						 GetCurrentProcess(),
+						 &childstdoutrddup,
+						 0,
+						 FALSE,
+						 DUPLICATE_SAME_ACCESS))
+	{
+		CloseHandle(childstdoutrd);
+		CloseHandle(childstdoutwr);
+		return NULL;
+	}
+
+	CloseHandle(childstdoutrd);
+
+	ZeroMemory(&pi, sizeof(pi));
+	ZeroMemory(&si, sizeof(si));
+	si.cb = sizeof(si);
+	si.dwFlags = STARTF_USESTDHANDLES;
+	si.hStdError = childstdoutwr;
+	si.hStdOutput = childstdoutwr;
+	si.hStdInput = INVALID_HANDLE_VALUE;
+
+	if (CreateProcess(NULL,
+					  cmd,
+					  NULL,
+					  NULL,
+					  TRUE,
+					  0,
+					  NULL,
+					  NULL,
+					  &si,
+					  &pi))
+	{
+		/* Successfully started the process */
+		char	   *lineptr;
+
+		ZeroMemory(line, maxsize);
+
+		/* Try to read at least one line from the pipe */
+		/* This may require more than one wait/read attempt */
+		for (lineptr = line; lineptr < line + maxsize - 1;)
+		{
+			DWORD		bytesread = 0;
+
+			/* Let's see if we can read */
+			if (WaitForSingleObject(childstdoutrddup, 10000) != WAIT_OBJECT_0)
+				break;			/* Timeout, but perhaps we got a line already */
+
+			if (!ReadFile(childstdoutrddup, lineptr, maxsize - (lineptr - line),
+						  &bytesread, NULL))
+				break;			/* Error, but perhaps we got a line already */
+
+			lineptr += strlen(lineptr);
+
+			if (!bytesread)
+				break;			/* EOF */
+
+			if (strchr(line, '\n'))
+				break;			/* One or more lines read */
+		}
+
+		if (lineptr != line)
+		{
+			/* OK, we read some data */
+			int			len;
+
+			/* If we got more than one line, cut off after the first \n */
+			lineptr = strchr(line, '\n');
+			if (lineptr)
+				*(lineptr + 1) = '\0';
+
+			len = strlen(line);
+
+			/*
+			 * If EOL is \r\n, convert to just \n. Because stdout is a
+			 * text-mode stream, the \n output by the child process is
+			 * received as \r\n, so we convert it to \n.  The server main.c
+			 * sets setvbuf(stdout, NULL, _IONBF, 0) which has the effect of
+			 * disabling \n to \r\n expansion for stdout.
+			 */
+			if (len >= 2 && line[len - 2] == '\r' && line[len - 1] == '\n')
+			{
+				line[len - 2] = '\n';
+				line[len - 1] = '\0';
+				len--;
+			}
+
+			/*
+			 * We emulate fgets() behaviour. So if there is no newline at the
+			 * end, we add one...
+			 */
+			if (len == 0 || line[len - 1] != '\n')
+				strcat(line, "\n");
+
+			retval = line;
+		}
+
+		CloseHandle(pi.hProcess);
+		CloseHandle(pi.hThread);
+	}
+
+	CloseHandle(childstdoutwr);
+	CloseHandle(childstdoutrddup);
+
+	return retval;
+#endif   /* WIN32 */
+}
+
+
+/*
+ * pclose() plus useful error reporting
+ * Is this necessary?  bjm 2004-05-11
+ * It is better here because pipe.c has win32 backend linkage.
+ */
+int
+pclose_check(FILE *stream)
+{
+	int			exitstatus;
+
+	exitstatus = pclose(stream);
+
+	if (exitstatus == 0)
+		return 0;				/* all is well */
+
+	if (exitstatus == -1)
+	{
+		/* pclose() itself failed, and hopefully set errno */
+		perror("pclose failed");
+	}
+	else if (WIFEXITED(exitstatus))
+		log_error(_("child process exited with exit code %d"),
+				  WEXITSTATUS(exitstatus));
+	else if (WIFSIGNALED(exitstatus))
+#if defined(WIN32)
+		log_error(_("child process was terminated by exception 0x%X"),
+				  WTERMSIG(exitstatus));
+#elif defined(HAVE_DECL_SYS_SIGLIST) && HAVE_DECL_SYS_SIGLIST
+	{
+		char		str[256];
+
+		snprintf(str, sizeof(str), "%d: %s", WTERMSIG(exitstatus),
+				 WTERMSIG(exitstatus) < NSIG ?
+				 sys_siglist[WTERMSIG(exitstatus)] : "(unknown)");
+		log_error(_("child process was terminated by signal %s"), str);
+	}
+#else
+		log_error(_("child process was terminated by signal %d"),
+				  WTERMSIG(exitstatus));
+#endif
+	else
+		log_error(_("child process exited with unrecognized status %d"),
+				  exitstatus);
+
+	return -1;
+}
+
+
+/*
+ *	set_pglocale_pgservice
+ *
+ *	Set application-specific locale and service directory
+ *
+ *	This function takes the value of argv[0] rather than a full path.
+ *
+ * (You may be wondering why this is in exec.c.  It requires this module's
+ * services and doesn't introduce any new dependencies, so this seems as
+ * good as anyplace.)
+ */
+void
+set_pglocale_pgservice(const char *argv0, const char *app)
+{
+	char		path[MAXPGPATH];
+	char		my_exec_path[MAXPGPATH];
+	char		env_path[MAXPGPATH + sizeof("PGSYSCONFDIR=")];	/* longer than
+																 * PGLOCALEDIR */
+
+	/* don't set LC_ALL in the backend */
+	if (strcmp(app, PG_TEXTDOMAIN("postgres")) != 0)
+		setlocale(LC_ALL, "");
+
+	if (find_my_exec(argv0, my_exec_path) < 0)
+		return;
+
+#ifdef ENABLE_NLS
+	get_locale_path(my_exec_path, path);
+	bindtextdomain(app, path);
+	textdomain(app);
+
+	if (getenv("PGLOCALEDIR") == NULL)
+	{
+		/* set for libpq to use */
+		snprintf(env_path, sizeof(env_path), "PGLOCALEDIR=%s", path);
+		canonicalize_path(env_path + 12);
+		putenv(strdup(env_path));
+	}
+#endif
+
+	if (getenv("PGSYSCONFDIR") == NULL)
+	{
+		get_etc_path(my_exec_path, path);
+
+		/* set for libpq to use */
+		snprintf(env_path, sizeof(env_path), "PGSYSCONFDIR=%s", path);
+		canonicalize_path(env_path + 13);
+		putenv(strdup(env_path));
+	}
+}
+
+#ifdef WIN32
+
+/*
+ * AddUserToTokenDacl(HANDLE hToken)
+ *
+ * This function adds the current user account to the restricted
+ * token used when we create a restricted process.
+ *
+ * This is required because of some security changes in Windows
+ * that appeared in patches to XP/2K3 and in Vista/2008.
+ *
+ * On these machines, the Administrator account is not included in
+ * the default DACL - you just get Administrators + System. For
+ * regular users you get User + System. Because we strip Administrators
+ * when we create the restricted token, we are left with only System
+ * in the DACL which leads to access denied errors for later CreatePipe()
+ * and CreateProcess() calls when running as Administrator.
+ *
+ * This function fixes this problem by modifying the DACL of the
+ * token the process will use, and explicitly re-adding the current
+ * user account.  This is still secure because the Administrator account
+ * inherits its privileges from the Administrators group - it doesn't
+ * have any of its own.
+ */
+BOOL
+AddUserToTokenDacl(HANDLE hToken)
+{
+	int			i;
+	ACL_SIZE_INFORMATION asi;
+	ACCESS_ALLOWED_ACE *pace;
+	DWORD		dwNewAclSize;
+	DWORD		dwSize = 0;
+	DWORD		dwTokenInfoLength = 0;
+	PACL		pacl = NULL;
+	PSID		psidUser = NULL;
+	TOKEN_DEFAULT_DACL tddNew;
+	TOKEN_DEFAULT_DACL *ptdd = NULL;
+	TOKEN_INFORMATION_CLASS tic = TokenDefaultDacl;
+	BOOL		ret = FALSE;
+
+	/* Figure out the buffer size for the DACL info */
+	if (!GetTokenInformation(hToken, tic, (LPVOID) NULL, dwTokenInfoLength, &dwSize))
+	{
+		if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
+		{
+			ptdd = (TOKEN_DEFAULT_DACL *) LocalAlloc(LPTR, dwSize);
+			if (ptdd == NULL)
+			{
+				log_error("could not allocate %lu bytes of memory", dwSize);
+				goto cleanup;
+			}
+
+			if (!GetTokenInformation(hToken, tic, (LPVOID) ptdd, dwSize, &dwSize))
+			{
+				log_error("could not get token information: %lu", GetLastError());
+				goto cleanup;
+			}
+		}
+		else
+		{
+			log_error("could not get token information buffer size: %lu", GetLastError());
+			goto cleanup;
+		}
+	}
+
+	/* Get the ACL info */
+	if (!GetAclInformation(ptdd->DefaultDacl, (LPVOID) &asi,
+						   (DWORD) sizeof(ACL_SIZE_INFORMATION),
+						   AclSizeInformation))
+	{
+		log_error("could not get ACL information: %lu", GetLastError());
+		goto cleanup;
+	}
+
+	/* Get the SID for the current user. We need to add this to the ACL. */
+	if (!GetUserSid(&psidUser, hToken))
+	{
+		log_error("could not get user SID: %lu", GetLastError());
+		goto cleanup;
+	}
+
+	/* Figure out the size of the new ACL */
+	dwNewAclSize = asi.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidUser) -sizeof(DWORD);
+
+	/* Allocate the ACL buffer & initialize it */
+	pacl = (PACL) LocalAlloc(LPTR, dwNewAclSize);
+	if (pacl == NULL)
+	{
+		log_error("could not allocate %lu bytes of memory", dwNewAclSize);
+		goto cleanup;
+	}
+
+	if (!InitializeAcl(pacl, dwNewAclSize, ACL_REVISION))
+	{
+		log_error("could not initialize ACL: %lu", GetLastError());
+		goto cleanup;
+	}
+
+	/* Loop through the existing ACEs, and build the new ACL */
+	for (i = 0; i < (int) asi.AceCount; i++)
+	{
+		if (!GetAce(ptdd->DefaultDacl, i, (LPVOID *) &pace))
+		{
+			log_error("could not get ACE: %lu", GetLastError());
+			goto cleanup;
+		}
+
+		if (!AddAce(pacl, ACL_REVISION, MAXDWORD, pace, ((PACE_HEADER) pace)->AceSize))
+		{
+			log_error("could not add ACE: %lu", GetLastError());
+			goto cleanup;
+		}
+	}
+
+	/* Add the new ACE for the current user */
+	if (!AddAccessAllowedAceEx(pacl, ACL_REVISION, OBJECT_INHERIT_ACE, GENERIC_ALL, psidUser))
+	{
+		log_error("could not add access allowed ACE: %lu", GetLastError());
+		goto cleanup;
+	}
+
+	/* Set the new DACL in the token */
+	tddNew.DefaultDacl = pacl;
+
+	if (!SetTokenInformation(hToken, tic, (LPVOID) &tddNew, dwNewAclSize))
+	{
+		log_error("could not set token information: %lu", GetLastError());
+		goto cleanup;
+	}
+
+	ret = TRUE;
+
+cleanup:
+	if (psidUser)
+		FreeSid(psidUser);
+
+	if (pacl)
+		LocalFree((HLOCAL) pacl);
+
+	if (ptdd)
+		LocalFree((HLOCAL) ptdd);
+
+	return ret;
+}
+
+/*
+ * GetUserSid*PSID *ppSidUser, HANDLE hToken)
+ *
+ * Get the SID for the current user
+ */
+static BOOL
+GetUserSid(PSID *ppSidUser, HANDLE hToken)
+{
+	DWORD		dwLength;
+	PTOKEN_USER pTokenUser = NULL;
+
+
+	if (!GetTokenInformation(hToken,
+							 TokenUser,
+							 pTokenUser,
+							 0,
+							 &dwLength))
+	{
+		if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
+		{
+			pTokenUser = (PTOKEN_USER) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
+
+			if (pTokenUser == NULL)
+			{
+				log_error("could not allocate %lu bytes of memory", dwLength);
+				return FALSE;
+			}
+		}
+		else
+		{
+			log_error("could not get token information buffer size: %lu", GetLastError());
+			return FALSE;
+		}
+	}
+
+	if (!GetTokenInformation(hToken,
+							 TokenUser,
+							 pTokenUser,
+							 dwLength,
+							 &dwLength))
+	{
+		HeapFree(GetProcessHeap(), 0, pTokenUser);
+		pTokenUser = NULL;
+
+		log_error("could not get token information: %lu", GetLastError());
+		return FALSE;
+	}
+
+	*ppSidUser = pTokenUser->User.Sid;
+	return TRUE;
+}
+
+#endif
diff --git a/src/port/pg_config_paths.h b/src/port/pg_config_paths.h
new file mode 100644
index 0000000..4cb58fc
--- /dev/null
+++ b/src/port/pg_config_paths.h
@@ -0,0 +1,12 @@
+#define PGBINDIR "/usr/lib/postgresql-8.4/bin"
+#define PGSHAREDIR "/usr/share/postgresql-8.4"
+#define SYSCONFDIR "/etc/postgresql-8.4"
+#define INCLUDEDIR "/usr/include/postgresql-8.4"
+#define PKGINCLUDEDIR "/usr/include/postgresql-8.4"
+#define INCLUDEDIRSERVER "/usr/include/postgresql-8.4/server"
+#define LIBDIR "/usr/lib/postgresql-8.4/lib"
+#define PKGLIBDIR "/usr/lib/postgresql-8.4/lib"
+#define LOCALEDIR "/usr/lib/postgresql-8.4/share/locale"
+#define DOCDIR "/usr/share/doc/postgresql-8.4"
+#define HTMLDIR "/usr/share/doc/postgresql-8.4"
+#define MANDIR "/usr/share/postgresql-8.4/man"
